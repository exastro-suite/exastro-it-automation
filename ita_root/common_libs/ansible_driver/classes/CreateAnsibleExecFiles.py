#   Copyright 2022 NEC Corporation
#
#   Licensed under the Apache License, Version 2.0 (the "License")
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#############################################################
# __init__
# getAnsibleWorkingDirectories
# lineno
# setITALocalVars
# getAnsibleDriverCommonShellPath
# CreateAnsibleWorkingDir
# CreateAnsibleWorkingFiles
# CreateHostsfile
# DeleteUnuseData
# InventryFileAddOptionCheckFormat
# CreateRoleHostvarsfiles
# CreateRoleHostvarsfile
# CreatePlaybookfile
# setAnsibleDriverID
# getAnsibleDriverID
# setAnsibleBaseDir
# getAnsibleBaseDir
# setAnsible_in_Dir
# getAnsible_in_Dir
# setAnsible_child_playbooks_Dir
# getAnsible_child_playbooks_Dir
# setPlaybook_child_playbooks_Dir
# getPlaybook_child_playbooks_Dir
# setAnsible_dialog_files_Dir
# getAnsible_dialog_files_Dir
# setAnsible_host_vars_Dir
# getAnsible_host_vars_Dir
# setAnsible_out_Dir
# getAnsible_out_Dir
# setAnsible_tmp_Dir
# getAnsible_tmp_Dir
# setAnsible_original_dialog_files_Dir
# getAnsible_original_dialog_files_Dir
# setAnsible_in_original_dialog_files_Dir
# getAnsible_in_original_dialog_files_Dir
# setAnsible_in_inventory_Dir
# getAnsible_in_inventory_Dir
# setAnsible_in_env_Dir
# getAnsible_in_env_Dir
# setAnsible_in_builder_files_Dir
# getAnsible_in_builder_files_Dir
# setAnsible_in_runner_files_Dir
# getAnsible_in_runner_files_Dir
# setAnsible_original_hosts_vars_Dir
# getAnsible_original_hosts_vars_Dir
# setAnsible_vault_hosts_vars_Dir
# getAnsible_vault_hosts_vars_Dir
# setAnsible_pioneer_template_hosts_vars_Dir
# getAnsible_pioneer_template_hosts_vars_Dir
# getAnsible_hosts_file
# getAnsible_playbook_file
# getAnsible_pioneer_template_host_var_file
# getAnsible_host_var_file
# getAnsible_org_host_var_file
# LocalLogPrint
# getDBHostList
# getDBRoleVarList
# getDBVarList
# MultiArrayVarsToYamlFormatMain
# getDBVarMultiArrayVarsList
# getDBLegacyPlaybookList
# getDBPioneerDialogFileList
# addSystemvars
# getDBTemplateMaster
# setHostvarsfile_template_file_Dir
# getHostvarsfile_template_file_Dir
# setTemporary_file_Dir
# getTemporary_file_Dir
# setAnsible_template_files_Dir
# getAnsible_template_files_Dir
# getITA_template_file
# getHostvarsfile_template_file_path
# getAnsible_template_file
# CreateTemplatefiles
# getDBPatternList
# getDBRolePackage
# getDBLegactRoleList
# CreateLegacyRolePlaybookfiles
# CheckLegacyRolePlaybookfiles
# getAnsible_RolePlaybook_file
# getRolePackageFile
# getAnsible_RolePackage_file
# setHostvarsfile_copy_file_Dir
# getHostvarsfile_copy_file_Dir
# setAnsible_copy_files_Dir
# getAnsible_copy_files_Dir
# getITA_copy_file
# getHostvarsfile_copy_file_value
# getAnsible_copy_file
# CreateCopyfiles
# getDBCopyMaster
# makeHostVarsPath
# makeHostVarsArray
# MultiArrayVarsToYamlFormatSub
# is_assoc
# getDBGlobalVarsMaster
# CreateLegacyRoleCopyFiles
# setAnsible_upload_files_Dir
# getAnsible_upload_files_Dir
# setAnsible_ssh_key_files_Dir
# getAnsible_ssh_key_files_Dir
# getITA_ssh_key_file
# getIN_ssh_key_file
# CreateSSH_key_file
# setAnsible_win_key_files_Dir
# getIN_win_key_file
# CreateWinrmPublicKeyFile
# CreateWinrmPrivateKeyFile
# LegacyRoleCheckConcreteValueIsVarTemplatefile
# LegacyRoleCheckConcreteValueIsVar
# CreateLegacyRoleTemplateFiles
# makeAnsibleVaultPassword
# makeAnsibleVaultValue
# getAnsibleExecuteUser
# setAnsibleExecuteUser
# HostVarEdit
# MultilineValueEdit
# chkMultilineValue
# makeMultilineValue
# ArrayTypeValue_encode
# MultiValueEdit
# isJsonString
# getAnsible_vault_host_var_file
# CreateDirectoryForCollectionProcess
# makeDir
# CreateMovementStatusFileVariables
# CreatePioneerOtherVariables
# CreateOperationVariables
# CreateSSHAgentConfigInfoFile
# setFileUploadCloumnFileEnv
# AnsibleEnginVirtualenvPathCheck
# getTowerProjectDirPath
# getTowerInstanceDirPath
# setTowerProjectDirPath
# setAnsibleSideFilePath
# setAnsibleTowerSideFilePath
# setTowerProjectsScpPath
# getTowerProjectsScpPath
# CopyAnsibleConfigFile
# CopysshAgentExpectfile
# CreateHostvarsfile
# CreatePioneerTemplateHostvarsfile
# CheckConcreteValueIsVar
# CheckConcreteValueIsVarTemplatefile
# getHostvarsfile_template_file_value
# getHostvarsfile_pioneer_template_file_value
# getHostvarsfile_pioneer_template_file
# getHostvarsfile_pioneer_copy_file_value
# CreateLegacyPlaybookfiles
# CreateChildPlaybookfiles
# CheckLegacyPlaybookfiles
# getITA_child_playbiook_file
# getAnsible_child_playbiook_file
# CheckVariablesDefinedInDeviceList
# CreateLegacytemplatefiles
# CheckTemplatefile
# CreateLegacyCopyFiles
# CommitHostVarsfiles
# CreateVaultHostvarsfiles
# CreatePioneerDialogfiles
# CreateDialogfiles
# getAnsible_dialog_file
# getAnsible_dialog_file_host_Dir
# getAnsible_org_dialog_file_host_Dir
# getITA_dialog_file
# CreatePioneertemplatefiles
# CreatePioneerCopyFiles
# CheckPioneerPlaybookfiles
# TemplateMmoduleAddPlaybook
# CheckDialogfileFormat
# str_to_num
# beforCommandCheck
# checkstateCommand
# errorstateCommand
# initstateCommandInfo
# checkCommand
# errorCommand
# initCommandInfo
# initlocalactionInfo
# errorlocalaction
# getArrayTypeValuecount
# getDBLegacyPlaybookList
# getDBPioneerDialogFileList
# getDBVarList
# var_check
# value_extraction
#############################################################
import os
import shutil
import re
import inspect
import json
from dictknife import deepmerge
from flask import g
import codecs
import base64

from common_libs.ansible_driver.classes.AnscConstClass import AnscConst
from common_libs.ansible_driver.classes.ansible_common_libs import AnsibleCommonLibs
from common_libs.ansible_driver.classes.YamlParseClass import YamlParse
from common_libs.ansible_driver.classes.AnsibleVaultClass import AnsibleVault
from common_libs.ansible_driver.classes.VarStructAnalJsonConvClass import VarStructAnalJsonConv
from common_libs.ansible_driver.classes.CheckAnsibleRoleFiles import CheckAnsibleRoleFiles, DefaultVarsFileAnalysis
from common_libs.ansible_driver.classes.WrappedStringReplaceAdmin import WrappedStringReplaceAdmin

from common_libs.ansible_driver.functions.util import getMovementAnsibleCnfUploadDirPath
from common_libs.ansible_driver.functions.util import getRolePackageContentUploadDirPath
from common_libs.ansible_driver.functions.util import getFileContentUploadDirPath
from common_libs.ansible_driver.functions.util import getTemplateContentUploadDirPath
from common_libs.ansible_driver.functions.util import getDeviceListSSHPrivateKeyUploadDirPath
from common_libs.ansible_driver.functions.util import getDeviceListWinrmPrivateKeyFileUploadDirPath, getDeviceListWinrmPublicKeyFileUploadDirPath
from common_libs.ansible_driver.functions.util import get_OSTmpPath
from common_libs.ansible_driver.functions.util import addAnsibleCreateFilesPath
from common_libs.ansible_driver.functions.util import getFileupLoadColumnPath
from common_libs.ansible_driver.functions.util import getDataRelayStorageDir
from common_libs.ansible_driver.functions.util import getAnsibleTmpDir
from common_libs.ansible_driver.functions.util import getAnsibleConst
from common_libs.ansible_driver.functions.util import getPioneerDialogUploadDirPath
from common_libs.ansible_driver.functions.util import getLegacyPlaybookUploadDirPath
from common_libs.ansible_driver.functions.util import get_AnsibleDriverShellPath
from common_libs.common.util import ky_encrypt, ky_decrypt, ky_file_encrypt, ky_file_decrypt
from common_libs.common.storage_access import storage_base, storage_read, storage_write, storage_base
from common_libs.ansible_driver.functions.ag_util import CreateAG_ITABuilderShellFiles, CreateAG_ITARunnerShellFiles, Replace_HostVrasFilepath


"""
Ansibleの実行に必要な情報をデータベースから取得しAnsible実行ディレクトリを作成するモジュール
"""

class CreateAnsibleExecFiles():
    """
    Ansibleの実行に必要な情報をデータベースから取得しAnsible実行ディレクトリを作成するクラス
    """
    def __init__(self, in_driver_id, in_ans_if_info, in_exec_no, in_engine_virtualenv_name, in_ansible_cnf_file, in_objDBCA):
        """
        コンストラクタ
        Arguments:
            in_driver_id:                     ドライバ区分
            in_ans_if_info:                   ansibleインターフェース情報
            in_exec_no:                       作業番号
            in_engine_virtualenv_name:        Ansible Engine virtualenv path
            in_ansible_cnf_file:              Ansible config file name
            in_objDBCA:                       データベースアクセスクラス変数
        Returns:
            なし
        """
        self.php_array = lambda x: x.items() if isinstance(x, dict) else enumerate(x)

        self.LC_ANS_IN_DIR = "in"
        self.LC_ANS_OUT_DIR = "out"
        self.LC_ANS_TMP_DIR = "tmp"

        self.LC_ANS_CHILD_PLAYBOOKS_DIR = "child_playbooks"
        self.LC_ANS_DIALOG_FILES_DIR = "dialog_files"
        self.LC_ANS_HOST_VARS_DIR = "host_vars"

        self.LC_VARS_ATTR_STD = '1'      # 一般変数
        self.LC_VARS_ATTR_LIST = '2'     # 複数具体値
        self.LC_VARS_ATTR_STRUCT = '3'   # 多次元変数

        self.LC_ANS_GROUP_VARS_DIR = "group_vars"
        self.LC_ANS_ORG_DIALOG_FILES_DIR = "original_dialog_files"
        self.LC_ANS_ORG_HOST_VARS_DIR = "original_host_vars"
        self.LC_ANS_VAULT_HOST_VARS_DIR = "vault_host_vars"
        self.LC_ANS_PIONEER_TEMPLATE_HOST_VARS_DIR = "pioneer_template_host_vars"
        self.LC_ANS_TEMPLATE_FILES_DIR = "template_files"
        self.LC_ANS_UPLOAD_FILES_DIR = "upload_files"
        self.LC_ANS_OUTDIR_DIR = "user_files"
        self.LC_ANS_PIONEER_LIBRARY_DIR = "library"

        # Ansible Agent用各種ディレクトリ
        self.LC_ANS_INVENTORY_DIR = "inventory"
        self.LC_ANS_ENV_DIR = "env"
        self.LC_ANS_BUILDER_EXECUTABLE_FILES_DIR = "builder_executable_files"
        self.LC_ANS_RUNNER_EXECUTABLE_FILES_DIR = "runner_executable_files"

        self.LC_ANS_PIONEER_LIBRARY_DIR = "library"

        self.LC_ANS_UNDEFINE_NAME = "__undefinesymbol__"

        self.LC_ANS_HOSTS_FILE = "hosts"
        self.LC_ANS_PLAYBOOK_FILE = "playbook.yml"
        self.LC_ANS_ROLE_PLAYBOOK_FILE = "site.yml"

        self.LC_ANS_RUNNER_START_SH_FILE = "start.sh"
        self.LC_ANS_RUNNER_SYOP_SH_FILE = "stop.sh"
        self.LC_ANS_RUNNER_ALIVE_SH_FILE = "alive.sh"

        self.LC_ANS_SSHAGENTCONFIG_FILE = ".sshAgentConfig.txt"
        self.LC_ANS_SSHAGENTEXPECT_FILE = "ky_ansible_ssh_add.exp"

        self.LC_WINRM_PORT = 5985

        self.lv_Ansible_driver_id = ""
        self.lv_hostaddress_type = ""

        self.lv_Ansible_base_Dir = {}
        self.lv_Ansible_in_Dir = ""
        self.lv_Ansible_child_playbooks_Dir = ""
        self.lv_Ansible_dialog_files_Dir = ""
        self.lv_Ansible_host_vars_Dir = ""
        self.lv_Ansible_out_Dir = ""
        self.lv_Ansible_tmp_Dir = ""
        self.lv_Ansible_original_dialog_files_Dir = ""
        self.lv_Ansible_original_hosts_vars_Dir = ""
        self.lv_Ansible_template_files_Dir = ""
        self.lv_Ansible_vault_hosts_vars_Dir = ""
        self.lv_Ansible_pioneer_template_hosts_vars_Dir = ""
        self.lv_Ansible_in_original_dialog_files_Dir = ""
        self.lv_Ansible_temporary_files_Dir = ""
        self.lv_AnsibleTmpDirAry = ""
        self.lv_Playbook_child_playbooks_Dir = ""
        self.lv_Hostvarsfile_template_file_Dir = ""
        self.lv_winrm_id = ""
        self.lv_ita_template_files_Dir = ""
        self.lv_Ansible_upload_files_Dir = ""
        self.lv_ansible_master_file_pkeyITEM = ""
        self.lv_ansible_master_file_nameITEM = ""
        self.LC_ANS_COPY_FILES_DIR = "copy_files"
        self.lv_ita_copy_files_Dir = ""
        self.run_operation_id = ""
        self.run_pattern_id = ""
        self.lv_objDBCA = ""
        self.lva_global_vars_list = {}
        self.lva_cpf_vars_list = {}
        self.lva_tpf_vars_list = {}
        self.lv_user_out_Dir = ""
        self.lv_conductor_instance_Dir = ""
        self.lv_conductor_instance_no = ""
        self.LC_ANS_SSH_KEY_FILES_DIR = "ssh_key_files"
        self.LC_ANS_SSH_KEY_FILE_VAR_NAME = "__ssh_key_file__"
        self.LC_ANS_SSH_EXTRA_ARGS_VAR_NAME = "__ssh_extra_args__"
        self.LC_ANS_PIONEER_LANG_VAR_NAME = "__pioneer_lang__"
        # pioneer用独自変数
        self.LC_ANS_PIONEER_ORIGINAL_EXEC_FILE_DIR = "__original_exec_file_dir__"
        self.LC_ANS_PIONEER_ENCODE_COLUMN_ENCODE_VALUE_FILE = "__encode_column_encode_value_file__"
        self.LC_ANS_PIONEER_SSH_PHRASES = "__ssh_phrases__"
        self.LC_ANS_PIONEER_SSH_PHRASES_FLG = "__ssh_phrases_flg__"

        self.v_Ansible_ssh_key_files_Dir = ""
        self.LC_ANS_WIN_KEY_FILES_DIR = "winrm_key_files"
        self.lv_Ansible_win_key_files_Dir = ""
        self.lv_legacy_Role_cpf_vars_list = {}
        self.lv_legacy_Role_tpf_vars_list = {}
        self.lv_tpf_vars_list = {}
        self.lv_cpf_vars_list = {}
        self.lv_use_gbl_vars_list = {}
        self.lv_parent_vars_list = {}
        self.lv_pioneer_template_parent_vars_list = {}
        self.lv_tpf_var_file_path_list = {}
        self.lv_cpf_var_file_path_list = {}
        self.ansible_vault_password_file_dir = ""
        self.lv_hostinfolist = {}
        self.ansible_exec_user = ""
        self.lv_ans_if_info = {}
        self.lv_exec_no = ""
        self.lv_vault_pass_list = {}
        self.lv_vault_value_list = {}
        self.lv_vault_value_update_list = {}

        self.lv_engine_virtualenv_name = ""
        self.lv_ansible_cnf_file = ""

        self.LegacyRoleCheckConcreteValueIsVar_use_host_name = ""
        self.LegacyRoleCheckConcreteValueIsVar_use_var_list = ""

        # Tower 作業インスタンス毎 Project Path
        # lv_TowerInstanceDirPath["TowerPath"]   "/var/lib/awx/projects"
        # lv_TowerInstanceDirPath["ExastroPath"] "/var/lib/exastro"
        self.lv_TowerInstanceDirPath = {}

        self.lv_exec_mode = ""

        self.LC_ITA_OUT_DIR = "__ita_out_dir__"
        self.LC_ITA_IN_DIR = "__ita_in_dir__"
        self.LC_ITA_CONDUCTOR_DIR = "__ita_conductor_dir__"
        self.LC_ITA_SYMPHONY_DIR = "__ita_symphony_dir__"
        self.LC_ITA_TMP_DIR = "__ita_tmp_dir__"

        self.LC_PLAYBOOK_DIALOG_FILE_VARNAME_MK = "var%d"

        # Tower(/var/lib/awx/projects)ディレクトリへのファイル転送パス配列
        self.vg_TowerProjectsScpPathArray = {}

        # 実行エンジンを退避
        self.lv_exec_mode = in_ans_if_info['ANSIBLE_EXEC_MODE']
        self.setAnsibleDriverID(in_driver_id)
        self.AnscObj = getAnsibleConst(in_driver_id)

        # ansible作業実行用ベースディレクトリ
        # ansible_ita_base_dir: /storage/{organization_id}/{workspace_id}/driver
        ansible_ita_base_dir = getDataRelayStorageDir() + "/driver"
        ansible_ans_base_dir = ansible_ita_base_dir
        self.setAnsibleBaseDir('ANSIBLE_SH_PATH_ITA', ansible_ita_base_dir)
        self.setAnsibleBaseDir('ANSIBLE_SH_PATH_ANS', ansible_ans_base_dir)

        # Conductor作業実行用ベースディレクトリ
        # Conductor_ita_base_dir: /storage/{organization_id}/{workspace_id}/driver/conductor
        Conductor_ans_base_dir = getDataRelayStorageDir() + "/driver/conductor"
        Conductor_ita_base_dir = Conductor_ans_base_dir
        self.setAnsibleBaseDir('CONDUCTOR_STORAGE_PATH_ANS', Conductor_ans_base_dir)
        self.setAnsibleBaseDir('CONDUCTOR_STORAGE_PATH_ITA', Conductor_ita_base_dir)

        # outディレクトリ
        self.lv_Ansible_out_Dir = ""

        self.lv_objDBCA = in_objDBCA
        self.lv_objMTS = ""

        self.lv_legacy_Role_cpf_vars_list = {}
        self.lv_legacy_Role_tpf_vars_list = {}
        self.lv_tpf_vars_list = {}
        self.lv_cpf_vars_list = {}
        self.lv_use_gbl_vars_list = {}
        self.lv_parent_vars_list = {}
        self.lv_tpf_var_file_path_list = {}
        self.lv_cpf_var_file_path_list = {}
        self.lv_ans_if_info = in_ans_if_info
        self.lv_exec_no = in_exec_no
        self.lv_vault_pass_list = {}
        self.lv_vault_value_list = {}
        self.lv_vault_value_update_list = {}

        self.lv_engine_virtualenv_name = in_engine_virtualenv_name

        self.lv_ansible_cnf_file = in_ansible_cnf_file

        self.LegacyRoleCheckConcreteValueIsVar_use_host_name = ""
        self.LegacyRoleCheckConcreteValueIsVar_use_var_list = {}

        # AAC Projectディレクトリパス取得
        self.setTowerProjectDirPath()

        # 作成用一時ディレクトリ取得
        self.lv_AnsibleTmpDirAry = getAnsibleTmpDir(in_exec_no, self.AnscObj.vg_OrchestratorSubId_dir)
        # self.lv_AnsibleTmpDirAry["BASE_DIR"]をaddAnsibleCreateFilesPathでゴミ掃除リストに追加はここでは不要
        dir_name = self.lv_AnsibleTmpDirAry["BASE_DIR"]
        # 作成用一時ディレクトリ作成
        if os.path.isdir(dir_name) is False:
            os.mkdir(dir_name)
        os.chmod(dir_name, 0o777)

    def getAnsibleWorkingDirectories(self, in_oct_id, in_execno):
        """
        ansible用作業ディレクトリパス取得
        Arguments:
            in_oct_id: オケストレータID
        Returns:
            ansible用作業ディレクトリパス
        """
        aryRetAnsibleWorkingDir = []

        # /{storage}/{organization_id}/{workspace_id}/driver/ansible
        c_dir_per_ans_orc_type_id = "{}/ansible".format(self.getAnsibleBaseDir('ANSIBLE_SH_PATH_ITA'))

        aryRetAnsibleWorkingDir.append(c_dir_per_ans_orc_type_id)

        # /{storage}/{organization_id}/{workspace_id}/driver/ansible/{legacy / pioneer / legacy_role}
        c_dir_per_orc_id = "{}/{}".format(c_dir_per_ans_orc_type_id, in_oct_id)
        aryRetAnsibleWorkingDir.append(c_dir_per_orc_id)

        # /{storage}/{organization_id}/{workspace_id}/driver/ansible/{legacy / pioneer / legacy_role}/作業番号
        c_dir_per_exe_no = "{}/{}".format(c_dir_per_orc_id, in_execno)
        aryRetAnsibleWorkingDir.append(c_dir_per_exe_no)

        # /{storage}/{organization_id}/{workspace_id}/driver/ansible/{legacy / pioneer / legacy_role}/作業番号/in
        c_dir_in_per_exe_no = "{}/{}".format(c_dir_per_exe_no, self.LC_ANS_IN_DIR)
        aryRetAnsibleWorkingDir.append(c_dir_in_per_exe_no)

        # /{storage}/{organization_id}/{workspace_id}/driver/ansible/{legacy / pioneer / legacy_role}/作業番号/out
        c_dir_out_per_exe_no = "{}/{}".format(c_dir_per_exe_no, self.LC_ANS_OUT_DIR)
        aryRetAnsibleWorkingDir.append(c_dir_out_per_exe_no)

        return aryRetAnsibleWorkingDir

    def setITALocalVars(self):
        """
        ITA独自変数名リスト生成
        Arguments:
            なし
        Returns:
            ITA独自変数名リスト
        """
        return  self.AnscObj.notHaveSpecificValues_ITA_sp_varlist

    def getAnsibleDriverCommonShellPath(self):
        path = "{}{}/{}/{}".format(os.environ["PYTHONPATH"], g.get('ORGANIZATION_ID'), g.get('WORKSPACE_ID'), "/common_libs/ansible_driver/shells")
        return path

    def CreateAnsibleWorkingDir(self,
                                in_oct_id,
                                in_execno,
                                in_operation_id,
                                in_hostaddress_type,
                                in_winrm_id,
                                in_pattern_id,
                                mt_rolenames,
                                mt_rolevars,
                                mt_roleglobalvars,
                                mt_role_rolepackage_id,
                                mt_def_vars_list,
                                mt_def_array_vars_list,
                                in_conductor_instance_no):
        """
        ansible用作業ディレクトリを作成
        Arguments:
            in_execno                   作業実行番号
            in_operation_id             オペレーションID
            in_hostaddress_type         ホストアドレス方式
                                        null or 1:IP方式  2:ホスト名方式
            in_winrm_id                 対象ホストがwindowsかを判別
                                        1: windows 他:windows以外
            in_pattern_id               作業パターンID
                                        Legacy-Role時のみ必須
            ina_rolenames               Legacy-Role role名リスト
                                        Legacy-Role時のみ必須
                                        ina_rolename[role名]
            ina_rolevars                Legacy-Role role内変数リスト
                                        Legacy-Role時のみ必須
                                        ina_rolevars[role名][変数名]=0
            mt_roleglobalvars           Legacy-Role role内グローバル変数リスト
                                        Legacy-Role時のみ必須
                                        mt_roleglobalvars[role名][グローバル変数名]=0
            mt_role_rolepackage_id      ロールパッケージ管理 Pkey 返却
                                        Legacy-Role時のみ必須
            mt_def_vars_list:          各ロールのデフォルト変数ファイル内に定義されている変数リスト
            mt_def_array_vars_list:    各ロールのデフォルト変数ファイル内に定義されている多次元変数の情報
            in_conductor_instance_no:   conductorから起動された場合のconductorインスタンスID
                                        作業実行の場合は空白
        Returns:
            True/False, mt_rolenames, mt_rolevars, mt_roleglobalvars, mt_role_rolepackage_id, mt_def_vars_list, mt_def_array_vars_list
        """
        self.lv_exec_no = in_execno

        self.lv_conductor_instance_no = in_conductor_instance_no

        self.run_operation_id = in_operation_id

        self.run_pattern_id = in_pattern_id

        self.lv_hostaddress_type = in_hostaddress_type

        self.lv_winrm_id = in_winrm_id

        # ドライバ区分ディレクトリ作成
        aryRetAnsibleWorkingDir = self.getAnsibleWorkingDirectories(in_oct_id, in_execno)

        # /{storage}/{organization_id}/{workspace_id}/driver/ansibleまでのディレクトリ作成
        c_dir = aryRetAnsibleWorkingDir[0]

        # /{storage}/{organization_id}/{workspace_id}/driver/ansible/{legacy / pioneer / legacy_role}
        # 作業番号ディレクトリ作成
        c_dir = aryRetAnsibleWorkingDir[1]
        if os.path.isdir(c_dir) is False:
            msgstr = g.appmsg.get_api_message("MSG-10120", [in_execno, c_dir])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, mt_rolenames, mt_rolevars, mt_roleglobalvars, mt_role_rolepackage_id, mt_def_vars_list, mt_def_array_vars_list
        else:
            os.chmod(c_dir, 0o777)

        # /{storage}/{organization_id}/{workspace_id}/driver/ansible/{legacy / pioneer / legacy_role}/作業番号
        # 作業番号作成
        c_dir = aryRetAnsibleWorkingDir[2]
        if os.path.isdir(c_dir) is False:
            os.mkdir(c_dir)
        os.chmod(c_dir, 0o777)

        # /{storage}/{organization_id}/{workspace_id}/driver/ansible/{legacy / pioneer / legacy_role}/作業番号/out
        # outディレクトリ作成
        c_outdir = aryRetAnsibleWorkingDir[4]
        if os.path.isdir(c_outdir) is False:
            os.mkdir(c_outdir)
        os.chmod(c_outdir, 0o777)

        # outディレクトリ名を記憶
        self.setAnsible_out_Dir(c_outdir)

        # Tower(/var/lib/awx/projects)ディレクトリへのファイル転送パス退避
        # /var/lib/exastro/ita_legacy_executions_0000040099/__ita_out_dir__
        Tower_out_Dir = "{}/{}".format(self.getTowerProjectDirPath("ExastroPath"), self.LC_ITA_OUT_DIR)
        self.setTowerProjectsScpPath(self.AnscObj.DF_SCP_OUT_TOWER_PATH, Tower_out_Dir)

        # /{storage}/{organization_id}/{workspace_id}/driver/ansible/{legacy / pioneer / legacy_role}/{ 作業番号 }/out
        self.setTowerProjectsScpPath(self.AnscObj.DF_SCP_OUT_ITA_PATH, self.getAnsible_out_Dir())

        # Gitリポジトリ作業用 ディレクトリバス
        # /{storage}/{organization_id}/{workspace_id}/tmp/driver/ansible/legacy_0000040099/__ita_out_dir__
        path = "{}/{}".format(self.lv_AnsibleTmpDirAry["DIR_NAME"], self.LC_ITA_OUT_DIR)
        self.setTowerProjectsScpPath(self.AnscObj.DF_GITREPO_OUT_PATH, path)

        # ユーザー公開用データリレイストレージパス
        # /{storage}/{organization_id}/{workspace_id}/driver/ansible/{legacy / pioneer / legacy_role}/作業番号/out/user_files
        user_out_Dir = "{}/{}".format(c_outdir, self.LC_ANS_OUTDIR_DIR)
        # isdirでディレクトリ有無チェック
        if os.path.isdir(user_out_Dir) is False:
            os.mkdir(user_out_Dir)
        os.chmod(user_out_Dir, 0o777)

        # ホスト変数定義ファイルに記載するパスなのでAnsible側のストレージパスに変更
        self.lv_user_out_Dir = self.setAnsibleSideFilePath(user_out_Dir, self.LC_ITA_OUT_DIR)

        # conductorからの起動か判定 ディレクトリはconductorバックヤードで作成済み
        if in_conductor_instance_no:
            ins_Path = in_conductor_instance_no
            # ユーザー公開用conductorインスタンス作業用 データリレイストレージパス
            if self.lv_exec_mode in (self.AnscObj.DF_EXEC_MODE_ANSIBLE, self.AnscObj.DF_EXEC_MODE_AG):
                self.lv_conductor_instance_Dir = "{}/{}".format(self.getAnsibleBaseDir('CONDUCTOR_STORAGE_PATH_ANS'), ins_Path)
            else:
                # Tower(/var/lib/awx/projects)ディレクトリへのファイル転送パス退避
                self.lv_conductor_instance_Dir = "{}/{}/{}/{}".format(self.getTowerProjectDirPath("ExastroPath"),
                                                                      self.LC_ITA_TMP_DIR, self.LC_ITA_CONDUCTOR_DIR, ins_Path)
                self.setTowerProjectsScpPath(self.AnscObj.DF_SCP_CONDUCTOR_TOWER_PATH, self.lv_conductor_instance_Dir)

                ita_conductor_instance_Dir = "{}/{}".format(self.getAnsibleBaseDir('CONDUCTOR_STORAGE_PATH_ITA'), ins_Path)
                self.setTowerProjectsScpPath(self.AnscObj.DF_SCP_CONDUCTOR_ITA_PATH, ita_conductor_instance_Dir)

                # Gitリポジトリ作業用 ディレクトリバス
                path = "{}/{}/{}".format(self.lv_AnsibleTmpDirAry["DIR_NAME"], self.LC_ITA_TMP_DIR, self.LC_ITA_CONDUCTOR_DIR)
                self.setTowerProjectsScpPath(self.AnscObj.DF_GITREPO_CONDUCTOR_PATH, path)
        else:
            self.lv_conductor_instance_Dir = self.lv_user_out_Dir

        # /{storage}/{organization_id}/{workspace_id}/driver/ansible/{legacy / pioneer / legacy_role}/作業番号/in
        # inディレクトリ作成
        c_indir = aryRetAnsibleWorkingDir[3]
        if os.path.isdir(c_indir) is False:
            os.mkdir(c_indir)
        # ansible.cfgを配置した場合の考慮
        os.chmod(c_indir, 0o755)

        # INディレクトリ名を記憶
        self.setAnsible_in_Dir(c_indir)

        # ドライバ区分がLEGACYの場合にchild_playbooksディレクトリ作成
        if self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_DRIVER_ID:
            # child_playbooksディレクトリ作成
            c_dirwk = c_indir + "/" + self.LC_ANS_CHILD_PLAYBOOKS_DIR
            # isdirでディレクトリ有無チェック
            if os.path.isdir(c_dirwk) is False:
                os.mkdir(c_dirwk)
            os.chmod(c_dirwk, 0o777)

            # child_playbooksディレクトリ名を記憶
            self.setAnsible_child_playbooks_Dir(c_dirwk)
            # PlayBook内 子PlayBookパスを記憶
            self.setPlaybook_child_playbooks_Dir(self.LC_ANS_CHILD_PLAYBOOKS_DIR)
        # template_filesディレクトリ作成
        c_dirwk = c_indir + "/" + self.LC_ANS_TEMPLATE_FILES_DIR
        # isdirでディレクトリ有無チェック
        if os.path.isdir(c_dirwk) is False:
            os.mkdir(c_dirwk)
        os.chmod(c_dirwk, 0o777)
        self.setAnsible_template_files_Dir(c_dirwk)

        # ホスト変数ファイル内 template_filesディレクトリパスを記憶
        self.setHostvarsfile_template_file_Dir(c_dirwk)

        # ドライバ区分がLEGACYかPioneer、ROLEの場合にcopy_filesディレクトリを作成する。
        # copy_filesディレクトリ作成
        c_dirwk = c_indir + "/" + self.LC_ANS_COPY_FILES_DIR
        # isdirでディレクトリ有無チェック
        if os.path.isdir(c_dirwk) is False:
            os.mkdir(c_dirwk)
        os.chmod(c_dirwk, 0o777)
        self.setAnsible_copy_files_Dir(c_dirwk)

        self.setHostvarsfile_copy_file_Dir(c_dirwk)

        # upload_filesディレクトリ作成
        c_dirwk = c_indir + "/" + self.LC_ANS_UPLOAD_FILES_DIR
        # isdirでディレクトリ有無チェック
        if os.path.isdir(c_dirwk) is False:
            os.mkdir(c_dirwk)
        os.chmod(c_dirwk, 0o777)
        self.setAnsible_upload_files_Dir(c_dirwk)

        # ssh_key_filesディレクトリ作成
        c_dirwk = c_indir + "/" + self.LC_ANS_SSH_KEY_FILES_DIR
        # isdirでディレクトリ有無チェック
        if os.path.isdir(c_dirwk) is False:
            os.mkdir(c_dirwk)
        os.chmod(c_dirwk, 0o777)
        self.setAnsible_ssh_key_files_Dir(c_dirwk)

        # win_ca_filesディレクトリ作成
        c_dirwk = c_indir + "/" + self.LC_ANS_WIN_KEY_FILES_DIR
        # isdirでディレクトリ有無チェック
        if os.path.isdir(c_dirwk) is False:
            os.mkdir(c_dirwk)
        os.chmod(c_dirwk, 0o777)
        self.setAnsible_win_key_files_Dir(c_dirwk)

        # ドライバ区分がPIONEERの場合にdialog_filesディレクトリ作成
        if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
            # dialog_filesディレクトリ作成
            c_dirwk = c_indir + "/" + self.LC_ANS_DIALOG_FILES_DIR
            # isdirでディレクトリ有無チェック
            if os.path.isdir(c_dirwk) is False:
                os.mkdir(c_dirwk)
            os.chmod(c_dirwk, 0o777)
            self.setAnsible_dialog_files_Dir(c_dirwk)

            # original_dialog_filesディレクトリ作成
            c_dirwk = c_indir + "/" + self.LC_ANS_ORG_DIALOG_FILES_DIR
            # isdirでディレクトリ有無チェック
            if os.path.isdir(c_dirwk) is False:
                os.mkdir(c_dirwk)
            os.chmod(c_dirwk, 0o777)
            self.setAnsible_in_original_dialog_files_Dir(c_dirwk)

            # 対話ファイル実行に必要な資材配置ディレクトリ作成
            c_dirwk = c_indir + "/" + self.LC_ANS_PIONEER_LIBRARY_DIR
            # isdirでディレクトリ有無チェック
            if os.path.isdir(c_dirwk) is False:
                os.mkdir(c_dirwk)
            os.chmod(c_dirwk, 0o777)

            # 対話ファイル実行に必要な資材配置ディレクトリ配置
            src_files = []
            base_path = "/exastro/common_libs/ansible_driver/shells"
            src_files.append(base_path + "/ky_pionner_grep_side_Ansible.sh")
            src_files.append(base_path + "/pioneer_module.py")
            for src_file in src_files:
                dest_file = c_dirwk + "/" + os.path.basename(src_file)
                # 対話ファイル実行に必要な資材をコピーする。
                shutil.copyfile(src_file, dest_file)
                os.chmod(dest_file, 0o777)

        # Ansible Egent用のディレクトリを作成
        if self.lv_exec_mode == AnscConst.DF_EXEC_MODE_AG:
            # Ansible Agentの場合、inventoryディレクトリ作成
            c_dirwk = c_indir + "/" + self.LC_ANS_INVENTORY_DIR
            if os.path.isdir(c_dirwk) is False:
                os.mkdir(c_dirwk)
            os.chmod(c_dirwk, 0o777)
            self.setAnsible_in_inventory_Dir(c_dirwk)

            # Ansible Agentの場合、envディレクトリ作成
            c_dirwk = c_indir + "/" + self.LC_ANS_ENV_DIR
            if os.path.isdir(c_dirwk) is False:
                os.mkdir(c_dirwk)
            os.chmod(c_dirwk, 0o777)
            tgtdir = self.setAnsible_in_env_Dir(c_dirwk)

            # Ansible Agentの場合、envディレクトリ配下にsettingsファイル生成
            tgtfile = "{}/{}".format(c_dirwk, "settings")
            shutil.copy("{}/ky_ansible_runner_settings_file.txt".format(get_AnsibleDriverShellPath()), tgtfile)

            # movementの情報を取得
            sql = "SELECT * FROM {} WHERE MOVEMENT_ID = %s AND DISUSE_FLAG = '0'".format(self.AnscObj.vg_ansible_pattern_listDB)
            rows = self.lv_objDBCA.sql_execute(sql, bind_value_list=[in_pattern_id])
            movement_row = rows[0]

            # Ansible Agentの場合、builder_executable_filesディレクトリを生成する
            c_dirwk = c_indir + "/" + self.LC_ANS_BUILDER_EXECUTABLE_FILES_DIR
            if os.path.isdir(c_dirwk) is False:
                os.mkdir(c_dirwk)
            os.chmod(c_dirwk, 0o777)
            self.setAnsible_in_builder_files_Dir(c_dirwk)

            # 実行エンジンがAnsible Agentの場合、runner_executable_filesディレクトリを生成する
            c_dirwk = c_indir + "/" + self.LC_ANS_RUNNER_EXECUTABLE_FILES_DIR
            if os.path.isdir(c_dirwk) is False:
                os.mkdir(c_dirwk)
            os.chmod(c_dirwk, 0o777)
            self.setAnsible_in_runner_files_Dir(c_dirwk)

        # グローバル変数管理からグローバル変数の情報を取得
        self.lva_global_vars_list = {}
        retAry = self.getDBGlobalVarsMaster(self.lva_global_vars_list)
        ret = retAry[0]
        self.lva_global_vars_list = retAry[1]
        if ret is False:
            # ITAANSIBLEH-ERR-90235
            msgstr = g.appmsg.get_api_message("MSG-10458", [])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, mt_rolenames, mt_rolevars, mt_roleglobalvars, mt_role_rolepackage_id, mt_def_vars_list, mt_def_array_vars_list

        # ドライバ区分がLegacy-Roleの場合
        # 作業パターンIDに紐づくパッケージファイルを取得
        # パッケージファイルをZIPファイルをinディレクトリに解凍し
        # 不要なファイルを削除する。
        if self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_ROLE_DRIVER_ID:
            # 作業パターンIDに紐づくパッケージファイルを取得
            retAry = self.getRolePackageFile(in_pattern_id)
            ret = retAry[0]
            mt_role_rolepackage_id = retAry[1]
            role_package_file = retAry[2]
            if ret is False:
                return False, mt_rolenames, mt_rolevars, mt_roleglobalvars, mt_role_rolepackage_id, mt_def_vars_list, mt_def_array_vars_list

            roleObj = CheckAnsibleRoleFiles(self.lv_objMTS)

            # ロールパッケージファイル名(ZIP)を取得
            zipfile = self.getAnsible_RolePackage_file(mt_role_rolepackage_id, role_package_file)
            # del pkey = ""

            # ロールパッケージファイル名(ZIP)の存在確認
            if os.path.isfile(zipfile) is False:
                #
                msgstr = g.appmsg.get_api_message("MSG-10262", [mt_role_rolepackage_id, role_package_file])
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)
                return False, mt_rolenames, mt_rolevars, mt_roleglobalvars, mt_role_rolepackage_id, mt_def_vars_list, mt_def_array_vars_list

            # inディレクトリにロールパッケージファイル(ZIP)展開
            del_flag = False
            if roleObj.ZipextractTo(zipfile, self.getAnsible_in_Dir(), del_flag) is False:
                arryErrMsg = roleObj.getlasterror()
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), arryErrMsg[0])
                return False, mt_rolenames, mt_rolevars, mt_roleglobalvars, mt_role_rolepackage_id, mt_def_vars_list, mt_def_array_vars_list
            else:
                # ローカル変数のリスト作成
                system_vars = self.setITALocalVars()

                mt_def_vars_list = {}
                err_vars_list = {}
                def_varsval_list = {}
                self.lva_cpf_vars_list = {}
                self.lva_tpf_vars_list = {}
                ITA2User_var_list = {}
                User2ITA_var_list = {}
                comb_err_vars_list = {}

                # self.lva_cpf/tpf_vars_listの構造
                # lva_cpf_vars_list[ロール名][ロール名/--/Playbook名][行番号][変数名] = 1
                # lva_tpf_vars_list[ロール名][ロール名/--/Playbook名][行番号][変数名] = 1
                retList = roleObj.chkRolesDirectory(self.getAnsible_in_Dir(),
                                                    system_vars,
                                                    "",
                                                    mt_def_vars_list,
                                                    err_vars_list,
                                                    def_varsval_list,
                                                    mt_def_array_vars_list,
                                                    # ロール内のplaybookからcopy変数を抽出する。
                                                    True,
                                                    self.lva_cpf_vars_list,
                                                    True,
                                                    self.lva_tpf_vars_list,
                                                    ITA2User_var_list,
                                                    User2ITA_var_list,
                                                    comb_err_vars_list,
                                                    True)
                ret = retList[0]
                mt_def_vars_list = retList[1]
                err_vars_list = retList[2]
                def_varsval_list = retList[3]
                mt_def_array_vars_list = retList[4]
                self.lva_cpf_vars_list = retList[5]
                self.lva_tpf_vars_list = retList[6]
                ITA2User_var_list = retList[7]
                User2ITA_var_list = retList[8]
                comb_err_vars_list = retList[9]

                if ret is False:
                    # ロール内の読替表で読替変数と任意変数の組合せが一致していない
                    if len(comb_err_vars_list) != 0:
                        msgObj = DefaultVarsFileAnalysis(self.objMTS)
                        strErrMsg = msgObj.TranslationTableCombinationErrmsgEdit(False, comb_err_vars_list)
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), strErrMsg)
                        return False, mt_rolenames, mt_rolevars, mt_roleglobalvars, mt_role_rolepackage_id, mt_def_vars_list, mt_def_array_vars_list
                    # defaults定義ファイルに定義されている変数で属性が違う変数がある場合
                    elif len(err_vars_list) != 0:
                        msgObj = DefaultVarsFileAnalysis(self.objMTS)
                        strErrMsg = msgObj.VarsStructErrmsgEdit(err_vars_list)
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), strErrMsg)
                        return False, mt_rolenames, mt_rolevars, mt_roleglobalvars, mt_role_rolepackage_id, mt_def_vars_list, mt_def_array_vars_list
                    else:
                        arryErrMsg = roleObj.getlasterror()
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), arryErrMsg[0])
                        return False, mt_rolenames, mt_rolevars, mt_roleglobalvars, mt_role_rolepackage_id, mt_def_vars_list, mt_def_array_vars_list

                # 作業パターンIDに紐づけられているロール名取得
                w_RoleInfoList = []
                w_RoleNameList = []
                retAry = self.getDBLegactRoleList(in_pattern_id, w_RoleInfoList)
                ret = retAry[0]
                w_RoleInfoList = retAry[1]
                if ret is False:
                    return False, mt_rolenames, mt_rolevars, mt_roleglobalvars, mt_role_rolepackage_id, mt_def_vars_list, mt_def_array_vars_list

                w_RoleNameList = []
                for seq_no, role_info in w_RoleInfoList.items():
                    for role_id, role_name in role_info.items():
                        w_RoleNameList.append(role_name)

                # 紐づけされていないロールで使用しているCopy変数を
                # self.lva_cpf_vars_listから取り除く
                self.lva_cpf_vars_list = self.DeleteUnuseData(self.lva_cpf_vars_list, w_RoleNameList)

                # 紐づけされていないロールで使用しているTemplate変数を
                # self.lva_tpf_vars_listから取り除く
                self.lva_tpf_vars_list = self.DeleteUnuseData(self.lva_tpf_vars_list, w_RoleNameList)

                # 紐づけされていないロールで使用しているグローバル変数を
                # mt_roleglobalvarsから取り除く
                mt_roleglobalvars = roleObj.getglobalvarname()
                if len(mt_roleglobalvars) == 0:
                    mt_roleglobalvars = {}
                mt_roleglobalvars = self.DeleteUnuseData(mt_roleglobalvars, w_RoleNameList)

                chkObj = DefaultVarsFileAnalysis(self.lv_objMTS)
                msgstr = ""
                # ロールパッケージ内のPlaybookで定義しているグローバル変数がグローバル変数管理にあるか
                retAry = chkObj.chkDefVarsListPlayBookGlobalVarsList(mt_roleglobalvars, self.lva_global_vars_list, msgstr)
                ret = retAry[0]
                msgstr = retAry[1]
                if ret is False:
                    #
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    return False, mt_rolenames, mt_rolevars, mt_roleglobalvars, mt_role_rolepackage_id, mt_def_vars_list, mt_def_array_vars_list

                del chkObj

                # copy変数がファイル管理に登録されているか判定
                strErrMsg = ""
                objLibs = AnsibleCommonLibs(self.AnscObj.LC_RUN_MODE_STD)

                # self.lva_cpf_vars_listの構造 CONTENTS_FILE_ID/CONTENTS_FILEはchkCPFVarsMasterRegの戻り値
                # lva_cpf_vars_list[ロール名][ロール名/--/Playbook名][行番号][変数名]['CONTENTS_FILE_ID'] = Pkey
                # lva_cpf_vars_list[ロール名][ロール名/--/Playbook名][行番号][変数名]['CONTENTS_FILE'] = ファイル名

                retAry = objLibs.chk_cpf_vars_master_reg(self.lva_cpf_vars_list, self.lv_objDBCA)
                ret = retAry[0]
                self.lva_cpf_vars_list = retAry[1]
                strErrMsg = retAry[2]
                if ret is False:
                    #
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), strErrMsg)
                    return False, mt_rolenames, mt_rolevars, mt_roleglobalvars, mt_role_rolepackage_id, mt_def_vars_list, mt_def_array_vars_list

                # template変数がファイル管理に登録されているか判定
                strErrMsg = ""

                retAry = objLibs.chk_tpf_vars_master_reg(self.lva_tpf_vars_list, self.lv_objDBCA)
                ret = retAry[0]
                self.lva_tpf_vars_list = retAry[1]
                strErrMsg = retAry[2]
                if ret is False:
                    #
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), strErrMsg)
                    return False, mt_rolenames, mt_rolevars, mt_roleglobalvars, mt_role_rolepackage_id, mt_def_vars_list, mt_def_array_vars_list

                # テンプレート管理に登録されている変数情報取得
                # ina_tpf_vars_list[role_name][tgt_file][line_no][tpf_var_name]['VAR_STRUCT_ANAL_JSON_STRING']
                temlate_ctl_gbl_vars_list = {}
                for rolename, tpfinfo_1 in self.lva_tpf_vars_list.items():
                    for filename, tpfinfo_2 in tpfinfo_1.items():
                        for line_no, tpfinfo_3 in tpfinfo_2.items():
                            for tpf_var_name, tpfinfo_4 in tpfinfo_3.items():
                                if 'VAR_STRUCT_ANAL_JSON_STRING' in tpfinfo_4:
                                    pass
                                else:
                                    continue

                                JsonObj = VarStructAnalJsonConv()

                                # Jsonでエンコードされている変数情報をデコードする
                                retAry = JsonObj.TemplateVarStructAnalJsonLoads(tpfinfo_4['VAR_STRUCT_ANAL_JSON_STRING'])

                                # unuse Vars_list = retAry[0]
                                # unuse Array_vars_list = retAry[1]
                                # unuse LCA_vars_use = retAry[2]
                                # unuse Array_vars_use = retAry[3]
                                # unuse VarVal_list = retAry[5]
                                GBL_vars_info = retAry[4]
                                if len(GBL_vars_info) == 0:
                                    GBL_vars_info = {}

                                # ロール内で使用しているTPF変数で、テンプレート管理の変数定義に登録されているグローバル変数を抜き出す。
                                for dummy, gblinfo_1 in GBL_vars_info.items():
                                    for gbl_var_name, dummy in gblinfo_1.items():
                                        # テンプレート管理の変数定義に登録されているグローバル変数をマーク
                                        if rolename not in temlate_ctl_gbl_vars_list:
                                            temlate_ctl_gbl_vars_list[rolename] = {}
                                        if gbl_var_name not in temlate_ctl_gbl_vars_list[rolename]:
                                            temlate_ctl_gbl_vars_list[rolename][gbl_var_name] = 0
                                        if gbl_var_name not in self.lv_use_gbl_vars_list:
                                            self.lv_use_gbl_vars_list[gbl_var_name] = 0

                # ロール内で使用しているTPF変数で、テンプレート管理の変数定義に登録されているグローバル変数がグローバル変数管理に登録されているか判定
                chkObj = DefaultVarsFileAnalysis(self.lv_objMTS)
                msgstr = ""

                retAry = chkObj.chkDefVarsListPlayBookGlobalVarsList(temlate_ctl_gbl_vars_list, self.lva_global_vars_list, msgstr)
                ret = retAry[0]
                msgstr = retAry[1]
                if ret is False:
                    #
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    return False, mt_rolenames, mt_rolevars, mt_roleglobalvars, mt_role_rolepackage_id, mt_def_vars_list, mt_def_array_vars_list

                # ロール名取得
                # ina_rolename[role名]
                mt_rolenames = roleObj.getrolename()
                # ロール内のITA独自変数取得
                # ina_varname[role名][変数名]=0
                mt_rolevars = roleObj.getITAvarsname()

            # 展開先にhostsファイルがあれば削除する。
            path = "{}/{}".format(c_indir, self.LC_ANS_HOSTS_FILE)
            is_file = os.path.isfile(path)

            if is_file is True:
                os.remove(path)

            # 展開先にホスト変数ディレクトリがあれば削除する。
            path = "{}/{}".format(c_indir, self.LC_ANS_HOST_VARS_DIR)
            is_dir = os.path.isdir(path)

            if is_dir is True:
                shutil.rmtree(path)

            # 展開先にホストグループ変数ディレクトリがあれば削除する。
            path = "{}/{}".format(c_indir, self.LC_ANS_GROUP_VARS_DIR)
            is_dir = os.path.isdir(path)

            if is_dir is True:
                shutil.rmtree(path)

            # ITA独自ディレクトリの存在を確認し削除
            path = "{}/{}".format(c_indir, self.LC_ITA_OUT_DIR)
            is_dir = os.path.isdir(path)

            if is_dir is True:
                shutil.rmtree(path)

            path = "{}/{}".format(c_indir, self.LC_ITA_TMP_DIR)
            is_dir = os.path.isdir(path)

            if is_dir is True:
                shutil.rmtree(path)

        # host_varsディレクトリ作成
        c_dirwk = "{}/{}".format(c_indir, self.LC_ANS_HOST_VARS_DIR)
        # isdirでディレクトリ有無チェック
        if os.path.isdir(c_dirwk) is False:
            os.mkdir(c_dirwk)
        os.chmod(c_dirwk, 0o777)

        # host_varsディレクトリ名を記憶
        self.setAnsible_host_vars_Dir(c_dirwk)

        # tmpディレクトリ作成
        c_tmpdir = "{}/{}".format(c_dir, self.LC_ANS_TMP_DIR)
        if os.path.isdir(c_tmpdir) is False:
            os.mkdir(c_tmpdir)
        os.chmod(c_tmpdir, 0o777)

        # tmpディレクトリ名を記憶
        self.setAnsible_tmp_Dir(c_tmpdir)

        # Tower(/var/lib/awx/projects)ディレクトリへのファイル転送パス退避
        Tower_tmp_Dir = "{}/{}".format(self.getTowerProjectDirPath("ExastroPath"), self.LC_ITA_TMP_DIR)
        self.setTowerProjectsScpPath(self.AnscObj.DF_SCP_TMP_TOWER_PATH, Tower_tmp_Dir)
        self.setTowerProjectsScpPath(self.AnscObj.DF_SCP_TMP_ITA_PATH, self.getAnsible_tmp_Dir())

        # Gitリポジトリ作業用 ディレクトリバス
        path = "{}/{}".format(self.lv_AnsibleTmpDirAry["DIR_NAME"], self.LC_ITA_TMP_DIR)
        self.setTowerProjectsScpPath(self.AnscObj.DF_GITREPO_TMP_PATH, path)

        # Tower用のconductorディレクトリ生成
        if in_conductor_instance_no:
            c_dirwk = "{}/{}".format(c_tmpdir, self.LC_ITA_CONDUCTOR_DIR)
            # isdirでディレクトリ有無チェック
            if os.path.isdir(c_dirwk) is False:
                os.mkdir(c_dirwk)
            os.chmod(c_dirwk, 0o777)
            c_dirwk = "{}/{}/{}".format(c_tmpdir, self.LC_ITA_CONDUCTOR_DIR, in_conductor_instance_no)
            # isdirでディレクトリ有無チェック
            if os.path.isdir(c_dirwk) is False:
                os.mkdir(c_dirwk)
            os.chmod(c_dirwk, 0o777)

        # ドライバ区分がPIONEERの場合にPIONEER用作業ディレクトリ作成
        if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
            # original_dialog_filesディレクトリ作成
            c_dirwk = c_tmpdir + "/" + self.LC_ANS_ORG_DIALOG_FILES_DIR
            # isdirでディレクトリ有無チェック
            if os.path.isdir(c_dirwk) is False:
                os.mkdir(c_dirwk)
            os.chmod(c_dirwk, 0o777)
            self.setAnsible_original_dialog_files_Dir(c_dirwk)

            # original_host_varsディレクトリ作成
            c_dirwk = c_tmpdir + "/" + self.LC_ANS_ORG_HOST_VARS_DIR
            # isdirでディレクトリ有無チェック
            if os.path.isdir(c_dirwk) is False:
                os.mkdir(c_dirwk)
            os.chmod(c_dirwk, 0o777)
            self.setAnsible_original_hosts_vars_Dir(c_dirwk)

            # vault_host_varsディレクトリ作成
            c_dirwk = c_tmpdir + "/" + self.LC_ANS_VAULT_HOST_VARS_DIR
            # isdirでディレクトリ有無チェック
            if os.path.isdir(c_dirwk) is False:
                os.mkdir(c_dirwk)
            os.chmod(c_dirwk, 0o777)
            self.setAnsible_vault_hosts_vars_Dir(c_dirwk)

            # pioneer_template_host_varsディレクトリ作成
            c_dirwk = c_tmpdir + "/" + self.LC_ANS_PIONEER_TEMPLATE_HOST_VARS_DIR
            # isdirでディレクトリ有無チェック
            if os.path.isdir(c_dirwk) is False:
                os.mkdir(c_dirwk)
            os.chmod(c_dirwk, 0o777)
            self.setAnsible_pioneer_template_hosts_vars_Dir(c_dirwk)

        # ansible-vault用ディレクトリ作成
        self.ansible_vault_password_file_dir = c_dir
        c_tmpdir = c_dir + "/.tmp"

        is_dir = os.path.isdir(c_tmpdir)
        if is_dir is False:
            os.mkdir(c_tmpdir)
            os.chmod(c_tmpdir, 0o777)

        self.setTemporary_file_Dir(c_tmpdir)

        # Ansible Egent用のディレクトリを作成
        if self.lv_exec_mode == AnscConst.DF_EXEC_MODE_AG:
            # Ansibe bulder用　shell作成
            ret, msgstr  = CreateAG_ITABuilderShellFiles(self.lv_objDBCA, self.AnscObj, self.getAnsible_in_builder_files_Dir(), in_execno, movement_row)
            if ret is False:
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                            str(inspect.currentframe().f_lineno), msgstr)
                return False, mt_rolenames, mt_rolevars, mt_roleglobalvars, mt_role_rolepackage_id, mt_def_vars_list, mt_def_array_vars_list

            # unner_executable_files配下にstart.sh・stop.sh・alive.shを生成する
            ret, msgstr = CreateAG_ITARunnerShellFiles(self.lv_objDBCA, self.AnscObj, self.getAnsible_in_runner_files_Dir(), in_execno, movement_row)
            if ret is False:
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)
                return False, mt_rolenames, mt_rolevars, mt_roleglobalvars, mt_role_rolepackage_id, mt_def_vars_list, mt_def_array_vars_list

        # ansible実行時、aah-agentで必要なexpectファイルを所定の場所にコピーする。
        self.CopysshAgentExpectfile()

        return True, mt_rolenames, mt_rolevars, mt_roleglobalvars, mt_role_rolepackage_id, mt_def_vars_list, mt_def_array_vars_list

    def CreateAnsibleWorkingFiles(self,
                                  ina_hosts,
                                  ina_host_vars,
                                  ina_pioneer_template_host_vars,
                                  ina_vault_vars,
                                  ina_vault_host_vars_file_list,
                                  ina_child_playbooks, ina_dialog_files,
                                  ina_rolenames,
                                  ina_role_rolenames,
                                  ina_role_rolevars,
                                  ina_role_roleglobalvars,
                                  ina_hostinfolist,
                                  ina_host_child_vars,
                                  ina_DB_child_vars_master,
                                  ina_MultiArray_vars_list,
                                  ina_def_vars_list,
                                  ina_def_array_vars_list,
                                  in_exec_mode,
                                  in_exec_playbook_hed_def,
                                  in_exec_option):
        """
        ansible用各作業ファイルを作成
        Arguments:
            ina_hosts:              機器一覧ホスト一覧
                                    {SYSTEM_ID:HOST_NAME}, , ,
            ina_host_vars:          ホスト変数配列
                                    [ホスト名][ 変数名 ]=>具体値
            ina_pioneer_template_host_vars:
                                    ホスト変数配列 pioneer template用 変数一覧返却配列 (passwordColumnの具体値がansible-vaultで暗号化)
                                    [ホスト名][ 変数名 ]=>具体値
            vault_vars:             PasswordCoulumn変数一覧(Pioneer用)
                                    [ 変数名 ] = << 変数名 >>
            ina_vault_host_vars_file_list:  PasswordCoulumn変数のみのホスト変数一覧(Pioneer用)
                                            [ホスト名(IP)][ 変数名 ] = 具体値
            ina_child_playbooks:    子PlayBookファイル配列
                                    [INCLUDE順序][素材管理Pkey]=>素材ファイル
                                    ※Legacyの場合のみ必須
            ina_dialog_files:       対話ファイル配列
                                    [ホスト名][INCLUDE順番][素材管理Pkey]=対話ファイル
                                    ※Pioneerの場合のみ必須
            ina_rolenames:          ロール名リスト配列(データベースの登録内容)
                                    ※Legacy-Roleの場合のみ必須
                                    [実行順序][ロールID(Pkey)]=>ロール名
            ina_role_rolenames:     ロール名リスト配列(Role内登録内容)
                                    ※Legacy-Roleの場合のみ必須
                                    [ロール名]
            ina_role_rolevars:      ロール内変数リスト配列(Role内登録内容)
                                    ※Legacy-Roleの場合のみ必須
                                    [ロール名][変数名]=0
            ina_role_roleglobalvars:    ロール内グローバル変数リスト配列(Role内登録内容)
                                        ※Legacy-Roleの場合のみ必須
                                        [ロール名][グローバル変数名]=0
            ina_hostinfolist:       機器一覧ホスト情報
                                    {HOST_NAME:{機器一覧各項目:xx, ....}} ...
            ina_host_child_vars:    配列変数一覧返却配列(変数一覧に配列変数含む)
                                    [ホスト名][ 変数名 ][列順序][メンバー変数]=[具体値]
            ina_DB_child_vars_master:
                                    メンバー変数マスタの配列変数のメンバー変数リスト返却
                                    [変数名][メンバー変数名]=0
            in_exec_mode:           実行エンジン
                                    1: Ansible  2: Ansible Tower
            in_exec_playbook_hed_def: 親playbookヘッダセクション
            in_exec_option:           予約
        Returns:
            bool
        """
        self.lv_hostinfolist = ina_hostinfolist

        # 追加された予約変数生成
        retAry = self.CreateOperationVariables(self.run_operation_id, ina_hostinfolist, ina_host_vars, ina_pioneer_template_host_vars)
        ret = retAry[0]
        ina_host_vars = retAry[1]
        ina_pioneer_template_host_vars = retAry[2]
        if ret is False:
            return False

        # Pioneer LANG用 ローカル変数設定
        retAry = self.CreatePioneerOtherVariables(ina_hostinfolist, ina_host_vars)
        ret = retAry[0]
        ina_host_vars = retAry[1]
        if ret is False:
            return False

        # 収集機能用ディレクトリ生成/ホスト変数生成
        retAry = self.CreateDirectoryForCollectionProcess(ina_hostinfolist, ina_host_vars, ina_pioneer_template_host_vars)
        ret = retAry[0]
        ina_host_vars = retAry[1]
        ina_pioneer_template_host_vars = retAry[2]
        if ret is False:
            return False

        # Movmentインスタンスステータスファイル変数生成
        retAry = self.CreateMovementStatusFileVariables(ina_hostinfolist, ina_host_vars, ina_pioneer_template_host_vars)
        ret = retAry[0]
        ina_host_vars = retAry[1]
        ina_pioneer_template_host_vars = retAry[2]
        if ret is False:
            return False

        # Movmentロールに紐づいているグローバル変数を退避
        if self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_ROLE_DRIVER_ID:
            for rokename, global_vars_array in ina_role_roleglobalvars.items():
                for gbl_vars_name, dummy in global_vars_array.items():
                    if gbl_vars_name not in self.lv_use_gbl_vars_list:
                        self.lv_use_gbl_vars_list[gbl_vars_name] = {}

        # hostsファイル作成
        pioneer_sshkeyfilelist = {}
        pioneer_sshextraargslist = {}

        retAry = self.CreateHostsfile(ina_hosts, ina_hostinfolist, pioneer_sshkeyfilelist, pioneer_sshextraargslist)
        ret = retAry[0]
        pioneer_sshkeyfilelist = retAry[1]
        pioneer_sshextraargslist = retAry[2]
        if ret is False:
            return False

        # ドライバ区分を判定
        if self.getAnsibleDriverID() in [self.AnscObj.DF_LEGACY_DRIVER_ID, self.AnscObj.DF_PIONEER_DRIVER_ID]:
            # ホスト変数定義ファイル作成
            if self.CreateHostvarsfiles(ina_host_vars, ina_pioneer_template_host_vars,
                                        ina_host_child_vars, ina_DB_child_vars_master) is False:
                return False

        if self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_ROLE_DRIVER_ID:
            # ホスト変数定義ファイル作成
            if self.CreateRoleHostvarsfiles(ina_host_vars, ina_MultiArray_vars_list, ina_def_vars_list, ina_def_array_vars_list) is False:
                return False

            # Role内で使用しているcopyモジュール変数をホスト変数定義ファイルに追加
            if self.CreateLegacyRoleCopyFiles(ina_hosts, ina_rolenames, self.lva_cpf_vars_list) is False:
                return False

            # Role内で使用しているtemplateモジュール変数をホスト変数定義ファイルに追加
            if self.CreateLegacyRoleTemplateFiles(ina_hosts, ina_rolenames, self.lva_tpf_vars_list) is False:
                return False

        # ドライバ区分を判定
        if self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_DRIVER_ID:
            # Legacy PlayBookファイル作成
            if self.CreateLegacyPlaybookfiles(ina_child_playbooks, in_exec_mode, in_exec_playbook_hed_def) is False:
                return False

            # 子Playbookのフォーマットと変数定義チェック
            if self.CheckLegacyPlaybookfiles(ina_hosts, ina_host_vars, ina_child_playbooks) is False:
                return False

            # 機器一覧の変数定義チェック
            if self.CheckVariablesDefinedInDeviceList(ina_hostinfolist, ina_host_vars) is False:
                return False

            # 子Playbook内のtemplateモジュールをチェック
            if self.CreateLegacytemplatefiles(ina_hosts, ina_child_playbooks, ina_host_vars) is False:
                return False

            # 子Playbook内のcopyモジュールをチェック
            if self.CreateLegacyCopyFiles(ina_hosts, ina_child_playbooks) is False:
                return False

            # ホスト変数ファイルにグローバル変数・ファイル管理変数
            # テンプレート変数の情報を出力する。
            if self.CommitHostVarsfiles(ina_hosts, ina_host_vars, ina_pioneer_template_host_vars) is False:
                return False

        elif self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
            # Pionner 暗号化が必要な変数のホスト変数ファイル作成
            if self.CreateVaultHostvarsfiles(ina_vault_host_vars_file_list, ina_host_vars, ina_hostinfolist) is False:
                return False

            # Pionner 対話ファイル作成
            if self.CreatePioneerDialogfiles(ina_hostinfolist, ina_dialog_files, ina_host_vars,
                                             pioneer_sshkeyfilelist,
                                             pioneer_sshextraargslist,
                                             in_exec_mode) is False:
                return False

            # 対話ファイル内のtemplateモジュールをチェック
            if self.CreatePioneertemplatefiles(ina_hosts, ina_dialog_files, ina_host_vars) is False:
                return False

            # 対話ファイル内のcopyモジュールをチェック
            if self.CreatePioneerCopyFiles(ina_hosts, ina_dialog_files) is False:
                return False

            # 対話ファイルのフォーマットと変数定義チェック
            # 変数具体値の置換え
            if self.CheckPioneerPlaybookfiles(ina_hosts, ina_host_vars, ina_vault_vars, ina_dialog_files, False) is False:
                return False

            # ホスト変数ファイルにグローバル変数・コピー変数
            # テンプレート変数の情報を出力する。
            if self.CommitHostVarsfiles(ina_hosts, ina_host_vars, ina_pioneer_template_host_vars) is False:
                return False

            # 具体値がTPF/CPF変数の場合の具体値の置換え
            if self.CheckPioneerPlaybookfiles(ina_hosts, ina_host_vars, ina_vault_vars, ina_dialog_files, True) is False:
                return False

            # テンプレート管理を使用している場合、
            # 親PlaybookにTemplateMmoduleを追加して
            # テンプレート内の変数解決する。
            if len(self.lv_tpf_var_file_path_list) > 0:
                self.TemplateMmoduleAddPlaybook(self.lv_tpf_var_file_path_list)

        elif self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_ROLE_DRIVER_ID:
            # Legacy-Role PlayBookファイル作成
            if self.CreateLegacyRolePlaybookfiles(ina_rolenames, in_exec_mode, in_exec_playbook_hed_def) is False:
                return False

            # ロール内の変数定義チェック
            if self.CheckLegacyRolePlaybookfiles(ina_hosts,
                                                 ina_host_vars,
                                                 ina_rolenames,
                                                 ina_role_rolenames,
                                                 ina_role_rolevars,
                                                 ina_role_roleglobalvars) is False:
                return False

        # Movement一覧にAnsible Config Fileが設定されている場合にin配下にコピー
        if self.lv_ansible_cnf_file:
            if self.CopyAnsibleConfigFile() is False:
                return False

        return True

    def CreateHostsfile(self, ina_hosts, ina_hostinfolist, mt_pioneer_sshkeyfilelist, mt_pioneer_sshextraargslist):
        """
        hostsファイルを作成する。
        Arguments:
            ina_hosts:                      機器一覧ホスト一覧
                                            {SYSTEM_ID:HOST_NAME}, , ,
            ina_hostinfolist:               機器一覧ホスト情報
                                            {HOST_NAME:{機器一覧各項目:xx, ....}} ...
            ina_sshkeyfilelist:             SSHSSH秘密鍵ファイルリスト(pioneer専用)
            ina_pioneer_sshextraargslist:   SSH_EXTRA_ARGSリスト(pioneer専用)
        Returns:
            bool, mt_pioneer_sshkeyfilelist mt_pioneer_sshextraargslist
        """
        mt_pioneer_sshkeyfilelist = {}
        mt_pioneer_sshextraargslist = {}

        CreateSSHAgentConfigInfoFile = False
        # ssh-agentの設定に必要な情報を一時ファイル削除
        SSHAgentConfigInfoFile = "{}/{}".format(self.getTemporary_file_Dir(), self.LC_ANS_SSHAGENTCONFIG_FILE)

        file_name = self.getAnsible_hosts_file()
        # #2079 /storage配下は/tmpを経由してアクセスする
        obj = storage_write()
        obj.open(file_name, 'w')

        # 固定ファイル出力
        header = ""
        header += "all:\n"
        header += "  children:\n"
        header += "    hostgroups:\n"
        header += "      hosts:\n"

        obj.write(header)

        spaceStr = ""
        indento_sp_host = spaceStr.ljust(8)
        indento_sp_param = spaceStr.ljust(10)
        indento_sp12 = spaceStr.ljust(24)
        for host_id, host_name in ina_hosts.items():
            ssh_extra_args = ""
            # ssh_extra_argsの設定の有無を判定しssh_extra_argsの内容を退避
            if ina_hostinfolist[host_name]['SSH_EXTRA_ARGS']:
                # "を\"に置き換え
                ssh_extra_args = ina_hostinfolist[host_name]['SSH_EXTRA_ARGS'].replace('\"', '\\"')
                if self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_DRIVER_ID or \
                   self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_ROLE_DRIVER_ID:
                    # hostsファイルに追加するssh_extra_argsを生成
                    ssh_extra_args = 'ansible_ssh_extra_args: "' + ssh_extra_args + '"'
                else:
                    # Pioneer用にssh_extra_argsを退避
                    mt_pioneer_sshextraargslist[host_name] = ssh_extra_args
                    ssh_extra_args = ""

            hosts_extra_args = ""
            if self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_DRIVER_ID or self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_ROLE_DRIVER_ID:
                # hosts_extra_argsの設定の有無を判定しhosts_extra_argsの内容を退避
                if ina_hostinfolist[host_name]['HOSTS_EXTRA_ARGS']:
                    #
                    errorDetail = ""
                    retAry = self.InventryFileAddOptionCheckFormat(ina_hostinfolist[host_name]['HOSTS_EXTRA_ARGS'], hosts_extra_args, errorDetail)
                    ret = retAry[0]
                    hosts_extra_args = retAry[1]
                    errorDetail = retAry[2]
                    if ret is False:
                        msgstr = g.appmsg.get_api_message("MSG-10625", [host_name, errorDetail])
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        return False, mt_pioneer_sshkeyfilelist, mt_pioneer_sshextraargslist
                    # array->文字列に変換
                    hosts_extra_args = "<<<__TAB__>>>".join(hosts_extra_args)
                    hosts_extra_args = hosts_extra_args.replace("<<<__TAB__>>>", "\n" + indento_sp_param)

            param = ""
            passwd = ""
            port = ""

            # sshの接続パラメータ生成
            if self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_DRIVER_ID or self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_ROLE_DRIVER_ID:
                # ユーザー設定
                # self.LC_ANS_UNDEFINE_NAMEでチェックしてるなか？
                # if ina_hostinfolist[host_name]['LOGIN_USER'] != self.LC_ANS_UNDEFINE_NAME):
                if ina_hostinfolist[host_name]['LOGIN_USER']:
                    param = "ansible_user: " + ina_hostinfolist[host_name]['LOGIN_USER']

                # パスワード設定
                if ina_hostinfolist[host_name]['LOGIN_AUTH_TYPE'] == self.AnscObj.DF_LOGIN_AUTH_TYPE_PW or\
                   ina_hostinfolist[host_name]['LOGIN_AUTH_TYPE'] == self.AnscObj.DF_LOGIN_AUTH_TYPE_PW_WINRM:
                    # パスワードが設定されているか WinRMの場合、パスワード未設定の場合あり
                    if ina_hostinfolist[host_name]['LOGIN_PW']:

                        # パスワード暗号化
                        login_pw_ansible_vault = ""
                        make_vaultpass = self.makeAnsibleVaultPassword(
                            ina_hostinfolist[host_name]['LOGIN_PW'],
                            login_pw_ansible_vault,
                            indento_sp12,
                            ina_hostinfolist[host_name]['SYSTEM_ID'])
                        if make_vaultpass is False:
                            return False, mt_pioneer_sshkeyfilelist, mt_pioneer_sshextraargslist

                        passwd = "ansible_password: " + make_vaultpass

                # Winrm接続情報
                if ina_hostinfolist[host_name]['LOGIN_AUTH_TYPE'] in (self.AnscObj.DF_LOGIN_AUTH_TYPE_PW_WINRM,self.AnscObj.DF_LOGIN_AUTH_TYPE_KEY_WINRM):
                    # WINRM接続プロトコルよりポート番号が未設定時は、self.LC_WINRM_PORTが設定されている
                    port = "ansible_port: " + str(ina_hostinfolist[host_name]['WINRM_PORT'])
                    port += "\n" + indento_sp_param + "ansible_connection: winrm"

            ssh_key_file = ''
            win_private_key_file = ''
            win_public_key_file = ''
            win_transport = ''
            passphrase = ''
            sshpassprompt = ''

            # 秘密鍵ファイルが必要な認証方式か判定
            if ina_hostinfolist[host_name]['LOGIN_AUTH_TYPE'] == self.AnscObj.DF_LOGIN_AUTH_TYPE_KEY or\
               ina_hostinfolist[host_name]['LOGIN_AUTH_TYPE'] == self.AnscObj.DF_LOGIN_AUTH_TYPE_KEY_PP_USE:
                if ina_hostinfolist[host_name]['SSH_KEY_FILE']:
                    # 機器一覧にSSH鍵認証ファイルが登録されている場合はSSH鍵認証ファイルをinディレクトリ配下にコピーする。
                    retAry = self.CreateSSH_key_file(ina_hostinfolist[host_name]['SYSTEM_ID'], ina_hostinfolist[host_name]['SSH_KEY_FILE'])
                    ret = retAry[0]
                    ssh_key_file_path = retAry[1]
                    if ret is not True:
                        return False, mt_pioneer_sshkeyfilelist, mt_pioneer_sshextraargslist

                    # ansible実行時のパスに変更
                    ssh_key_file_path = self.setAnsibleSideFilePath(ssh_key_file_path, self.LC_ITA_IN_DIR)
                    # 秘密鍵認証の場合にssh-agntでパスフレーズの入力を省略する為の情報生成
                    if ina_hostinfolist[host_name]['LOGIN_AUTH_TYPE'] == self.AnscObj.DF_LOGIN_AUTH_TYPE_KEY_PP_USE:
                        if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG: # enomomto 実行エンジンがAnsible Agentの場合の場合、秘密鍵認証（パスフレーズあり）の場合にパスフレーズを暗号化
                            # 秘密鍵認証（パスフレーズあり）の場合にパスフレーズを暗号化しansible_passとEnter passphrase for keyを設定
                            login_pw_ansible_vault = ""
                            make_vaultpass = self.makeAnsibleVaultPassword(ina_hostinfolist[host_name]['LOGIN_PW'],
                                                                           login_pw_ansible_vault,
                                                                           indento_sp12,
                                                                           ina_hostinfolist[host_name]['SSH_KEY_FILE_PASSPHRASE'])
                            if make_vaultpass is False:
                                return False, mt_pioneer_sshkeyfilelist, mt_pioneer_sshextraargslist

                            passphrase = "ansible_pass: " + make_vaultpass
                            sshpassprompt = "Enter passphrase for key: " + '"Enter passphrase for key"'

                        if ina_hostinfolist[host_name]["SSH_KEY_FILE_PASSPHRASE"]:
                            CreateSSHAgentConfigInfoFile = True

                            # ssh-agentの設定に必要な情報を一時ファイルに出力
                            # enomomto AGの場合をssh-agent用のssh鍵ファイルのバスを加工する。
                            if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG:
                                write_ssh_key_file_path = Replace_HostVrasFilepath("in", ssh_key_file_path)
                            else:
                                write_ssh_key_file_path = ssh_key_file_path
                            if self.CreateSSHAgentConfigInfoFile(SSHAgentConfigInfoFile, ina_hostinfolist[host_name]["HOST_NAME"],
                                                                 write_ssh_key_file_path,
                                                                 ina_hostinfolist[host_name]["SSH_KEY_FILE_PASSPHRASE"]) is False:
                                return False, mt_pioneer_sshkeyfilelist, mt_pioneer_sshextraargslist

                    if self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_DRIVER_ID or\
                       self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_ROLE_DRIVER_ID:
                        # AGの場合をansible_ssh_private_key_fileのバスを加工する。
                        if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG:
                            write_ssh_key_file_path = Replace_HostVrasFilepath("in", ssh_key_file_path)
                        else:
                            write_ssh_key_file_path = ssh_key_file_path
                        # hostsファイルに追加するSSH鍵認証ファイルのパラメータ生成
                        ssh_key_file = 'ansible_ssh_private_key_file: ' + write_ssh_key_file_path
                    else:
                        # mt_pioneer_sshkeyfilelist[host_name] = ssh_key_file_path
                        if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG:
                            write_ssh_key_file_path = Replace_HostVrasFilepath("in", ssh_key_file_path)
                        else:
                            write_ssh_key_file_path = ssh_key_file_path
                        mt_pioneer_sshkeyfilelist[host_name] = write_ssh_key_file_path

            elif ina_hostinfolist[host_name]['LOGIN_AUTH_TYPE'] == self.AnscObj.DF_LOGIN_AUTH_TYPE_KEY_WINRM:
                win_transport = 'ansible_winrm_transport: certificate'

                # winRM公開鍵ファイルをインベントリファイルに追加
                if ina_hostinfolist[host_name]['WINRM_CERT_PEM_FILE']:
                    # 機器一覧のwinRM公開鍵ファイルに登録ファイルをinディレクトリ配下にコピーする
                    retAry = self.CreateWinrmPublicKeyFile(ina_hostinfolist[host_name]['SYSTEM_ID'],
                                                            ina_hostinfolist[host_name]['WINRM_CERT_PEM_FILE'])

                    ret = retAry[0]
                    win_private_key_file_path = retAry[1]

                    if ret is not True:
                        return False, mt_pioneer_sshkeyfilelist, mt_pioneer_sshextraargslist

                    # ky_encryptで中身がスクランブルされているので、復元
                    ret = ky_file_decrypt(win_private_key_file_path, win_private_key_file_path)
                    if ret is False:
                        msgstr = g.appmsg.get_api_message("MSG-10943", [ina_hostinfolist[host_name]['WINRM_CERT_PEM_FILE']])
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        return False, mt_pioneer_sshkeyfilelist, mt_pioneer_sshextraargslist

                    # ansible実行時のパスに変更
                    win_private_key_file_path = self.setAnsibleSideFilePath(win_private_key_file_path, self.LC_ITA_IN_DIR)

                    # enomomto AGの場合にansible_winrm_cert_pemのパスを加工
                    if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG: # enomomto AGの場合を追加
                        write_win_private_key_file_path = Replace_HostVrasFilepath("in", win_private_key_file_path)
                    else:
                        write_win_private_key_file_path = win_private_key_file_path

                    if self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_DRIVER_ID or\
                       self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_ROLE_DRIVER_ID:
                        # hostsファイルに追加するサーバー証明書ファイルのパラメータ生成
                        win_private_key_file = 'ansible_winrm_cert_pem: ' + write_win_private_key_file_path
                # winRM秘密鍵ファイルをインベントリファイルに追加
                if ina_hostinfolist[host_name]['WINRM_CERT_KEY_PEM_FILE']:
                    # 機器一覧のwinRM秘密鍵ファイルに登録ファイルをinディレクトリ配下にコピーする
                    retAry = self.CreateWinrmPrivateKeyFile(ina_hostinfolist[host_name]['SYSTEM_ID'],
                                                            ina_hostinfolist[host_name]['WINRM_CERT_KEY_PEM_FILE'])

                    ret = retAry[0]
                    win_public_key_file_path = retAry[1]

                    if ret is not True:
                        return False, mt_pioneer_sshkeyfilelist, mt_pioneer_sshextraargslist

                    # ky_encryptで中身がスクランブルされているので、復元
                    ret = ky_file_decrypt(win_public_key_file_path, win_public_key_file_path)
                    if ret is False:
                        msgstr = g.appmsg.get_api_message("MSG-10944", [ina_hostinfolist[host_name]['WINRM_CERT_KEY_PEM_FILE']])
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        return False, mt_pioneer_sshkeyfilelist, mt_pioneer_sshextraargslist

                    # ansible実行時のパスに変更
                    win_public_key_file_path = self.setAnsibleSideFilePath(win_public_key_file_path, self.LC_ITA_IN_DIR)
                    # ansible agentの場合をansible_winrm_cert_key_pemのバスを加工する。
                    if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG:
                        # ansible agentの場合を追加
                        write_win_public_key_file_path = ("/in/", win_public_key_file_path)
                    else:
                        write_win_public_key_file_path = win_public_key_file_path

                    if self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_DRIVER_ID or\
                       self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_ROLE_DRIVER_ID:
                        # hostsファイルに追加するサーバー証明書ファイルのパラメータ生成
                        win_public_key_file = 'ansible_winrm_cert_key_pem: ' + write_win_public_key_file_path

            now_host_name = ""
            host_name_string = ""
            # ホストアドレス方式がホスト名方式の場合はホスト名をhostsに登録する。
            # hostname:
            #   ansible_host: ip/dnshost
            #  1/None: ip  2: host
            if self.lv_hostaddress_type == "2":
                host_name_string = indento_sp_host + ina_hostinfolist[host_name]['HOST_NAME'] + ":\n"
                host_name_string += indento_sp_param + 'ansible_host: ' + ina_hostinfolist[host_name]['HOST_DNS_NAME'] + "\n"
                now_host_name = ina_hostinfolist[host_name]['HOST_DNS_NAME']
            else:
                # ホストアドレス方式がIPアドレスの場合
                host_name_string = indento_sp_host + ina_hostinfolist[host_name]['HOST_NAME'] + ":\n"
                host_name_string += indento_sp_param + 'ansible_host: ' + ina_hostinfolist[host_name]['IP_ADDRESS'] + "\n"

            # Pioneerでホスト名がlocalhostの場合に、インベントファイルに
            # ansible_connection: localを追加する
            if now_host_name == 'localhost' and self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                host_name_string += indento_sp_param + "ansible_connection: local\n"

            if len(param) != 0:
                host_name_string += indento_sp_param + param + "\n"

            if len(passwd) != 0:
                host_name_string += indento_sp_param + passwd + "\n"

            if len(passphrase) != 0:
                host_name_string += indento_sp_param + passphrase + "\n"

            if len(sshpassprompt) != 0:
                host_name_string += indento_sp_param + sshpassprompt + "\n"

            if len(port) != 0:
                host_name_string += indento_sp_param + port + "\n"

            if len(ssh_key_file) != 0:
                host_name_string += indento_sp_param + ssh_key_file + "\n"

            if len(ssh_extra_args) != 0:
                host_name_string += indento_sp_param + ssh_extra_args + "\n"

            if len(hosts_extra_args) != 0:
                host_name_string += indento_sp_param + hosts_extra_args + "\n"

            if len(win_transport) != 0:
                host_name_string += indento_sp_param + win_transport + "\n"

            if len(win_private_key_file) != 0:
                host_name_string += indento_sp_param + win_private_key_file + "\n"

            if len(win_public_key_file) != 0:
                host_name_string += indento_sp_param + win_public_key_file + "\n"

            obj.write(host_name_string)

        obj.close()

        # ssh-agentの設定に必要な情報を一時ファイルをスクランブル
        if CreateSSHAgentConfigInfoFile is True:
            ret = ky_file_encrypt(SSHAgentConfigInfoFile, SSHAgentConfigInfoFile)
            if ret is False:
                #
                msgstr = g.appmsg.get_api_message("MSG-10297", [])
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)
                return False, mt_pioneer_sshkeyfilelist, mt_pioneer_sshextraargslist

        return True, mt_pioneer_sshkeyfilelist, mt_pioneer_sshextraargslist

    def DeleteUnuseData(self, srcData, chkList):
        '''
        辞書型配列から不要なデータを削除
        Arguments:
            srcData: 辞書型配列
            {ロール名: {ファイル名: {行番号: {変数名: 0},,,,}}}
            chkList: 辞書に必要なキーリスト
                    ['role1', 'role2']
        Returns:
            srcData
        '''
        for roleName in list(srcData.keys()):
            useFlag = False
            for useRoleName in chkList:
                if roleName == useRoleName:
                    useFlag = True
                    break
            if useFlag is False:
                del srcData[roleName]
        return srcData

    def InventryFileAddOptionCheckFormat(self, in_string, mt_yaml_array, mt_error_line):
        """
        インベントリファイル追加オプション(YAML形式)を検査
        Arguments:
            in_string: インベントリファイル追加オプション
            mt_yaml_array: インベントリファイル追加オプションを行単位にリスト化
            mt_yamlParse_error: YAML文法エラー時のエラー内容
        Returns:
            True/False, mt_yaml_array, mt_yamlParse_error
        """
        mt_yaml_array = in_string.split("\n")
        tmpFile = "{}/yamlParse_{}".format(get_OSTmpPath(), os.getpid())
        # /tmpに作成したファイルはゴミ掃除リストに追加
        addAnsibleCreateFilesPath(tmpFile)
        # #2079 /storage配下ではないので対象外
        fd = open(tmpFile, 'w')
        fd.write(in_string)
        fd.close()
        obj = YamlParse()
        ret = obj.Parse(tmpFile)

        os.remove(tmpFile)
        if ret is False:
            mt_error_line = obj.GetLastError()
            return False, mt_yaml_array, mt_error_line
        return True, mt_yaml_array, mt_error_line

    def CreateRoleHostvarsfiles(self, ina_host_vars, ina_MultiArray_vars_list, def_vars_list, ina_def_array_vars_list):
        """
        ホスト変数ファイルを作成する。(Role専用)
        Arguments:
            ina_host_vars:          ホスト変数配列
                                    [ホスト名][ 変数名 ]=>具体値
            ina_MultiArray_vars_list:
            def_vars_list:
            ina_def_array_vars_list:
        Returns:
            True/False
        """
        # ホスト分繰返し
        for host_name in ina_host_vars.keys():
            host_vars_file = host_name
            file_name = self.getAnsible_host_var_file(host_vars_file)
            vars_list = ina_host_vars[host_name]

            # ホスト変数定義ファイル作成
            if self.CreateRoleHostvarsfile("VAR",
                                           file_name,
                                           vars_list,
                                           ina_MultiArray_vars_list,
                                           def_vars_list,
                                           ina_def_array_vars_list,
                                           host_name) is False:
                return False
        return True

    def CreateRoleHostvarsfile(self,
                               in_var_type,
                               in_file_name,
                               ina_var_list,
                               ina_MultiArray_vars_list,
                               ina_role_rolevars,
                               ina_def_array_vars_list,
                               in_host_name, in_mode="w"):
        """
        指定ホストのホスト変数定義ファイルを作成する。(Role専用)
        Arguments:
            in_var_type:        登録対象の変数タイプ  "VAR"/"CPF"
            in_file_name:       ホスト変数定義ファイル名
            ina_var_list:       ホスト変数配列
            ina_MultiArray_vars_list:
            ina_role_rolevars:
            ina_def_array_vars_list:
            in_host_name:
            in_mode:            書込モード
                                    "w":上書   デフォルト
                                    "a":追加

        Returns:
            True/False
        """
        parent_vars_list = {}

        # LegacyRoleCheckConcreteValueIsVarで必要な情報を退避
        self.LegacyRoleCheckConcreteValueIsVar_use_host_name = in_host_name
        if in_var_type == "VAR":
            if in_host_name not in self.LegacyRoleCheckConcreteValueIsVar_use_var_list:
                self.LegacyRoleCheckConcreteValueIsVar_use_var_list[in_host_name] = {}
            self.LegacyRoleCheckConcreteValueIsVar_use_var_list[in_host_name] = ina_var_list

        if in_host_name not in self.lv_legacy_Role_cpf_vars_list:
            self.lv_legacy_Role_cpf_vars_list[in_host_name] = {}
        if in_host_name not in self.lv_legacy_Role_tpf_vars_list:
            self.lv_legacy_Role_tpf_vars_list[in_host_name] = {}

        var_str = ""

        for var, val in ina_var_list.items():
            # 変数の重複出力防止
            if var in parent_vars_list:
                continue

            # 機器一覧のプロトコルが未登録の場合を判定
            if var == self.AnscObj.ITA_SP_VAR_ANS_PROTOCOL_VAR_NAME and val == self.LC_ANS_UNDEFINE_NAME:
                # __loginprotocol__をホスト変数に出力しない
                continue
            # コピー変数の重複出力防止
            if in_var_type == "CPF":
                if var in self.lv_legacy_Role_cpf_vars_list[in_host_name]:
                    continue
            # テンプレート変数の重複出力防止
            if in_var_type == "TPF":
                if var in self.lv_legacy_Role_tpf_vars_list[in_host_name]:
                    continue

            parent_vars_list[var] = 0

            # 機器一覧のパスワードをansible-vaultで暗号化
            if var == self.AnscObj.ITA_SP_VAR_ANS_PASSWD_VAR_NAME and val != self.LC_ANS_UNDEFINE_NAME:
                # ansible-vaultで暗号化された文字列のインデントを調整
                indento_sp4 = "".ljust(4)

                login_pw_ansible_vault = ""
                make_vaultpass = self.makeAnsibleVaultPassword(
                    val,
                    login_pw_ansible_vault,
                    indento_sp4,
                    self.lv_hostinfolist[in_host_name]['SYSTEM_ID'])
                if make_vaultpass is False:
                    return False

                val = make_vaultpass

            # ホスト変数ファイルのレコード生成
            # 変数名: 具体値
            NumPadding = 2
            edit_val = self.HostVarEdit(val, NumPadding)
            var_str += "{}: {}\n".format(var, edit_val)

            # 変数の具体値に使用しているテンプレート/コピー変数の情報を確認
            if in_var_type == "VAR":
                retAry = self.LegacyRoleCheckConcreteValueIsVar(val,
                                                                self.lv_legacy_Role_cpf_vars_list[in_host_name],
                                                                self.lv_legacy_Role_tpf_vars_list[in_host_name])
                ret = retAry[0]
                self.lv_legacy_Role_cpf_vars_list[in_host_name] = retAry[1]
                self.lv_legacy_Role_tpf_vars_list[in_host_name] = retAry[2]
                if ret is False:
                    # エラーメッセージは出力しているので、ここでは何も出さない。
                    return False

        # copy/templateモジュール変数のみ登録で呼ばれるケースの対応
        if in_mode == "w":
            parent_vars_list = {}
            MultiArrayVars_str = ""
            retAry = self.MultiArrayVarsToYamlFormatMain(
                ina_MultiArray_vars_list,
                MultiArrayVars_str,
                parent_vars_list,
                in_host_name,
                self.lv_legacy_Role_cpf_vars_list[in_host_name],
                self.lv_legacy_Role_tpf_vars_list[in_host_name])
            ret = retAry[0]
            MultiArrayVars_str = retAry[1]
            parent_vars_list = retAry[2]
            self.lv_legacy_Role_cpf_vars_list[in_host_name] = retAry[3]
            self.lv_legacy_Role_tpf_vars_list[in_host_name] = retAry[4]
            if ret is False:
                msgstr = g.appmsg.get_api_message("MSG-10457", [])
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)
                return False

            var_str += MultiArrayVars_str

            # グローバル変数をホスト変数ファイルに登録する。
            for var, val in self.lva_global_vars_list.items():
                # 作業パターンに紐づいているロール以外で使用しているグローバル変数を除外
                if var not in self.lv_use_gbl_vars_list:
                    continue

                # 二重処理防止
                if var in parent_vars_list:
                    continue

                parent_vars_list[var] = 0

                # 変数名: 具体値
                # 複数行具体値の場合に複数行の扱い記号を付ける
                edit_val = self.makeMultilineValue(val)

                NumPadding = 2
                out_val = self.MultilineValueEdit(edit_val, NumPadding)
                var_str += "{}: {}\n".format(var, out_val)

                # グローバル変数の具体値にコピー変数があるか確認
                retAry = self.LegacyRoleCheckConcreteValueIsVar(val,
                                                                self.lv_legacy_Role_cpf_vars_list[in_host_name],
                                                                self.lv_legacy_Role_tpf_vars_list[in_host_name])
                ret = retAry[0]
                self.lv_legacy_Role_cpf_vars_list[in_host_name] = retAry[1]
                self.lv_legacy_Role_tpf_vars_list[in_host_name] = retAry[2]
                if ret is False:
                    return False

            # "VAR"でしかこないルート 多段変数と他変数と同時に出力する。
            #  変数の具体値に使用しているコピー変数の情報をホスト変数ファイルに出力
            for var, val in self.lv_legacy_Role_cpf_vars_list[in_host_name].items():
                # 変数名: 具体値
                var_str += "{}: {}\n".format(var, val)

            # 変数の具体値に使用しているテンプレート変数の情報をホスト変数ファイルに出力
            for var, val in self.lv_legacy_Role_tpf_vars_list[in_host_name].items():
                # 変数名: 具体値
                var_str += "{}: {}\n".format(var, val)

        if var_str:
            # #2079 /storage配下は/tmpを経由してアクセスする
            obj = storage_write()
            obj.open(in_file_name, in_mode)
            obj.write(var_str)
            obj.close()

        return True

    def CreatePlaybookfile(self, in_file_name, ina_playbook_list, in_exec_mode, in_exec_playbook_hed_def):
        """
        親Playbook作成
        Arguments:
            in_file_name                親Playbookパス
            ina_playbook_list:          Roleの場合
                                        ロール名リスト配列
                                        {実行順序:{ロールID(Pkey):ロール名}}
            in_exec_mode:               実行エンジン
                                        1: Ansible  2: Ansible Tower
            in_exec_playbook_hed_def:   親playbookヘッダセクション
        Returns:
            True/False
        """

        # #2079 /storage配下は/tmpを経由してアクセスする
        obj = storage_write()
        obj.open(in_file_name, "w")
        # ドライバ区分判定
        value = ""
        if self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_DRIVER_ID:
            if not in_exec_playbook_hed_def:
                value = "- hosts: all\n"
                value += "  remote_user: \"{{ " + self.AnscObj.ITA_SP_VAR_ANS_USERNAME_VAR_NAME + " }}\"\n"
                value += "  gather_facts: no\n"

                # 対象ホストがwindowsか判別。windows以外の場合は become: yes を設定
                if self.lv_winrm_id != "1":
                    value += "  become: yes\n"
            else:
                value = in_exec_playbook_hed_def
                value += "\n"
            value += "\n"
            value += "  tasks:\n"
        elif self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
            value = "- hosts: all\n"
            value = value + "  gather_facts: False\n"
            value = value + "\n"
            value = value + "  tasks:\n"
            pass
        elif self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_ROLE_DRIVER_ID:
            if not in_exec_playbook_hed_def:
                value = "- hosts: all\n"
                value += "  remote_user: \"{{ " + self.AnscObj.ITA_SP_VAR_ANS_USERNAME_VAR_NAME + " }}\"\n"
                value += "  gather_facts: no\n"

                # 対象ホストがwindowsか判別。windows以外の場合は become: yes を設定
                if self.lv_winrm_id != "1":
                    value += "  become: yes\n"
            else:
                value = in_exec_playbook_hed_def
                value += "\n"

            value = value + "\n"
            value = value + "  roles:\n"

        obj.write(value)
        value = ""
        for no, file_list in ina_playbook_list.items():
            for key, file in file_list.items():
                # ドライバ区分判定
                if self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_DRIVER_ID:
                    target_playbook_path = self.getPlaybook_child_playbook_file(key, file)
                    value += "    - include_tasks: " + target_playbook_path + "\n"

                elif self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                    log_file_path = self.setAnsibleSideFilePath(self.getAnsible_out_Dir(), self.LC_ITA_OUT_DIR)
                    host_vars_path = self.setAnsibleSideFilePath(self.getAnsible_original_hosts_vars_Dir(), self.LC_ITA_TMP_DIR)

                    # original_exec_dirはオリジナル対話ファイル格納ディレクトリを渡し、pioneer_module.pyでexec_fileのファイル名と結合してファイル名を解決
                    value += "    - name: pioneer_module exec\n"
                    value += "      pioneer_module: username={{ " + self.AnscObj.ITA_SP_VAR_ANS_USERNAME_VAR_NAME + " }} " + \
                             "protocol={{ " + self.AnscObj.ITA_SP_VAR_ANS_PROTOCOL_VAR_NAME + " }} " + \
                             "exec_file={{ " + file + " }} " + \
                             "inventory_hostname={{ " + self.AnscObj.ITA_SP_VAR_TARGETHOSTNAME_VAR_NAME + " }} " + \
                             "host_vars_file='" + host_vars_path + "/{{ " + self.AnscObj.ITA_SP_VAR_ANS_INVENTORYHOST_VAR_NAME + " }}' " + \
                             "grep_shell_dir='./library' " + \
                             "log_file_dir='" + log_file_path + "' " + \
                             "ssh_key_file={{ " + self.LC_ANS_SSH_KEY_FILE_VAR_NAME + " }} " + \
                             "extra_args={{ " + self.LC_ANS_SSH_EXTRA_ARGS_VAR_NAME + " }} " + \
                             "lang={{ " + self.LC_ANS_PIONEER_LANG_VAR_NAME + " }} " + \
                             "original_exec_dir={{ " + self.LC_ANS_PIONEER_ORIGINAL_EXEC_FILE_DIR + " }} " + \
                             "encode_column_encode_value_file={{ " + self.LC_ANS_PIONEER_ENCODE_COLUMN_ENCODE_VALUE_FILE + " }} " + \
                             "ssh_phrases={{ " + self.LC_ANS_PIONEER_SSH_PHRASES + " | default('__undef__') }} " + \
                             "ssh_phrases_flg={{ " + self.LC_ANS_PIONEER_SSH_PHRASES_FLG + " }} \n"
                    value += "      delegate_to: 127.0.0.1\n"
                elif self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_ROLE_DRIVER_ID:
                    value += "    - role: " + file + "\n"

        obj.write(value)
        obj.close()

        return True

    def setAnsibleDriverID(self, in_val):
        """
        Ansibleドライバ(legacy/pioneer/role)区分を記憶
        Arguments:
            in_val: Ansibleドライバ区分
                    legacy:       self.AnscObj.DF_LEGACY_DRIVER_ID
                    pioneer:      self.AnscObj.DF_PIONEER_DRIVER_ID
                    role:         self.AnscObj.DF_LEGACY_ROLE_DRIVER_ID
        Returns:
            なし
        """
        self.lv_Ansible_driver_id = in_val

    def getAnsibleDriverID(self):
        """
        Ansibleドライバ(legacy/pioneer/role)区分を取得
        Arguments:
            なし
        Returns:
            Ansibleドライバ区分
            legacy:       self.AnscObj.DF_LEGACY_DRIVER_ID
            pioneer:      self.AnscObj.DF_PIONEER_DRIVER_ID
            role:         self.AnscObj.DF_LEGACY_ROLE_DRIVER_ID
        """
        return self.lv_Ansible_driver_id

    def setAnsibleBaseDir(self, in_base_name, in_dir):
        """
        Ansible用 各種ベースディレクトリ名を記憶
        Arguments:
            in_base_name: 共有パス区分
                        ANSIBLE_SH_PATH_ITA:  Ansible作業用 ITA側
                        ANSIBLE_SH_PATH_ANS:  Ansible作業用 Ansible側
                        CONDUCTOR_STORAGE_PATH_ITA: conductor作業用 ITA側
                        CONDUCTOR_STORAGE_PATH_ANS: conductor作業用 Ansible側
            in_dir:       ベースディレクトリ
        Returns:
            なし
        """
        self.lv_Ansible_base_Dir[in_base_name] = in_dir

    def getAnsibleBaseDir(self, in_base_name):
        """
        Ansible用 各種ベースディレクトリ名を取得
        Arguments:
            in_base_name: 共有パス区分
                        ANSIBLE_SH_PATH_ITA:  Ansible作業用 ITA側
                        ANSIBLE_SH_PATH_ANS:  Ansible作業用 Ansible側
                        CONDUCTOR_STORAGE_PATH_ITA: conductor作業用 ITA側
                        CONDUCTOR_STORAGE_PATH_ANS: conductor作業用 Ansible側
        Returns:
            Ansible用 各種ベースディレクトリ名
        """
        return self.lv_Ansible_base_Dir[in_base_name]

    def setAnsible_in_Dir(self, in_indir):
        """
        作業実行inディレクトリパスを記憶
        Arguments:
            in_dir:   作業実行inディレクトリ
        Returns:
            なし
        """
        self.lv_Ansible_in_Dir = in_indir

    def getAnsible_in_Dir(self):
        """
        作業実行inディレクトリパスを取得
        Arguments:
            なし
        Returns:
            作業実行inディレクトリパス
        """
        return self.lv_Ansible_in_Dir

    def setAnsible_child_playbooks_Dir(self, in_indir):
        """
        作業実行inディレクトリ配下のchild_playbooksディレクトリパスを記憶
        Arguments:
            in_dir:      inディレクトリのchild_playbooksディレクトリパス
        Returns:
            なし
        """
        self.lv_Ansible_child_playbooks_Dir = in_indir

    def getAnsible_child_playbooks_Dir(self):
        """
        作業実行inディレクトリ配下のchild_playbooksディレクトリパスを取得
        Arguments:
            なし
        Returns:
            作業実行inディレクトリ配下のchild_playbooksディレクトリパス
        """
        return self.lv_Ansible_child_playbooks_Dir

    def setPlaybook_child_playbooks_Dir(self, in_dir):
        """
        親PlayBook内の子PlayBookディレクトリ格納ディレクトリ名「child_playbooks」を記憶
        Arguments:
            in_dir:      child_playbooks
        Returns:
            なし
        """
        self.lv_Playbook_child_playbooks_Dir = in_dir

    def getPlaybook_child_playbooks_Dir(self):
        """
        親PlayBook内の子PlayBookディレクトリ格納ディレクトリ名「child_playbooks」を取得
        Arguments:
            なし
        Returns:
            child_playbooks
        """
        return self.lv_Playbook_child_playbooks_Dir

    def getPlaybook_child_playbook_file(self, in_pkey, in_file):
        """
        親PlayBook内の子PlayBookファイルパスを取得
        Arguments:
            in_pkey:    子playbookファイル Pkey
            in_file:    子playbookファイル
        Returns:
            child_playbooks
        """
        file = "{}/{}-{}".format(self.getPlaybook_child_playbooks_Dir(), in_pkey, in_file)
        return file

    def setAnsible_dialog_files_Dir(self, in_indir):
        """
        作業実行inディレクトリ配下のdialog_filesディレクトリパスを記憶
        Arguments:
            in_dir:  作業実行inディレクトリリ配下のdialog_filesディレクトリパス
        Returns:
            なし
        """
        self.lv_Ansible_dialog_files_Dir = in_indir

    def getAnsible_dialog_files_Dir(self):
        """
        作業実行inディレクトリ配下のdialog_filesディレクトリパスを取得
        Arguments:
            なし
        Returns:
            作業実行inディレクトリリ配下のdialog_filesディレクトリパス
        """
        return self.lv_Ansible_dialog_files_Dir

    def setAnsible_host_vars_Dir(self, in_indir):
        """
        作業実行inディレクトリ配下のhost_varsディレクトリパスを記憶
        Arguments:
            in_dir:  作業実行inディレクトリリ配下のhost_varsディレクトリパス
        Returns:
            なし
        """
        self.lv_Ansible_host_vars_Dir = in_indir

    def getAnsible_host_vars_Dir(self):
        """
        作業実行inディレクトリ配下のhost_varsディレクトリパスを取得
        Arguments:
            なし
        Returns:
            作業実行inディレクトリリ配下のhost_varsディレクトリパス
        """
        return self.lv_Ansible_host_vars_Dir

    def setAnsible_out_Dir(self, in_indir):
        """
        作業実行outディレクトリパスを記憶
        Arguments:
            in_dir: 作業実行outディレクトリパス
        Returns:
            なし
        """
        self.lv_Ansible_out_Dir = in_indir

    def getAnsible_out_Dir(self):
        """
        作業実行outディレクトリパスを記憶
        Arguments:
            なし
        Returns:
            作業実行outディレクトリパス
        """
        return self.lv_Ansible_out_Dir

    def setAnsible_tmp_Dir(self, in_indir):
        """
        作業実行tmpディレクトリパスを記憶
        Arguments:
            in_dir: 作業実行tmpディレクトリパス
        Returns:
            なし
        """
        self.lv_Ansible_tmp_Dir = in_indir

    def getAnsible_tmp_Dir(self):
        """
        作業実行tmpディレクトリパスを記憶
        Arguments:
            なし
        Returns:
            作業実行tmpディレクトリパス
        """
        return self.lv_Ansible_tmp_Dir

    def setAnsible_original_dialog_files_Dir(self, in_indir):
        """
        作業実行tmpディレクトリ配下のoriginal_dialog_filesディレクトリパスを記憶
        Arguments:
            in_dir: 作業実行tmpディレクトリ配下のoriginal_dialog_filesディレクトリパス
        Returns:
            なし
        """
        self.lv_Ansible_original_dialog_files_Dir = in_indir

    def getAnsible_original_dialog_files_Dir(self):
        """
        作業実行tmpディレクトリ配下のoriginal_dialog_filesディレクトリパスを取得
        Arguments:
            なし
        Returns:
            作業実行tmpディレクトリ配下のoriginal_dialog_filesディレクトリパス
        """
        return self.lv_Ansible_original_dialog_files_Dir

    def setAnsible_in_original_dialog_files_Dir(self, in_indir):
        """
        作業実行inディレクトリ配下のoriginal_dialog_filesディレクトリパスを記憶
        Arguments:
            in_dir: 作業実行inディレクトリ配下のoriginal_dialog_filesディレクトリパス
        Returns:
            なし
        """
        self.lv_Ansible_in_original_dialog_files_Dir = in_indir

    def getAnsible_in_original_dialog_files_Dir(self):
        """
        作業実行inディレクトリ配下のoriginal_dialog_filesディレクトリパスを取得
        Arguments:
            なし
        Returns:
            作業実行inディレクトリ配下のoriginal_dialog_filesディレクトリパス
        """
        return self.lv_Ansible_in_original_dialog_files_Dir

    def setAnsible_in_inventory_Dir(self, in_indir):
        """
        作業実行inディレクトリ配下のinventoryディレクトリパスを記憶
        Arguments:
            in_dir: 作業実行inディレクトリ配下のinventoryディレクトリパス
        Returns:
            なし
        """
        self.lv_Ansible_in_inventory_files_Dir = in_indir

    def getAnsible_in_inventory_Dir(self):
        """
        作業実行inディレクトリ配下のinventoryディレクトリパスを取得
        Arguments:
            なし
        Returns:
            作業実行inディレクトリ配下のinventoryディレクトリパス
        """
        return self.lv_Ansible_in_inventory_files_Dir

    def setAnsible_in_env_Dir(self, in_indir):
        """
        作業実行inディレクトリ配下のinventoryディレクトリパスを記憶
        Arguments:
            in_dir: 作業実行inディレクトリ配下のinventoryディレクトリパス
        Returns:
            なし
        """
        self.lv_Ansible_in_env_files_Dir = in_indir

    def getAnsible_in_env_Dir(self):
        """
        作業実行inディレクトリ配下のenvディレクトリパスを取得
        Arguments:
            なし
        Returns:
            作業実行inディレクトリ配下のenvディレクトリパス
        """
        return self.lv_Ansible_in_env_files_Dir

    def setAnsible_in_builder_files_Dir(self, in_indir):
        """
        作業実行inディレクトリ配下のbuilder_filesディレクトリパスを記憶
        Arguments:
            in_dir: 作業実行inディレクトリ配下のbuilder_filesディレクトリパス
        Returns:
            なし
        """
        self.lv_Ansible_in_builder_files_Dir = in_indir

    def getAnsible_in_builder_files_Dir(self):
        """
        作業実行inディレクトリ配下のbuilder_filesディレクトリパスを取得
        Arguments:
            なし
        Returns:
            作業実行inディレクトリ配下のbuilder_filesディレクトリパス
        """
        return self.lv_Ansible_in_builder_files_Dir

    def setAnsible_in_runner_files_Dir(self, in_indir):
        """
        作業実行inディレクトリ配下のrunner_filesディレクトリパスを記憶
        Arguments:
            in_dir: 作業実行inディレクトリ配下のbuilder_filesディレクトリパス
        Returns:
            なし
        """
        self.lv_Ansible_in_runner_files_Dir = in_indir

    def getAnsible_in_runner_files_Dir(self):
        """
        作業実行inディレクトリ配下のrunner_filesディレクトリパスを取得
        Arguments:
            なし
        Returns:
            作業実行inディレクトリ配下のrunner_filesディレクトリパス
        """
        return self.lv_Ansible_in_runner_files_Dir

    def setAnsible_original_hosts_vars_Dir(self, in_indir):
        """
        作業実行tmpディレクトリ配下のoriginal_hosts_varsディレクトリパスを記録
        Arguments:
            in_dir: 作業実行tmpディレクトリ配下のoriginal_hosts_varsディレクトリパス
        Returns:
            なし
        """
        self.lv_Ansible_original_hosts_vars_Dir = in_indir

    def getAnsible_original_hosts_vars_Dir(self):
        """
        作業実行tmpディレクトリ配下のoriginal_hosts_varsディレクトリパスを取得
        Arguments:
            なし
        Returns:
            作業実行tmpディレクトリ配下のoriginal_hosts_varsディレクトリパス
        """
        return self.lv_Ansible_original_hosts_vars_Dir

    def setAnsible_vault_hosts_vars_Dir(self, in_indir):
        """
        作業実行tmpディレクトリ配下のvault_host_varsディレクトリパスを記録
        暗号化された変数のみのホスト変数ファイル
        Arguments:
            in_dir: 作業実行tmpディレクトリ配下のvault_host_varsディレクトリパス
        Returns:
            なし
        """
        self.lv_Ansible_vault_hosts_vars_Dir = in_indir

    def getAnsible_vault_hosts_vars_Dir(self):
        """
        作業実行tmpディレクトリ配下のvault_host_varsディレクトリパスを取得
        暗号化された変数のみのホスト変数ファイル
        Arguments:
            なし
        Returns:
            作業実行tmpディレクトリ配下のvault_host_varsディレクトリパス
        """
        return self.lv_Ansible_vault_hosts_vars_Dir

    def setAnsible_pioneer_template_hosts_vars_Dir(self, in_indir):
        """
        作業実行tmpディレクトリ配下のpioneer template用 host_varsディレクトリパスを記録
        暗号化された変数のみのホスト変数ファイル
        Arguments:
            in_dir:  作業実行tmpディレクトリ配下のpioneer template用 host_varsディレクトリパス
        Returns:
            なし
        """
        self.lv_Ansible_pioneer_template_hosts_vars_Dir = in_indir

    def getAnsible_pioneer_template_hosts_vars_Dir(self):
        """
        作業実行tmpディレクトリ配下のpioneer template用 host_varsディレクトリパスを取得
        暗号化された変数のみのホスト変数ファイル
        Arguments:
            なし
        Returns:
            作業実行tmpディレクトリ配下のpioneer template用 host_varsディレクトリパス
        """
        return self.lv_Ansible_pioneer_template_hosts_vars_Dir

    # lv_ita_dialog_files_Dirと同様、util.pyにfunctionを用意する
    def getAnsible_hosts_file(self):
        """
        作業実行hostsファイル名を取得
        Arguments:
            なし
        Returns:
            作業実行hostsファイル名
        """
        if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG: # enomomto AGの場合を追加
            file = "{}/{}/{}".format(self.getAnsible_in_Dir(), self.LC_ANS_INVENTORY_DIR, self.LC_ANS_HOSTS_FILE)
        else:
            file = self.getAnsible_in_Dir() + "/" + self.LC_ANS_HOSTS_FILE
        return file

    def getAnsible_playbook_file(self):
        """
        playbookファイル名を取得
        Arguments:
            なし
        Returns:
            playbookファイル名
        """
        file = self.getAnsible_in_Dir() + "/" + self.LC_ANS_PLAYBOOK_FILE
        return file

    def getAnsible_pioneer_template_host_var_file(self, in_hostname):
        """
        作業実行tmpディレクトリ配下のpioneer template用 host_vars/host毎のディレクトリを取得
        Arguments:
            in_hostname: ホスト名
        Returns:
            作業実行tmpディレクトリ配下のpioneer template用 host_vars/host毎のディレクトリ
        """
        file = "{}/{}".format(self.getAnsible_pioneer_template_hosts_vars_Dir(), in_hostname)
        return file

    def getAnsible_host_var_file(self, in_hostname):
        """
        作業実行inディレクトリ配下のhost_vars/host毎ディレクトリパスを取得
        Arguments:
            in_hostname: ホスト名
        Returns:
            作業実行inディレクトリ配下のhost_vars/host毎ディレクトリパス
        """
        file = "{}/{}".format(self.getAnsible_host_vars_Dir(), in_hostname)
        return file

    def getAnsible_org_host_var_file(self, in_hostname):
        """
        作業実行tmpディレクトリ配下のoriginal_hosts_vars/host毎ディレクトリパスを取得
        Arguments:
            in_hostname: ホスト名
        Returns:
            作業実行tmpディレクトリ配下のoriginal_hosts_vars/host毎ディレクトリパス
        """
        file = "{}/{}".format(self.getAnsible_original_hosts_vars_Dir(), in_hostname)
        return file

    def getAnsible_org_dialog_file(self, in_hostname, in_pkey, in_filename):
        """
        加工前の対話ファイル名(Pioneer)を取得
        Arguments:
            in_hostname:       ホスト名(IPアドレス)
            in_pkey:           対話ファイル Pkey
            in_filename:       対話ファイル名
        Returns:
            加工前の対話ファイルパス(Pioneer)を取得
        """
        # Ansible実行時の対話ファイル名は Pkey(10桁)-対話ファイル名 する。
        file = "{}/{}/{}-{}".format(self.getAnsible_original_dialog_files_Dir(), in_hostname, in_pkey, in_filename)
        return file

    def LocalLogPrint(self, file, line, errorMsg, file_dir=""):
        """
        作業実行のエラーログ枠に紐づくファイル「作業実行/out/error.log」
        にエラーログを出力する。
        「「作業実行/out」ディレクトリが無い場合は標準出力にエラーログを出力する。
        Arguments:
            file: ファイル名
            line: 行番号
            errorMsg: エラーログ
        Returns:
            なし
        """
        logmsg = "File[{}:{}]{}".format(file, line, errorMsg)
        # エラーログファイルのパスが生成されている場合エラーログファイルにログ出力
        if not self.getAnsible_out_Dir():
            logfile = file_dir + "/" + "error.log"
        else:
            logfile = self.getAnsible_out_Dir() + "/" + "error.log"
        # #2079 /storage配下は/tmpを経由してアクセスする
        obj = storage_write()
        obj.open(logfile, "a")
        obj.write(errorMsg + "\n")
        obj.close()
        g.applogger.debug(logmsg)

    def getDBHostList(self, in_execute_no, in_pattern_id, in_operation_id, mt_hostlist, mt_hostostypelist, mt_hostinfolist, in_winrm_id):
        """
        Ansible実行の対象機器情報をデータベースより取得する。
        Arguments:
            in_execute_no:      作業番号
            in_pattern_id:      作業パターンID
            in_operation_id:    オペレーションID
            mt_hostlist:        ホスト一覧
                                {機器一覧:SYSTEM_ID: 機器一覧:HOST_NAME},,
            mt_hostostypelist:  ホスト毎OS種別一覧  Pioneerの場合のみ
                                {機器一覧:HOST_NAME': 機器一覧:OS_TYPE_ID'}
            mt_hostinfolist:    {機器一覧:'HOST_NAME' {機器一覧:各項目: 値},,,},,,
            in_winrm_id:        Movement一覧のwinrm接続の設定値
                                "1": winrm接続選択
        Returns:
            True/False, mt_hostlist, mt_hostostypelist, mt_hostinfolist
        """
        mt_hostlist = {}
        mt_hostostypelist = {}
        mt_hostinfolist = {}

        # Movement一覧よりホスト指定形式を取得
        sql = "SELECT ANS_HOST_DESIGNATE_TYPE_ID  FROM {} WHERE MOVEMENT_ID=%s AND DISUSE_FLAG='0'".format(self.AnscObj.vg_ansible_pattern_listDB)
        rows = self.lv_objDBCA.sql_execute(sql, [in_pattern_id])
        if len(rows) == 0:
            #
            msgstr = g.appmsg.get_api_message("MSG-10382", [])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, mt_hostlist, mt_hostostypelist, mt_hostinfolist
        for row in rows:
            HostDesignateTypeId = row['ANS_HOST_DESIGNATE_TYPE_ID']

        # 機器一覧に対するDISUSE_FLAG = '0'の条件はSELECT文に入れない。
        sql = """
            SELECT
                TBL_1.PHO_LINK_ID,
                TBL_1.SYSTEM_ID AS PHO_HOST_ID,
                TBL_2.*,
                (
                SELECT
                    TBL_3.PROTOCOL_NAME
                FROM
                    T_ANSC_PIONEER_PROTOCOL_TYPE TBL_3
                WHERE
                    TBL_3.PROTOCOL_ID = TBL_2.PROTOCOL_ID AND
                    TBL_3.DISUSE_FLAG = '0'
                ) AS PROTOCOL_NAME
            FROM
                (
                SELECT
                    TBL_4.PHO_LINK_ID,
                    TBL_4.SYSTEM_ID
                FROM
                    {} TBL_4
                WHERE
                    TBL_4.EXECUTION_NO      = %s AND
                    TBL_4.DISUSE_FLAG       = '0'
                ) TBL_1
            LEFT OUTER JOIN T_ANSC_DEVICE TBL_2 ON ( TBL_1.SYSTEM_ID = TBL_2.SYSTEM_ID )
            ORDER BY TBL_2.HOST_NAME
            """.format(self.AnscObj.vg_ansible_pho_linkDB)

        rows = self.lv_objDBCA.sql_execute(sql, [in_execute_no])

        for row in rows:
            if row['DISUSE_FLAG'] == '0':
                mt_hostlist[row['SYSTEM_ID']] = {}
                mt_hostostypelist[row['HOST_NAME']] = {}
                mt_hostinfolist[row['HOST_NAME']] = {}

                # 認証方式の設定値確認
                login_auth_type = row['LOGIN_AUTH_TYPE']
                if self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_DRIVER_ID or\
                   self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_ROLE_DRIVER_ID:
                    # Movement一覧でwinrm接続が選択されている場合
                    # 機器一覧の認証方式がパスワード認証(winrm)以外か判定
                    if in_winrm_id == "1" and login_auth_type not in (self.AnscObj.DF_LOGIN_AUTH_TYPE_PW_WINRM, self.AnscObj.DF_LOGIN_AUTH_TYPE_KEY_WINRM):
                        #
                        msgstr = g.appmsg.get_api_message("MSG-10207", [row['HOST_NAME']])
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        return False, mt_hostlist, mt_hostostypelist, mt_hostinfolist

                    # Movement一覧でwinrm接続が選択されていない場合
                    # 機器一覧の認証方式がパスワード認証(winrm)か判定
                    if in_winrm_id != "1" and login_auth_type == self.AnscObj.DF_LOGIN_AUTH_TYPE_PW_WINRM:
                        #
                        msgstr = g.appmsg.get_api_message("MSG-10208", [row['HOST_NAME']])
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        return False, mt_hostlist, mt_hostostypelist, mt_hostinfolist

                if HostDesignateTypeId == "1":
                    # ホスト指定形式がIPの場合、機器一覧のIPアドレスが設定されているか判定
                    if not row['IP_ADDRESS']:
                        #
                        msgstr = g.appmsg.get_api_message("MSG-10690", [row['SYSTEM_ID']])
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        return False, mt_hostlist, mt_hostostypelist, mt_hostinfolist
                else:
                    # ホスト指定形式がホストの場合、機器一覧のDNSホストが設定されているか判定
                    if not row['HOST_DNS_NAME']:
                        #
                        msgstr = g.appmsg.get_api_message("MSG-10691", [row['SYSTEM_ID']])
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        return False, mt_hostlist, mt_hostostypelist, mt_hostinfolist

                # パスワード管理ありでパスワード退避
                if row['LOGIN_PW']:
                    # パスワード退避
                    row['LOGIN_PW'] = ky_decrypt(row['LOGIN_PW'])
                else:
                    # パスワード未設定を退避
                    row['LOGIN_PW'] = self.LC_ANS_UNDEFINE_NAME
                if row['SSH_KEY_FILE_PASSPHRASE']:
                    row['SSH_KEY_FILE_PASSPHRASE'] = ky_decrypt(row['SSH_KEY_FILE_PASSPHRASE'])

                if self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_DRIVER_ID or\
                   self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_ROLE_DRIVER_ID:
                    if not row['PROTOCOL_NAME']:
                        row['PROTOCOL_ID'] = self.LC_ANS_UNDEFINE_NAME
                    else:
                        row['PROTOCOL_ID'] = row['PROTOCOL_NAME']
                else:
                    row['PROTOCOL_ID'] = row['PROTOCOL_NAME']

                    # OS種別未入力判定
                    if not row['OS_TYPE_ID']:
                        #
                        msgstr = g.appmsg.get_api_message("MSG-10197", [row['SYSTEM_ID']])
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        return False, mt_hostlist, mt_hostostypelist, mt_hostinfolist

                    # IPアドレス, OS種別の配列作成 pioneerの場合のみ作成
                    mt_hostostypelist[row['HOST_NAME']] = row['OS_TYPE_ID']

                # Pioneer LNAG のIDを文字コードに置換する
                if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                    #
                    if not row['PIONEER_LANG_ID']:
                        row['PIONEER_LANG_ID'] = "1"
                    lang_id2lang_str = {}
                    lang_id2lang_str["1"] = 'utf-8'
                    lang_id2lang_str["2"] = 'shift_jis'
                    lang_id2lang_str["3"] = 'euc_jp'
                    if row['PIONEER_LANG_ID'] in lang_id2lang_str:
                        row['PIONEER_LANG_STRING'] = lang_id2lang_str[row['PIONEER_LANG_ID']]
                    else:
                        msgstr = g.appmsg.get_api_message("MSG-10209", [row['HOST_NAME']])
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        return False, mt_hostlist, mt_hostostypelist, mt_hostinfolist
                # 接続タイプが選択されていることを確認
                if not row['CREDENTIAL_TYPE_ID']:
                    #
                    msgstr = g.appmsg.get_api_message("MSG-10295", [row['HOST_NAME']])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    return False, mt_hostlist, mt_hostostypelist, mt_hostinfolist

                # ホスト名の配列作成
                mt_hostlist[row['SYSTEM_ID']] = row['HOST_NAME']

                # WINRM接続プロトコル配列作成
                if not row['WINRM_PORT']:
                    # WINRM接続プロトコルが空白の場合はデフォルト値を設定
                    row['WINRM_PORT'] = self.LC_WINRM_PORT

                mt_hostinfolist[row['HOST_NAME']] = row

            # 作業対象ホスト管理に登録されているホストが機器一覧に未登録
            else:
                #
                msgstr = g.appmsg.get_api_message("MSG-10183", [row['PHO_LINK_ID'], row['SYSTEM_ID']])
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)
                return False, mt_hostlist, mt_hostostypelist, mt_hostinfolist

        if len(rows) < 1:
            #
            msgstr = g.appmsg.get_api_message("MSG-10184", [in_pattern_id])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, mt_hostlist, mt_hostostypelist, mt_hostinfolist

        if len(mt_hostlist) < 1:
            #
            msgstr = g.appmsg.get_api_message("MSG-10185", [in_pattern_id])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, mt_hostlist, mt_hostostypelist, mt_hostinfolist

        return True, mt_hostlist, mt_hostostypelist, mt_hostinfolist

    def getDBRoleVarList(self, in_execute_no, in_pattern_id, in_operation_id, mt_host_vars, mt_MultiArray_vars_list, mt_All_vars_list):
        """
        ansibleで実行する変数をデータベースより取得する。(Role)
        Arguments:
            in_execute_no:           作業実行番号
            in_pattern_id:           MovementID
            in_operation_id:         オペレーションID
            mt_host_vars:            多段変数以外の変数リスト
            mt_MultiArray_vars_list: 多段変数リスト
            mt_All_vars_list:        未使用(I/Fを合わせる為に残す)
        Returns:
            bool, mt_host_vars, mt_MultiArray_vars_list, mt_All_vars_list
        """
        vars_assign_seq_list = {}
        # unuse child_vars_list = {}
        varerror_flg = True
        # B_ANSIBLE_LNS_PATTERN_VARS_LINKに対するDISUSE_FLAG = '0'の
        # 条件はSELECT文に入れない。
        sql = """
            SELECT
                TBL.*
            FROM
            (
            SELECT
                TBL_1.ASSIGN_ID,
                TBL_1.SYSTEM_ID,
                TBL_1.VARS_ENTRY,
                TBL_1.VARS_ENTRY_FILE,
                TBL_1.SENSITIVE_FLAG,
                TBL_1.ASSIGN_SEQ,
                TBL_2.VARS_NAME,
                TBL_2.VARS_ATTRIBUTE_01,
                TBL_1.COL_SEQ_COMBINATION_ID,
                TBL_3.COL_COMBINATION_MEMBER_ALIAS,
                TBL_4.ARRAY_MEMBER_ID,
                TBL_4.PARENT_VARS_KEY_ID,
                TBL_4.VARS_KEY_ID,
                TBL_4.VARS_NAME AS MEMBER_VARS_NAME,
                TBL_4.ARRAY_NEST_LEVEL,
                TBL_4.ASSIGN_SEQ_NEED,
                TBL_4.COL_SEQ_NEED,
                TBL_4.MEMBER_DISP,
                TBL_4.MAX_COL_SEQ,
                TBL_4.VRAS_NAME_PATH,
                TBL_4.VRAS_NAME_ALIAS,
                TBL_2.DISUSE_FLAG   AS PTN_VARS_LINK_DISUSE_FLAG,
                TBL_3.DISUSE_FLAG   AS MEMBER_COL_COMB_DISUSE_FLAG,
                TBL_4.DISUSE_FLAG   AS ARRAY_MEMBER_DISUSE_FLAG,
                (
                SELECT
                    COUNT(*)
                FROM
                    T_ANSR_TGT_HOST TBL_4
                WHERE
                    TBL_4.EXECUTION_NO      = %s                 AND
                    TBL_4.OPERATION_ID      = %s                 AND
                    TBL_4.MOVEMENT_ID       = %s                 AND
                    TBL_4.SYSTEM_ID         = TBL_1.SYSTEM_ID    AND
                    TBL_4.DISUSE_FLAG       = '0'
                ) AS PHO_LINK_HOST_COUNT,
                (
                SELECT
                    TBL_3.HOST_NAME
                FROM
                    T_ANSC_DEVICE TBL_3
                WHERE
                    TBL_3.SYSTEM_ID   = TBL_1.SYSTEM_ID          AND
                    TBL_3.DISUSE_FLAG = '0'
                ) AS HOST_NAME
            FROM
                (
                SELECT
                    TBL.ASSIGN_ID,
                    TBL.EXECUTION_NO,
                    TBL.SYSTEM_ID,
                    TBL.MVMT_VAR_LINK_ID,
                    TBL.COL_SEQ_COMBINATION_ID,
                    TBL.VARS_ENTRY,
                    TBL.VARS_ENTRY_FILE,
                    TBL.SENSITIVE_FLAG,
                    TBL.ASSIGN_SEQ
                FROM
                    T_ANSR_VALUE TBL
                WHERE
                    TBL.EXECUTION_NO = %s AND
                    TBL.OPERATION_ID = %s AND
                    TBL.MOVEMENT_ID  = %s AND
                    TBL.DISUSE_FLAG  = '0'
                ) TBL_1
            LEFT OUTER JOIN T_ANSR_MVMT_VAR_LINK            TBL_2 ON ( TBL_1.MVMT_VAR_LINK_ID       =
                                                                       TBL_2.MVMT_VAR_LINK_ID )
            LEFT OUTER JOIN T_ANSR_NESTVAR_MEMBER_COL_COMB  TBL_3 ON ( TBL_1.COL_SEQ_COMBINATION_ID =
                                                                       TBL_3.COL_SEQ_COMBINATION_ID )
            LEFT OUTER JOIN T_ANSR_NESTVAR_MEMBER           TBL_4 ON ( TBL_3.ARRAY_MEMBER_ID        =
                                                                       TBL_4.ARRAY_MEMBER_ID )
            ) TBL
            ORDER BY HOST_NAME, VARS_NAME, ARRAY_NEST_LEVEL, VARS_KEY_ID, ASSIGN_SEQ

            """

        rows = self.lv_objDBCA.sql_execute(sql, [in_execute_no,
                                                 in_operation_id,
                                                 in_pattern_id,
                                                 in_execute_no,
                                                 in_operation_id,
                                                 in_pattern_id])

        mt_host_vars = {}
        tgt_row = []
        array_tgt_row = []

        # ary = {}
        # ary = {'VARS_ENTRY_FILE': None,
        #       'ASSIGN_SEQ': 1,
        #       'ASSIGN_ID': 'ASSIGN_ID01',
        #       'PTN_VARS_LINK_DISUSE_FLAG': '0',
        #       'PHO_LINK_HOST_COUNT': 1,
        #       'VARS_ATTRIBUTE_01': '2',
        #       'VARS_NAME': 'ttttt',
        #       'SENSITIVE_FLAG': '0',
        #       'VARS_ENTRY': 'aaa',
        #       'HOST_NAME': 'SYSTEM01'}
        # rows = []
        # rows.append(ary)
        for row in rows:
            ret = self.setFileUploadCloumnFileEnv(row)
            if ret is not True:
                return False, mt_host_vars, mt_MultiArray_vars_list, mt_All_vars_list

            #  具体値の暗号化が必要な場合で具体値が空の場合
            if row['SENSITIVE_FLAG'] == self.AnscObj.DF_SENSITIVE_ON:
                #  暗号化の処理をパスするようにしたいので、具体値を""に設定し暗号化不要に設定
                if not row['VARS_ENTRY']:
                    row['VARS_ENTRY'] = ""
                    row['SENSITIVE_FLAG'] = self.AnscObj.DF_SENSITIVE_OFF
            else:
                if not row['VARS_ENTRY']:
                    row['VARS_ENTRY'] = ""

            if row['VARS_ATTRIBUTE_01'] == self.LC_VARS_ATTR_STRUCT:
                array_tgt_row.append(row)
            else:
                tgt_row.append(row)
        for row in tgt_row:
            assign_seq = True
            if not row['ASSIGN_SEQ']:
                assign_seq = False

            if row['PTN_VARS_LINK_DISUSE_FLAG'] == '0':
                # 作業対象ホストになくて代入値管理のみあるホスト変数をはじく
                if row['PHO_LINK_HOST_COUNT'] == 0:
                    continue

                # 代入値管理のみあるホスト変数(作業対象ホストにない)をはじく
                if row['PHO_LINK_HOST_COUNT'] > 0:
                    # 不要なチェック処理
                    # 多次元変数以外か判定
                    # if row['VARS_ATTRIBUTE_01'] == self.LC_VARS_ATTR_STRUCT:
                    #     if row['MEMBER_COL_COMB_DISUSE_FLAG'] != '0':
                    #         #
                    #         msgstr = g.appmsg.get_api_message("MSG-10452", [row['ASSIGN_ID']])
                    #         self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                    #                            str(inspect.currentframe().f_lineno), msgstr)
                    #         return False, mt_host_vars, mt_MultiArray_vars_list, mt_All_vars_list
                    #
                    #     if row['ARRAY_MEMBER_DISUSE_FLAG'] != '0':
                    #         #
                    #         msgstr = g.appmsg.get_api_message("MSG-10453", [row['ASSIGN_ID']])
                    #         self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                    #         str(inspect.currentframe().f_lineno), msgstr)
                    #         return False, mt_host_vars, mt_MultiArray_vars_list, mt_All_vars_list

                    if row['VARS_ATTRIBUTE_01'] == self.LC_VARS_ATTR_LIST:
                        # 配列変数以外で代入順序がnullの場合はエラーにする。
                        if assign_seq is False:
                            #
                            msgstr = g.appmsg.get_api_message("MSG-10416", [row['ASSIGN_ID'], row['VARS_NAME']])
                            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                               str(inspect.currentframe().f_lineno), msgstr)
                            return False, mt_host_vars, mt_MultiArray_vars_list, mt_All_vars_list

                    if row['VARS_ATTRIBUTE_01'] == self.LC_VARS_ATTR_STD:
                        # 代入順序がnull以外の場合はエラーにする。
                        if assign_seq is True:
                            #
                            msgstr = g.appmsg.get_api_message("MSG-10442", [row['ASSIGN_ID'], row['VARS_NAME']])
                            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                               str(inspect.currentframe().f_lineno), msgstr)
                            return False, mt_host_vars, mt_MultiArray_vars_list, mt_All_vars_list

                    # 多次元変数以外か判定
                    if row['VARS_ATTRIBUTE_01'] != self.LC_VARS_ATTR_STRUCT:
                        # 配列変数以外で代入順序が重複していないか判定する。
                        keyStr = "{}_{}_{}".format(row['HOST_NAME'], row['VARS_NAME'], row['ASSIGN_SEQ'])
                        if keyStr in vars_assign_seq_list:
                            #
                            msgstr = g.appmsg.get_api_message("MSG-10417", [row['ASSIGN_ID'],
                                                                            vars_assign_seq_list[keyStr],
                                                                            row['VARS_NAME'],
                                                                            row['ASSIGN_SEQ']])
                            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                               str(inspect.currentframe().f_lineno), msgstr)
                            return False, mt_host_vars, mt_MultiArray_vars_list, mt_All_vars_list
                        else:
                            # 配列変数以外で代入順序の重複チェックリスト作成
                            vars_assign_seq_list[keyStr] = row['ASSIGN_ID']

                        # 具体値の暗号化が必要か判定
                        if row['SENSITIVE_FLAG'] == self.AnscObj.DF_SENSITIVE_ON:
                            indento_sp = ""
                            valut_value = ""
                            value = ky_decrypt(row['VARS_ENTRY'])
                            make_vaultvalue = self.makeAnsibleVaultValue(value, valut_value, indento_sp, row['ASSIGN_ID'])
                            if make_vaultvalue is False:
                                return False, mt_host_vars, mt_MultiArray_vars_list, mt_All_vars_list

                            # 具体値を暗号化した具体値で上書き
                            row['VARS_ENTRY'] = make_vaultvalue
                        else:
                            # 複数行具体値の場合に複数行の扱い記号を付ける
                            row['VARS_ENTRY'] = self.makeMultilineValue(row['VARS_ENTRY'])

                        if row['VARS_ATTRIBUTE_01'] == self.LC_VARS_ATTR_STD:
                            # ホスト変数配列作成
                            if row['HOST_NAME'] not in mt_host_vars:
                                mt_host_vars[row['HOST_NAME']] = {}
                            mt_host_vars[row['HOST_NAME']][row['VARS_NAME']] = row['VARS_ENTRY']
                        else:
                            if row['HOST_NAME'] not in mt_host_vars:
                                mt_host_vars[row['HOST_NAME']] = {}
                            if row['VARS_NAME'] not in mt_host_vars[row['HOST_NAME']]:
                                mt_host_vars[row['HOST_NAME']][row['VARS_NAME']] = ""
                            # 複数行具体値をjson形式で収める retAry[0]は見る必要はない

                            retAry = self.ArrayTypeValue_encode(mt_host_vars[row['HOST_NAME']][row['VARS_NAME']], row['VARS_ENTRY'])
                            mt_host_vars[row['HOST_NAME']][row['VARS_NAME']] = retAry[1]

            elif row['PTN_VARS_LINK_DISUSE_FLAG']:
                #
                msgstr = g.appmsg.get_api_message("MSG-10187", [row['ASSIGN_ID']])
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)
                return False, mt_host_vars, mt_MultiArray_vars_list, mt_All_vars_list

            # DISUSE_FLAG = '1'は読み飛ばし

        if varerror_flg is True:
            retAry = self.getDBVarMultiArrayVarsList(array_tgt_row, mt_MultiArray_vars_list)
            varerror_flg = retAry[0]
            mt_MultiArray_vars_list = retAry[1]

        return varerror_flg, mt_host_vars, mt_MultiArray_vars_list, mt_All_vars_list

    def MultiArrayVarsToYamlFormatMain(self,
                                       ina_MultiArray_vars_list,
                                       mt_str_hostvars,
                                       mt_parent_vars_list,
                                       in_host_name,
                                       mt_legacy_Role_cpf_vars_list,
                                       mt_legacy_Role_tpf_vars_list):
        """
        多段変数の具体値をホスト変数ファイル出力用文字列生成
        Arguments:
            ina_MultiArray_vars_list:      多段変数の具体値リスト
            mt_str_hostvars:               ホスト変数ファイルに出力する文字列
            mt_parent_vars_list:           親変数名リスト
            in_host_name,                  ホスト名
            mt_legacy_Role_cpf_vars_list   ファイル管理変数リスト
            mt_legacy_Role_tpf_vars_list   テンプレート理変数リスト
        Returns:
            True/False, mt_str_hostvars, mt_parent_vars_list, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list
        """
        mt_parent_vars_list = {}

        mt_str_hostvars = ""

        for parent_vars_name, parent_vars_list in ina_MultiArray_vars_list.items():
            # 該当ホストの多段変数が未登録か判定
            if in_host_name not in parent_vars_list:
                continue

            host_vars_array = parent_vars_list[in_host_name]
            mt_parent_vars_list[parent_vars_name] = 1
            cur_str_hostvars = parent_vars_name + ":" + "\n"
            error_code = ""
            line = ""
            before_vars = ""
            indent = ""
            nest_level = 1
            # 多次元配列の具体値構造体から。ホスト変数定義を生成する。
            retAry = self.MultiArrayVarsToYamlFormatSub(host_vars_array,
                                                        cur_str_hostvars,
                                                        before_vars,
                                                        indent,
                                                        nest_level,
                                                        error_code,
                                                        line,
                                                        mt_legacy_Role_cpf_vars_list,
                                                        mt_legacy_Role_tpf_vars_list)
            ret = retAry[0]
            cur_str_hostvars = retAry[1]
            error_code = retAry[2]
            line = retAry[3]
            mt_legacy_Role_cpf_vars_list = retAry[4]
            mt_legacy_Role_tpf_vars_list = retAry[5]

            if ret is False:
                # エラーメッセージを直接出力している場合あり
                if error_code == "":
                    return False, mt_str_hostvars, mt_parent_vars_list, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list

                msgstr = g.appmsg.get_api_message(error_code, [parent_vars_name])
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)
                return False, mt_str_hostvars, mt_parent_vars_list, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list

            mt_str_hostvars += cur_str_hostvars

        return True, mt_str_hostvars, mt_parent_vars_list, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list

    def getDBVarMultiArrayVarsList(self, in_tgt_row, mt_MultiArray_vars_list):
        """
        ansibleで実行する多段変数をデータベースより取得する。(Role)
        Arguments:
            in_tgt_row:              データベースに登録されている多次元変数情報
            mt_MultiArray_vars_list: 多段変数リスト
        Returns:
            bool, mt_MultiArray_vars_list
        """
        vars_seq_list = {}

        for row in in_tgt_row:
            # 具体値の暗号化が必要か判定
            if row['SENSITIVE_FLAG'] == self.AnscObj.DF_SENSITIVE_ON:
                indento_sp = ""
                valut_value = ""
                value = ky_decrypt(row['VARS_ENTRY'])
                make_vaultvalue = self.makeAnsibleVaultValue(value, valut_value, indento_sp, row['ASSIGN_ID'])
                if make_vaultvalue is False:
                    return False, mt_MultiArray_vars_list

                # 具体値を暗号化した具体値で上書き
                row['VARS_ENTRY'] = make_vaultvalue
            else:
                # 複数行具体値の場合に複数行の扱い記号を付ける
                row['VARS_ENTRY'] = self.makeMultilineValue(row['VARS_ENTRY'])

            # 多段メンバー変数の廃止レコードを判定
            if row['MEMBER_COL_COMB_DISUSE_FLAG'] != '0':
                continue

            if row['PTN_VARS_LINK_DISUSE_FLAG'] == '0':
                # 代入値管理のみあるホスト変数(作業対象ホストにない)をはじく
                if row['PHO_LINK_HOST_COUNT'] == 0:
                    continue

                if not row['VARS_NAME']:
                    msgstr = g.appmsg.get_api_message("MSG-10188", [row['ASSIGN_ID']])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    return False, mt_MultiArray_vars_list

                if row['ASSIGN_SEQ_NEED'] == '0' and row['ASSIGN_SEQ']:
                    msgstr = g.appmsg.get_api_message("MSG-10442", [row['ASSIGN_ID'], row['COL_COMBINATION_MEMBER_ALIAS']])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    return False, mt_MultiArray_vars_list

                if row['ASSIGN_SEQ_NEED'] == '1' and not row['ASSIGN_SEQ']:
                    msgstr = g.appmsg.get_api_message("MSG-10416", [row['ASSIGN_ID'], row['COL_COMBINATION_MEMBER_ALIAS']])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    return False, mt_MultiArray_vars_list

                # 各変数の代入順序と説順序が重複していないか判定する。
                dup_key = 0

                keyStr = "{}_{}_{}_{}".format(row['HOST_NAME'], row['VARS_NAME'], row['COL_SEQ_COMBINATION_ID'], row['ASSIGN_SEQ'])
                if keyStr not in vars_seq_list:
                    # 各変数の代入順序と説順序が重複リスト生成
                    vars_seq_list[keyStr] = row['ASSIGN_SEQ']
                else:
                    dup_key = vars_seq_list[keyStr]

                if dup_key != 0:
                    msgstr = g.appmsg.get_api_message("MSG-10443", [row['ASSIGN_ID'], dup_key, row['COL_COMBINATION_MEMBER_ALIAS']])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    return False, mt_MultiArray_vars_list

                if row['VARS_NAME'] not in mt_MultiArray_vars_list:
                    mt_MultiArray_vars_list[row['VARS_NAME']] = {}
                if row['HOST_NAME'] not in mt_MultiArray_vars_list[row['VARS_NAME']]:
                    mt_MultiArray_vars_list[row['VARS_NAME']][row['HOST_NAME']] = {}

                if not row['ASSIGN_SEQ']:
                    var_type = AnscConst.GC_VARS_ATTR_STD
                else:
                    var_type = AnscConst.GC_VARS_ATTR_LIST

                var_path_array = []
                # 多次元配列のメンバー変数へのパス配列を生成
                retAry = self.makeHostVarsPath(row['COL_COMBINATION_MEMBER_ALIAS'], var_path_array)
                var_path_array = retAry

                # Noneを空白に設定 host_varsにNoneと出力される為
                if not row['VARS_ENTRY']:
                    row['VARS_ENTRY'] = ""
                # 多次元配列の具体値情報をホスト変数ファイルに戻す為の辞書作成
                src_dict = mt_MultiArray_vars_list[row['VARS_NAME']][row['HOST_NAME']]

                add_dict = self.makeHostVarsArray(var_path_array,
                                                  0,
                                                  mt_MultiArray_vars_list[row['VARS_NAME']][row['HOST_NAME']],
                                                  var_type, row['VARS_ENTRY'],
                                                  row['ASSIGN_SEQ'])
                # 辞書をマージ
                merge_dict = deepmerge(src_dict, add_dict)
                mt_MultiArray_vars_list[row['VARS_NAME']][row['HOST_NAME']] = merge_dict
                # mt_MultiArray_vars_list[row['VARS_NAME']][row['HOST_NAME']] = ret
            elif row['PTN_VARS_LINK_DISUSE_FLAG']:
                msgstr = g.appmsg.get_api_message("MSG-10187", [row['ASSIGN_ID']])
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)
                return False, mt_MultiArray_vars_list
            else:
                # DISUSE_FLAG = '1'は読み飛ばし
                continue
        return True, mt_MultiArray_vars_list

    def addSystemvars(self, mt_host_vars, ina_hostinfolist, execution_no, movement_id):
        """
        ITA独自変数を設定する
        Arguments:
            mt_host_vars: ホスト変数一覧
            hostinfolist: 機器一覧
            execution_no: 作業番号
            movement_id:  MovementID
        Returns:
            mt_host_vars
        """
        for host_name, hostinfo in ina_hostinfolist.items():
            if host_name not in mt_host_vars:
                mt_host_vars[host_name] = {}

            mt_host_vars[host_name][self.AnscObj.ITA_SP_VAR_ANS_PROTOCOL_VAR_NAME] = hostinfo['PROTOCOL_ID']

            mt_host_vars[host_name][self.AnscObj.ITA_SP_VAR_ANS_USERNAME_VAR_NAME] = hostinfo['LOGIN_USER']

            if hostinfo['LOGIN_PW'] != self.LC_ANS_UNDEFINE_NAME:
                mt_host_vars[host_name][self.AnscObj.ITA_SP_VAR_ANS_PASSWD_VAR_NAME] = hostinfo['LOGIN_PW']

            mt_host_vars[host_name][self.AnscObj.ITA_SP_VAR_ANS_INVENTORYHOST_VAR_NAME] = host_name

            if hostinfo['HOST_DNS_NAME']:
                mt_host_vars[host_name][self.AnscObj.ITA_SP_VAR_ANS_DNSHOSTNAME_VAR_NAME] = hostinfo['HOST_DNS_NAME']
            else:
                mt_host_vars[host_name][self.AnscObj.ITA_SP_VAR_ANS_DNSHOSTNAME_VAR_NAME] = self.LC_ANS_UNDEFINE_NAME
            if hostinfo['IP_ADDRESS']:
                mt_host_vars[host_name][self.AnscObj.ITA_SP_VAR_ANS_IPADDRESS_VAR_NAME] = hostinfo['IP_ADDRESS']
            else:
                mt_host_vars[host_name][self.AnscObj.ITA_SP_VAR_ANS_IPADDRESS_VAR_NAME] = self.LC_ANS_UNDEFINE_NAME

            # 実行エンジンがAnsible Agentの場合、__workflowdir__と__conductor_workflowdir__のパスを変更
            if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG:
                if self.lv_conductor_instance_no:
                    mt_host_vars[host_name][self.AnscObj.ITA_SP_VAR_ANS_OUTDIR_VAR_NAME] = "{}/{}".format("/outdir/out", os.path.basename(self.lv_user_out_Dir))
                    mt_host_vars[host_name][self.AnscObj.ITA_SP_VAR_CONDUCTO_DIR_VAR_NAME] = "{}".format("/outdir/conductor")
                else:
                    mt_host_vars[host_name][self.AnscObj.ITA_SP_VAR_ANS_OUTDIR_VAR_NAME] = "{}/{}".format("/outdir/out", os.path.basename(self.lv_user_out_Dir))
                    mt_host_vars[host_name][self.AnscObj.ITA_SP_VAR_CONDUCTO_DIR_VAR_NAME] = "{}/{}".format("/outdir/out", os.path.basename(self.lv_user_out_Dir))
            else:
                mt_host_vars[host_name][self.AnscObj.ITA_SP_VAR_ANS_OUTDIR_VAR_NAME] = self.lv_user_out_Dir
                mt_host_vars[host_name][self.AnscObj.ITA_SP_VAR_CONDUCTO_DIR_VAR_NAME] = self.lv_conductor_instance_Dir

            if self.lv_conductor_instance_no:
                mt_host_vars[host_name][self.AnscObj.ITA_SP_VAR_CONDUCTOR_ID] = self.lv_conductor_instance_no
            else:
                mt_host_vars[host_name][self.AnscObj.ITA_SP_VAR_CONDUCTOR_ID] = self.LC_ANS_UNDEFINE_NAME
            mt_host_vars[host_name][self.AnscObj.ITA_SP_VAR_ANS_EXECUTION_NO] = execution_no
            mt_host_vars[host_name][self.AnscObj.ITA_SP_VAR_ANS_MOVEMENT_ID] = movement_id

        return mt_host_vars

    def getDBTemplateMaster(self, in_tpf_var_name, mt_tpf_key, mt_tpf_file_name, mt_tpf_role_only, mt_tpf_vars_struct):
        """
        テンプレートファイルの情報をデータベースより取得する。
        Arguments:
            in_tpf_var_name:    テンプレート変数名
            mt_tpf_key:         テンプレートKey格納変数
            mt_tpf_file_name:   テンプレートファイル格納変数
            mt_tpf_role_only:   多段/読替表変数を含むテンプレート
                                1:Yes  0:No
            mt_tpf_vars_struct: 変数構造定義
        Returns:
            True/False, mt_tpf_key, mt_tpf_file_name, mt_tpf_role_only, mt_tpf_vars_struct
        """
        sql = "SELECT * FROM T_ANSC_TEMPLATE_FILE WHERE ANS_TEMPLATE_VARS_NAME = %s AND DISUSE_FLAG = '0'"

        rows = self.lv_objDBCA.sql_execute(sql, [in_tpf_var_name])

        if len(rows) < 1:
            # テンプレートが未登録の場合のエラー処理は呼び側にまかせる。
            # Pioneer/Legacy チェック確認
            return False, mt_tpf_key, mt_tpf_file_name, mt_tpf_role_only, mt_tpf_vars_struct

        row = rows[0]

        mt_tpf_key = row["ANS_TEMPLATE_ID"]
        mt_tpf_file_name = row["ANS_TEMPLATE_FILE"]
        mt_tpf_role_only = row["ROLE_ONLY_FLAG"]
        mt_tpf_vars_struct = row["VAR_STRUCT_ANAL_JSON_STRING"]

        return True, mt_tpf_key, mt_tpf_file_name, mt_tpf_role_only, mt_tpf_vars_struct

    def setHostvarsfile_template_file_Dir(self, in_dir):
        """
        inディレクトリ配下のテンプレートファイル格納ディレクトリパスを記憶
        Arguments:
            in_indir: inディレクトリ配下のテンプレートファイル格納ディレクトリパス
        Returns:
            なし
        """
        self.lv_Hostvarsfile_template_file_Dir = in_dir

    def getHostvarsfile_template_file_Dir(self):
        """
        inディレクトリ配下のテンプレートファイル格納ディレクトリパスを取得
        Arguments:
            なし
        Returns:
            in_indir: inディレクトリ配下のテンプレートファイル格納ディレクトリパス
        """
        return self.lv_Hostvarsfile_template_file_Dir

    def setTemporary_file_Dir(self, in_indir):
        """
        ITA側一時ファイル格納ディレクトリ名を記憶
        Arguments:
            in_indir: 一時ファイル格納ディレクトリ
        Returns:
            なし
        """
        self.lv_Ansible_temporary_files_Dir = in_indir

    def getTemporary_file_Dir(self):
        """
        ITA側一時ファイル格納ディレクトリ名を取得
        Arguments:
            なし
        Returns:
            一時ファイル格納ディレクトリ
        """
        return self.lv_Ansible_temporary_files_Dir

    def setAnsible_template_files_Dir(self, in_indir):
        """
        inディレクトリからのtemplate_filesディレクトリパスを記憶
        Arguments:
            in_dir:  inディレクトリからのtemplate_filesディレクトリパス
        Returns:
            なし
        """
        self.lv_Ansible_template_files_Dir = in_indir

    def getAnsible_template_files_Dir(self):
        """
        inディレクトリからのtemplate_filesディレクトリパスを取得
        Arguments:
            なし
        Returns:
            inディレクトリ内のSSH秘密鍵ファイルパス
        """
        return self.lv_Ansible_template_files_Dir

    # del def setITA_template_file_Dir(self, in_indir):
    # del def getITA_template_file_Dir(self):
    # getITA_template_fileに置換え
    def getITA_template_file(self, in_key, in_filename):
        """
        ITAが管理しているテンプレートファイルのパスを取得
        Arguments:
            in_key:     テンプレートファイルのPkey(データベース)
            in_filename:   テンプレートファイル名
        Returns:
            ITAが管理しているテンプレートファイルのパス
        """
        path = "{}/{}/{}".format(getTemplateContentUploadDirPath(), in_key, in_filename)
        return path

    def getHostvarsfile_template_file_path(self, in_pkey, in_file):
        """
        inディレクトリ配下のテンプレートファイルパスを取得
        ホスト変数ファイル内のテンプレートファイルパス
        Arguments:
            in_pkey:    テンプレートファイル Pkey
            in_file:    テンプレートファイル
        Returns:
            inディレクトリ配下のテンプレートファイルパス
        """
        file = "{}/{}-{}".format(self.getHostvarsfile_template_file_Dir(), in_pkey, in_file)
        return file

    def getAnsible_template_file(self, in_pkey, in_filename):
        """
        Ansible実行時のテンプレートファイルパスを取得
            getHostvarsfile_template_file_path と同じパスになる
        Arguments:
            in_pkey:    テンプレートファイル Pkey
            in_file:    テンプレートファイル
        Returns:
            Ansible実行時のテンプレートファイルパス
        """
        file = "{}/{}-{}".format(self.getAnsible_template_files_Dir(), in_pkey, in_filename)
        return file

    def CreateTemplatefiles(self, ina_template_files):
        """
        テンブレートファイルを所定のディレクトリにコピーする。
        Arguments:
            ina_template_files: テンプレートファイル配列
                                {Pkey:テンプレートファイル}
        Returns:
            True/False
        """
        for pkey, template_file in ina_template_files.items():
            # テンプレートファイルが存在しているか確認
            src_file = self.getITA_template_file(pkey, template_file)
            if os.path.isfile(src_file) is False:
                msgstr = g.appmsg.get_api_message("MSG-10121", [pkey, os.path.basename(src_file)])
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)
                return False

            # inディレクトリ配下のテンプレートファイルのパス取得
            dst_file = self.getAnsible_template_file(pkey, template_file)

            if os.path.isfile(dst_file) is True:
                # 既にコピー済み
                continue

            # inディレクトリ配下にテンプレートファイルをコピー
            shutil.copyfile(src_file, dst_file)

        return True

    def getDBPatternList(self, in_pattern_id):
        """
        Movementロール紐付の情報を取得
        Arguments:
            in_pattern_id:   MovementID
        Returns:
            True/False, pattern_list, single_pkg
            pattern_list: Movementロール紐付の情報返却配列
            single_pkg:   ロールパッケージの複数指定有無
        """
        pattern_list = []
        single_pkg = True
        sql = '''
                SELECT
                    *
                FROM
                    {}
                WHERE
                    MOVEMENT_ID  = %s AND
                    DISUSE_FLAG = 0
                '''.format(self.AnscObj.vg_ansible_pattern_linkDB)

        # DBエラーはExceptionで呼び元に戻る
        rows = self.lv_objDBCA.sql_execute(sql, [in_pattern_id])

        # Movementロール紐付登録確認
        if len(rows) < 1:
            msgstr = g.appmsg.get_api_message("MSG-10180", [in_pattern_id])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, pattern_list, single_pkg

        pkgid = 0
        idx = 0

        for row in rows:
            # 複数のロールパッケージが紐付ていないか判定
            if idx == 0:
                pkgid = row['ROLE_PACKAGE_ID']
                # Movementロール紐付設定
                pattern_list.append(row)
            else:
                if pkgid != row['ROLE_PACKAGE_ID']:
                    single_pkg = False
            idx = 1
        return True, pattern_list, single_pkg

    def getDBRolePackage(self, in_role_package_id):
        """
        ロールパッケージ管理の情報を取得
        Arguments:
            in_role_package_id: ロールパッケージID
        Returns:
            [True/False, role_package_list]
            role_package_list:  ロールパッケージ管理の情報
                                [{ROLE_PACKAGE_ID:? ,ROLE_PACKAGE_NAME: ? ,ROLE_PACKAGE_FILE: ?}]
        """
        sql = '''
                SELECT
                    *
                FROM
                    {}
                WHERE
                    ROLE_PACKAGE_ID = %s AND
                    DISUSE_FLAG = 0
                '''.format(self.AnscObj.vg_ansible_master_fileDB)

        # DBエラーはExceptionで呼び元に戻る
        rows = self.lv_objDBCA.sql_execute(sql, [in_role_package_id])

        role_package_list = []
        # ロールパッケージID登録確認
        if len(rows) < 1:
            msgstr = g.appmsg.get_api_message("MSG-10264", [in_role_package_id])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, role_package_list

        if not rows[0]['ROLE_PACKAGE_FILE']:
            #
            msgstr = g.appmsg.get_api_message("MSG-10279", [in_role_package_id])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, role_package_list

        role_package_list.append(rows[0])

        return True, role_package_list

    def getDBLegactRoleList(self, in_pattern_id, mt_rolenamelist):
        """
        Movementに紐づいているロール名を取得
        Arguments:
            in_pattern_id:      MovementID
            mt_rolenamelist:    ロール一覧
                                {INCLUDE_SEQ:{ROLE_ID:{ROLE_NAME'}}
        Returns:
            True/False, mt_rolenamelist
        """
        sql = '''
                SELECT
                    TBL_1.MVMT_MATL_LINK_ID,
                    TBL_1.ROLE_ID,
                    TBL_1.INCLUDE_SEQ,
                    TBL_2.ROLE_NAME,
                    TBL_2.DISUSE_FLAG
                FROM
                    (
                    SELECT
                        TBL3.MVMT_MATL_LINK_ID,
                        TBL3.MOVEMENT_ID,
                        TBL3.ROLE_ID,
                        TBL3.INCLUDE_SEQ
                    FROM
                        {}  TBL3
                    WHERE
                        TBL3.MOVEMENT_ID  = %s AND
                        TBL3.DISUSE_FLAG = '0'
                    )TBL_1
                    LEFT OUTER JOIN  {}  TBL_2 ON
                        ( TBL_1.ROLE_ID = TBL_2.ROLE_ID)
                    ORDER BY TBL_1.INCLUDE_SEQ
                '''.format(self.AnscObj.vg_ansible_pattern_linkDB, self.AnscObj.vg_ansible_roleDB)

        # DBエラーはExceptionで呼び元に戻る
        rows = self.lv_objDBCA.sql_execute(sql, [in_pattern_id])

        mt_rolenamelist = {}
        for row in rows:
            if row['DISUSE_FLAG'] == '0':
                if row['INCLUDE_SEQ'] not in mt_rolenamelist:
                    mt_rolenamelist[row['INCLUDE_SEQ']] = {}
                if row['ROLE_ID'] not in mt_rolenamelist[row['INCLUDE_SEQ']]:
                    mt_rolenamelist[row['INCLUDE_SEQ']][row['ROLE_ID']] = {}
                mt_rolenamelist[row['INCLUDE_SEQ']][row['ROLE_ID']] = row['ROLE_NAME']

            # ロール管理にロールが未登録の場合
            elif not row['DISUSE_FLAG']:
                #
                msgstr = g.appmsg.get_api_message("MSG-10265", row['MVMT_MATL_LINK_ID'])
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)
                return False, mt_rolenamelist
            # DISUSE_FLAG = '1'は読み飛ばし
        if len(rows) < 1:
            #
            msgstr = g.appmsg.get_api_message("MSG-10266", [in_pattern_id])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, mt_rolenamelist
        # 対象ロールの数を確認
        if len(mt_rolenamelist) < 1:
            #
            msgstr = g.appmsg.get_api_message("MSG-10266", [in_pattern_id])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, mt_rolenamelist

        return True, mt_rolenamelist

    def CreateLegacyRolePlaybookfiles(self, ina_rolenames, in_exec_mode, in_exec_playbook_hed_def):
        """
        Legacy-Role用 親PlayBookファイルを作成する。
        Arguments:
            ina_rolenames:              ロール名リスト配列
                                        [実行順序][ロールID(Pkey)]=>ロール名
            in_exec_mode:               実行エンジン
                                        1: Ansible  2: Ansible Tower
            in_exec_playbook_hed_def:   親playbookヘッダセクション
        Returns:
            True/False
        """
        # 親PlayBookファイル作成(Legacy-Role)
        file_name = self.getAnsible_RolePlaybook_file()
        if self.CreatePlaybookfile(file_name, ina_rolenames, in_exec_mode, in_exec_playbook_hed_def) is False:
            return False
        return True

    def CheckLegacyRolePlaybookfiles(self, ina_hosts, ina_host_vars, ina_rolenames, ina_role_rolenames, ina_role_rolevars, ina_role_roleglobalvars):
        """
        Playbookで使用している変数がホスト変数に登録されているかチェックする。
        Arguments:
            ina_hosts:                  機器一覧ホスト一覧
                                        {SYSTEM_ID:HOST_NAME}, , ,
            ina_host_vars:              ホスト変数配列
                                        [ホスト名(IP)][ 変数名 ]=>具体値
            ina_rolenames:              ロール名リスト配列(データベース側)
                                        [実行順序][ロールID(Pkey)]=>ロール名
            ina_role_rolenames:         ロール名リスト配列(Role内登録内容)
                                        [ロール名]
            ina_role_rolevars:          ロール内変数リスト配列(Role内登録内容)
                                        [ロール名][変数名]=0
            ina_role_roleglobalvars:    ロール内グローバル変数リスト配列(Role内登録内容)
                                        [ロール名][グローバル変数名]=0
        Returns:
            True/False
        """
        # グローバル変数以外の変数の具体値が未登録でもエラーにしていないので
        # グローバル変数についてもグローバル変数管理の登録の有無をチェックしない

        result_code = True

        # ロール分の繰返し(データベース側)
        for no, rolename_list in ina_rolenames.items():
            # ロール名取得(データベース側)
            for rolepkey, rolename in rolename_list.items():
                # データベース側のロールがロール内に存在しているか判定
                if rolename not in ina_role_rolenames:
                    # 存在していない
                    msgstr = g.appmsg.get_api_message("MSG-10276", [rolename])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    result_code = False
                    continue
                # ロール内に変数が登録されているか
                if rolename not in ina_role_rolevars:
                    # ロール内に変数が使用されていない場合は以降のチェックをスキップ
                    continue

                # ロールに登録されている変数のデータベース登録確認
                for var_name, dummy in ina_role_rolevars[rolename].items():
                    # ホスト配列のホスト分繰り返し
                    for no, host_name in ina_hosts.items():
                        # ITA独自変数の具体値確認
                        chkVarDict = {}
                        chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_PROTOCOL_VAR_NAME] = "MSG-10267"
                        chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_USERNAME_VAR_NAME] = "MSG-10268"
                        chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_PASSWD_VAR_NAME] = "MSG-10269"
                        chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_DNSHOSTNAME_VAR_NAME] = "MSG-10914"
                        chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_IPADDRESS_VAR_NAME] = "MSG-10915"
                        chkVarDict[self.AnscObj.ITA_SP_VAR_CONDUCTOR_ID] = "MSG-10926"
                        errParamList = [rolename, var_name, host_name]
                        other_Var_chk_error_no = None
                        ret = self.chkVariableValue(var_name, ina_host_vars[host_name], chkVarDict, errParamList, other_Var_chk_error_no)
                        if ret is False:
                            result_code = False
        return result_code

    def getAnsible_RolePlaybook_file(self):
        """
        Ansible Role 親Playbookファイルパス取得
        Arguments:
            なし
        Returns:
            Ansible Role 親Playbookファイルパス
        """
        file = "{}/{}".format(self.getAnsible_in_Dir(), self.LC_ANS_ROLE_PLAYBOOK_FILE)
        return file

    def getRolePackageFile(self, in_pattern_id):
        """
        Movement紐付パッケージファイルを取得
        Arguments:
            in_pattern_id:   MovementID
        Returns:
            [{True/False, role_package_pkey, role_package_file}]
            role_package_pkey:  ロールパッケージファイル Pkey返却
            role_package_file:  ロールパッケージファイル(ZIP)返却
        """
        role_package_pkey = ""
        role_package_file = ""
        # Movementロール紐付に登録されているロールパッケージの情報取得
        # Movementロール紐付なし、複数のロールパッケージの紐付をチェック
        retAry = self.getDBPatternList(in_pattern_id)
        ret = retAry[0]
        patternlist = retAry[1]
        single_pkg = retAry[2]
        # [{ ROLE_PACKAGE_ID:? ,ROLE_ID: ?, INCLUDE_SEQ: ? }]
        if ret is not True:
            msgstr = g.appmsg.get_api_message("MSG-10023", [os.path.basename(inspect.currentframe().f_code.co_filename),
                                                            str(inspect.currentframe().f_lineno),
                                                            str(inspect.currentframe().f_lineno)])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, role_package_pkey, role_package_file

        # 作業パターン詳細に複数のロールパッケージが紐づいていないか判定する。
        if single_pkg is False:
            #
            msgstr = g.appmsg.get_api_message("MSG-10263", [])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, role_package_pkey, role_package_file

        role_package_pkey = patternlist[0]["ROLE_PACKAGE_ID"]

        # ロールパッケージ管理の情報取得
        retAry = self.getDBRolePackage(role_package_pkey)
        ret = retAry[0]
        rolepackagelist = retAry[1]
        #  [{ROLE_PACKAGE_ID:? ,ROLE_PACKAGE_NAME: ? ,ROLE_PACKAGE_FILE: ?}]
        if ret is not True:
            msgstr = g.appmsg.get_api_message("MSG-10023", [os.path.basename(__file__),
                                                            str(inspect.currentframe().f_lineno),
                                                            str(inspect.currentframe().f_lineno)])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, role_package_pkey, role_package_file

        role_package_file = rolepackagelist[0]["ROLE_PACKAGE_FILE"]
        role_package_pkey = rolepackagelist[0]["ROLE_PACKAGE_ID"]
        return True, role_package_pkey, role_package_file

    def getAnsible_RolePackage_file(self, in_pkey, in_filename):
        """
        ロールパッケージファイル(ZIP)パスを取得
        Arguments:
            in_pkey:      ロールパッケージファイル(ZIP) Pkey
            in_filename:  ロールパッケージファイル名
        Returns:
            ロールパッケージファイル(ZIP)パス
        """
        file = "{}/{}/{}".format(getRolePackageContentUploadDirPath(), in_pkey, in_filename)
        return file

    def setHostvarsfile_copy_file_Dir(self, in_dir):
        """
        inディレクトリ配下のデcopy_filesィレクトリバスを記憶
        Arguments:
            in_dir:      copy_filesディレクトリ
        Returns:
            なし
        """
        self.lv_Hostvarsfile_copy_file_Dir = in_dir

    def getHostvarsfile_copy_file_Dir(self):
        """
        inディレクトリ配下のデcopy_filesィレクトリバスを取得
        Arguments:
            なし
        Returns:
            inディレクトリ配下のデcopy_filesィレクトリバス
        """
        return self.lv_Hostvarsfile_copy_file_Dir

    def setAnsible_copy_files_Dir(self, in_indir):
        """
        inディレクトリからのcopy_filesディレクトリバスを記憶
        Arguments:
            in_indir: inディレクトリからのcopy_filesディレクトリバス
        Returns:
            なし
        """
        self.lv_Ansible_copy_files_Dir = in_indir

    def getAnsible_copy_files_Dir(self):
        """
        inディレクトリからのcopy_filesディレクトリバスを取得
        Arguments:
            なし
        Returns:
            inディレクトリからのcopy_filesディレクトリバス
        """
        return self.lv_Ansible_copy_files_Dir

    # setITA_copy_file_Dir(self, in_indir):
    # getITA_copy_file_Dir():
    # getITA_copy_fileに置換え
    def getITA_copy_file(self, in_key, in_filename):
        """
        ITAが管理しているcopyファイルのパスを取得
        Arguments:
            in_key:        copyファイルのPkey(データベース)
            in_filename:   copyファイル名
        Returns:
            ITAが管理しているcopyファイルのパス
        """
        path = "{}/{}/{}".format(getFileContentUploadDirPath(), in_key, in_filename)
        return path

    def getHostvarsfile_copy_file_value(self, in_pkey, in_file):
        """
        inディレクトリからのcopy_filesディレクトリバスを取得
        Arguments:
            in_pkey:   ファイル管理 Pkey
            in_file:   ファイル管理 ファイル名
        Returns:
            inディレクトリからのcopy_filesディレクトリバス
        """
        path = "{}/{}-{}".format(self.getHostvarsfile_copy_file_Dir(), in_pkey, in_file)
        return path

    def getAnsible_copy_file(self, in_pkey, in_filename):
        """
        ロールパッケージ管理の情報を取得
        Arguments:
            in_role_package_id: ロールパッケージID
        Returns:
            [True/False, role_package_list]
            role_package_list:  ロールパッケージ管理の情報
                                [{ROLE_PACKAGE_ID:? ,ROLE_PACKAGE_NAME: ? ,ROLE_PACKAGE_FILE: ?}]
        """
        filepath = "{}/{}-{}".format(self.getAnsible_copy_files_Dir(), in_pkey, in_filename)
        return filepath

    def CreateCopyfiles(self, ina_copy_files):
        """
        ファイル管理のファイルを所定のディレクトリにコピーする。
        Arguments:
            ina_copy_files: copyファイル配列
                            {Pkey: copyファイル}..
        Returns:
            True/False
        """
        for pkey, copy_file in ina_copy_files.items():
            # copyファイルが存在しているか確認
            src_file = self.getITA_copy_file(pkey, copy_file)
            if os.path.isfile(src_file) is False:
                msgstr = g.appmsg.get_api_message("MSG-10410", [pkey, os.path.basename(src_file)])
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)
                return False

            # Ansible実行時のcopyファイル名
            dst_file = self.getAnsible_copy_file(pkey, copy_file)
            if os.path.isfile(dst_file) is True:
                # 既にコピー済み
                return True

            shutil.copyfile(src_file, dst_file)

        return True

    def getDBCopyMaster(self, in_cpf_var_name, mt_cpf_key, mt_cpf_file_name):
        """
        ファイル管理の情報取得
        Arguments:
            in_cpf_var_name: ファイル管理変数名
            mt_cpf_key:      ファイル管理 Pkey
            mt_cpf_file_name: ファイル管理ファイル名
        Returns:
            [True/False, mt_cpf_key, mt_cpf_file_name
        """
        sql = """
                SELECT
                    *
                FROM
                    T_ANSC_CONTENTS_FILE
                WHERE
                    CONTENTS_FILE_VARS_NAME = %s AND
                    DISUSE_FLAG             = '0'
                """
        mt_cpf_key = ""
        mt_cpf_file_name = ""

        rows = self.lv_objDBCA.sql_execute(sql, [in_cpf_var_name])

        if len(rows) < 1:
            # ファイル管理が未登録の場合のエラー処理は呼び側にまかせる。
            # Pionner/Legacyのチェック確認
            return False, mt_cpf_key, mt_cpf_file_name

        row = rows[0]

        mt_cpf_key = row["CONTENTS_FILE_ID"]
        mt_cpf_file_name = row["CONTENTS_FILE"]

        return True, mt_cpf_key, mt_cpf_file_name

    def makeHostVarsPath(self, in_var_name_str, mt_var_path_array):
        """
        多段変数のメンバー変数へのパス配列を生成
        Arguments:
            in_var_name_str:     多段変数のメンバー変数へのパス
            mt_var_path_array:  多段変数のメンバー変数へのパス配列
        Returns:
            mt_var_path_array
        """
        # 列順序を文字列ソート対応
        # exp1
        # VAR_sp_array1:
        #   - array1_list: []
        #     array1_std:
        #     array1_array:
        #       - array1_array_list: []
        #         array1_array_std:
        # 入力 [0].array1_array[0].array1_array_std
        # 出力 .0000000000.array1_array.0000000000.array1_array_std
        # exp2
        # VAR_sp_array2:
        #   array:
        #     - array2_list: []
        #       array2_std:
        #       array2_array:
        # 入力 array[0].array2_list
        # 出力 array.0000000000.array2_list
        # 列順次([0-9])を10桁の0埋文字列に置換
        # in_var_name_str = in_var_name_str.replace("[", ".")
        # in_var_name_str = in_var_name_str.replace("]", "")
        in_var_name_str = self.strtozfill(in_var_name_str)
        # 先頭が配列の場合の . を取り除く
        # .array1.array2.0.array2_2.0.array2_2_2.0.array2_2_2_2
        in_var_name_str = re.sub(r'^\.', '', in_var_name_str)
        mt_var_path_array = in_var_name_str.split('.')

        return mt_var_path_array

    def strtozfill(slef, in_var_name_str):
        out_var_name_str = ""
        add_list = []
        in_var_name_str = in_var_name_str.replace("[", ".-")
        in_var_name_str = in_var_name_str.replace("]", "-")
        str_list = in_var_name_str.split('.')
        for str in str_list:
            mc = "\-[0-9]*\-"
            ret = re.match(mc, str)
            if ret is not None:
                str = str.replace("-", "")
                str = str.replace("-", "")
                str = str.zfill(10)
            add_list.append(str)
        out_var_name_str = ".".join(add_list)
        return out_var_name_str

    def makeHostVarsArray(self, in_key_array, in_idx, mt_out_array, in_var_type, in_var_val, in_ass_no):
        """
        多段／変数メンバー変数の具体値情報をホスト変数ファイルに戻す為の配列作成
        Arguments:
            in_key_array:      多段／変数メンバー変数へのパス配列
            in_idx:            階層番号(0～)
            mt_out_array(out): ホスト変数ファイルに戻す為の配列
            in_var_type:       メンバー変数のタイプ
                                1: Key-Value変数
                                2: 複数具体値変数
            in_var_val:        メンバー変数の具体値
            in_ass_no:         複数具体値変数の場合の代入順序
        Returns:
            なし
        """
        # 末端の変数に達したか判定
        if len(in_key_array) <= in_idx:

            # 末端の変数か判定
            if len(in_key_array) == in_idx:
                # 具体値を埋め込む
                if in_var_type == AnscConst.GC_VARS_ATTR_STD:
                    # Key-Value変数の場合
                    mt_out_array = in_var_val
                else:
                    # 複数具体値の場合
                    mt_out_array[in_ass_no] = in_var_val

                    # 代入順序で昇順ソートする。
                    sortdic = sorted(mt_out_array.items(), key=lambda x: x[0], reverse=False)
                    mt_out_array.clear()
                    mt_out_array.update(sortdic)

            return mt_out_array

        # 該当階層の変数名を取得
        var_name = in_key_array[in_idx]

        # ホスト変数配列に変数名が退避されているか判定
        if var_name not in mt_out_array:
            # 変数名をホスト変数配列に退避
            mt_out_array[var_name] = {}

            # 配列の場合に列順序で昇順ソート
            if var_name.isdigit() is True:
                sortdic = sorted(mt_out_array.items(), key=lambda x: x[0], reverse=False)
                mt_out_array.clear()
                mt_out_array.update(sortdic)

        in_idx += 1
        # 次の階層へ
        ret = self.makeHostVarsArray(in_key_array, in_idx, mt_out_array[var_name], in_var_type, in_var_val, in_ass_no)
        mt_out_array[var_name] = ret
        return mt_out_array

    def MultiArrayVarsToYamlFormatSub(self,
                                      ina_host_vars_array,
                                      mt_str_hostvars,
                                      in_before_vars,
                                      in_indent,
                                      nest_level,
                                      mt_error_code,
                                      mt_line,
                                      mt_legacy_Role_cpf_vars_list,
                                      mt_legacy_Role_tpf_vars_list):
        """
        多段変数の具体値をホスト変数ファイル出力用文字列生成
        Arguments:
            ina_host_vars_array:           多段変数の具体値リスト
            mt_str_hostvars:               ホスト変数ファイルに出力する文字列
            in_before_vars:                一つ前の変数構造
            in_indent:                     ホスト変数ファイルに出力際のインデント数
            nest_level:                    階層番号(1～)
            mt_error_code:                 エラー時のメッセージコード
            mt_line:                       エラー発生個所
            mt_legacy_Role_cpf_vars_list   ファイル管理変数リスト
            mt_legacy_Role_tpf_vars_list   テンプレート理変数リスト
        Returns:
            True/False, Dmt_str_hostvars, mt_error_code, mt_line, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list
        """

        idx = 0

        # 配列階層か判定
        array_f = self.is_assoc(ina_host_vars_array)
        if array_f == -1:
            mt_error_code = "MSG-10455"
            mt_line = inspect.currentframe().f_lineno
            return False, mt_str_hostvars, mt_error_code, mt_line, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list

        if array_f != 'I':
            indent = in_indent + "  "
            nest_level = nest_level + 1
        else:
            indent = in_indent

        for var, val in ina_host_vars_array.items():
            # 繰返数設定
            idx = idx + 1

            # 現階層の変数名退避
            before_vars = var

            # php 要確認
            # 具体値の配列の場合の判定
            # 具体値の配列の場合は具体値が全てとれない模様
            # - xxxx1
            #   - xxxx2
            # - xxxx3
            # array(2) {
            #    [0]=>
            #      array(1) {
            #      [0]=>
            #        string(5) "xxxxx2"
            var_int = False
            if isinstance(var, int):
                var_int = True
            else:
                if var.isdigit():
                    var_int = True
            if var_int is True:
                # 具体値の配列の場合の判定
                ret = self.is_assoc(val)
                if ret == "I":
                    mt_error_code = "MSG-10456"
                    mt_line = inspect.currentframe().f_lineno
                    return False, mt_str_hostvars, mt_error_code, mt_line, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list

            # 複数具体値か判定する。
            if var_int is True:

                # 具体値があるか判定
                if isinstance(val, dict) is False:
                    # 変数の具体値にコピー変数が使用されていないか確認
                    retAry = self.LegacyRoleCheckConcreteValueIsVar(val,
                                                                    mt_legacy_Role_cpf_vars_list,
                                                                    mt_legacy_Role_tpf_vars_list)
                    ret = retAry[0]
                    mt_legacy_Role_cpf_vars_list = retAry[1]
                    mt_legacy_Role_tpf_vars_list = retAry[2]
                    if ret is False:
                        # エラーメッセージは出力しているので、ここでは何も出さない。
                        mt_error_code = ""
                        return False, mt_str_hostvars, mt_error_code, mt_line, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list

                    # 具体値出力
                    # - xxxxxxx
                    NumPadding = len(indent) + 4
                    # 多段変数の複数具体値はJSON形式なっていない
                    edit_str = self.MultilineValueEdit(val, NumPadding)

                    vars_str = "{}  - {}\n".format(indent, edit_str)
                    mt_str_hostvars = mt_str_hostvars + vars_str
                    continue

                else:
                    # 具体値がないので配列階層
                    # 配列階層の場合はインデントを1つ戻す。
                    if idx == 1:
                        indent = "".ljust(len(indent) - 2)
            else:
                # 1つ前の階層が配列階層か判定
                if in_before_vars.isdigit():
                    # Key-Value変数か判定
                    if isinstance(val, dict) is False:
                        # Key-Value変数の場合
                        if idx == 1:
                            # 変数の具体値にコピー変数が使用されていないか確認
                            retAry = self.LegacyRoleCheckConcreteValueIsVar(val,
                                                                            mt_legacy_Role_cpf_vars_list,
                                                                            mt_legacy_Role_tpf_vars_list)
                            ret = retAry[0]
                            mt_legacy_Role_cpf_vars_list = retAry[1]
                            mt_legacy_Role_tpf_vars_list = retAry[2]

                            if ret is False:
                                # エラーメッセージは出力しているので、ここでは何も出さない。
                                mt_error_code = ""
                                return False, mt_str_hostvars, mt_error_code, mt_line, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list
                            # 変数と具体値出力 配列の先頭変数なので - を付ける
                            # - xxxxx: xxxxxxx
                            NumPadding = len(indent) + 4
                            edit_str = self.MultilineValueEdit(val, NumPadding)
                            vars_str = "{}- {}: {}\n".format(indent, var, edit_str)
                            mt_str_hostvars = mt_str_hostvars + vars_str

                            # インデント位置を加算
                            indent = indent + "  "

                        else:

                            # 変数の具体値にコピー変数が使用されていないか確認
                            retAry = self.LegacyRoleCheckConcreteValueIsVar(val,
                                                                            mt_legacy_Role_cpf_vars_list,
                                                                            mt_legacy_Role_tpf_vars_list)
                            ret = retAry[0]
                            mt_legacy_Role_cpf_vars_list = retAry[1]
                            mt_legacy_Role_tpf_vars_list = retAry[2]
                            if ret is False:
                                # エラーメッセージは出力しているので、ここでは何も出さない。
                                mt_error_code = ""
                                return False, mt_str_hostvars, mt_error_code, mt_line, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list

                            # 変数と具体値出力 配列の先頭変数ではないので - は付けない
                            #   xxxxx: xxxxxx
                            # インデント位置は加算済み
                            NumPadding = len(indent) + 4
                            edit_str = self.MultilineValueEdit(val, NumPadding)
                            vars_str = "{}{}: {}\n".format(indent, var, edit_str)
                            mt_str_hostvars = mt_str_hostvars + vars_str

                        continue

                    else:
                        # ネスト変数の場合
                        if idx == 1:
                            # 変数出力 配列の先頭変数なので - を付ける
                            vars_str = "{}- {}:\n".format(indent, var)
                            mt_str_hostvars = mt_str_hostvars + vars_str

                            # インデント位置を加算
                            indent = indent + "  "

                        else:
                            # 変数出力 配列の先頭変数ではないので - は付けない
                            vars_str = "{}{}:\n".format(indent, var)
                            mt_str_hostvars = mt_str_hostvars + vars_str

                else:
                    # Key-Value変数か判定
                    if isinstance(val, dict) is False:
                        # 変数の具体値にコピー変数が使用されていないか確認
                        retAry = self.LegacyRoleCheckConcreteValueIsVar(val,
                                                                        mt_legacy_Role_cpf_vars_list,
                                                                        mt_legacy_Role_tpf_vars_list)
                        ret = retAry[0]
                        mt_legacy_Role_cpf_vars_list = retAry[1]
                        mt_legacy_Role_tpf_vars_list = retAry[2]
                        if ret is False:
                            # エラーメッセージは出力しているので、ここでは何も出さない。
                            mt_error_code = ""
                            return False, mt_str_hostvars, mt_error_code, mt_line, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list

                        # 変数と具体値出力
                        # xxxxx: xxxxxxx
                        NumPadding = len(indent) + 4
                        edit_str = self.MultilineValueEdit(val, NumPadding)
                        vars_str = "{}{}: {}\n".format(indent, var, edit_str)
                        mt_str_hostvars = mt_str_hostvars + vars_str

                        continue

                    else:
                        # ネスト変数として出力
                        # xxxxx:
                        vars_str = "{}{}:\n".format(indent, var)
                        mt_str_hostvars = mt_str_hostvars + vars_str

            retAry = self.MultiArrayVarsToYamlFormatSub(val,
                                                        mt_str_hostvars,
                                                        before_vars,
                                                        indent,
                                                        nest_level,
                                                        mt_error_code,
                                                        mt_line,
                                                        mt_legacy_Role_cpf_vars_list,
                                                        mt_legacy_Role_tpf_vars_list)
            ret = retAry[0]
            mt_str_hostvars = retAry[1]
            mt_error_code = retAry[2]
            mt_line = retAry[3]
            mt_legacy_Role_cpf_vars_list = retAry[4]
            mt_legacy_Role_tpf_vars_list = retAry[5]
            if ret is False:
                return False, mt_str_hostvars, mt_error_code, mt_line, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list

        return True, mt_str_hostvars, mt_error_code, mt_line, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list

    def is_assoc(self, in_array):
        """
        多段変数の末端変数の構造判定
        Arguments:
            in_array: 多段変数構造
        Returns:
            -1/"I"/"C"
        """
        key_int = False
        key_char = False
        if isinstance(in_array, dict) is False:
            return -1

        for key, value in in_array.items():
            # 配列構造の場合に数値(index)と文字列が混在していないか判定
            if isinstance(key, int):
                key_int = True
            else:
                if key.isdigit() is False:
                    key_char = True
                else:
                    key_int = True
        if key_char is True and key_int is True:
            return -1
        if key_char is True:
            return "C"
        return "I"

    def getDBGlobalVarsMaster(self, mt_global_vars_list):
        """
          グローバル変数の情報をデータベースより取得
          Arguments:
            mt_global_vars_list: データベースより取得したグローバル変数
          Returns:
            True
        """
        sql = '''
                SELECT
                    VARS_NAME,
                    VARS_ENTRY
                FROM
                    T_ANSC_GLOBAL_VAR
                WHERE
                    DISUSE_FLAG = '0'
                '''
        # DBエラーはExceptionで呼び元に戻る
        rows = self.lv_objDBCA.sql_execute(sql, [])
        for row in rows:
            if row['VARS_NAME'] not in mt_global_vars_list:
                mt_global_vars_list[row['VARS_NAME']] = row['VARS_ENTRY']
        return True, mt_global_vars_list

    def CreateLegacyRoleCopyFiles(self, ina_hosts, ina_rolenames, ina_cpf_vars_list):
        """
        playbook内で使用しているファイル管理のファイルを所定の場所にコピーする
        Arguments:
            ina_hosts:         機器一覧ホスト一覧
                               {SYSTEM_ID:HOST_NAME}, , ,
            ina_rolenames:     処理対象ロールリスト
            ina_cpf_vars_list: ファイル管理変数リスト
        Returns:
            True/False
        """
        # 処理対象のロール名抽出
        tgt_role_list = {}
        for no, rolename_list in ina_rolenames.items():
            for rolepkey, rolename in rolename_list.items():
                tgt_role_list[rolename] = 1

        # 処理対象のロールで使用しているファイル変数か判定
        la_cpf_files = {}
        la_cpf_path = {}
        for role_name, tgt_file_list in ina_cpf_vars_list.items():
            if role_name not in tgt_role_list:
                continue
            for tgt_file, line_no_list in tgt_file_list.items():
                for line_no, cpf_var_name_list in line_no_list.items():
                    for cpf_var_name, file_info_list in cpf_var_name_list.items():

                        # inディレクトリ配下のcopyファイルバスを取得
                        cpf_path = self.getHostvarsfile_copy_file_value(file_info_list['CONTENTS_FILE_ID'],
                                                                        file_info_list['CONTENTS_FILE'])

                        # ファイルパスをansible側から見たパスに変更する。
                        cpf_path = self.setAnsibleSideFilePath(cpf_path, self.LC_ITA_IN_DIR)

                        # la_cpf_path[copy変数]=inディレクトリ配下ののcopyファイルパス
                        la_cpf_path[cpf_var_name] = cpf_path

                        # copyファイルのpkeyとファイル名を退避
                        la_cpf_files[file_info_list['CONTENTS_FILE_ID']] = file_info_list['CONTENTS_FILE']

        # ファイル管理のファイルを所定の場所にコピー
        if len(la_cpf_files) > 0:
            ret = self.CreateCopyfiles(la_cpf_files)
            if ret is False:
                return False

        # ホスト変数定義ファイルにファイル管理変数を追加
        if len(la_cpf_files) > 0:
            # 作業対象ホスト分ループ
            for host_key, host_name in ina_hosts.items():
                # ホスト変数定義ファイル名を取得
                file_name = self.getAnsible_host_var_file(host_name)
                # ホスト変数定義ファイルにテンプレート変数を追加
                if self.CreateRoleHostvarsfile("CPF", file_name, la_cpf_path, "", "", "", "", "a") is False:
                    return False

        return True

    # function getDBTranslationTable(in_pattern_id, &ina_translationtable_list){
    def setAnsible_upload_files_Dir(self, in_indir):
        """
        inディレクトリからのFileUpLoadColumnファイル格納ディレクトリパス(upload_files)を記憶
        Arguments:
            inディレクトリからのFileUpLoadColumnファイル格納ディレクトリパス(upload_files)
        Returns:
            なし
        """
        self.lv_Ansible_upload_files_Dir = in_indir

    def getAnsible_upload_files_Dir(self):
        """
        inディレクトリからのFileUpLoadColumnファイル格納ディレクトリパス(upload_files)を取得
        Arguments:
            なし
        Returns:
            inディレクトリからのFileUpLoadColumnファイル格納ディレクトリパス(upload_files)
        """
        return self.lv_Ansible_upload_files_Dir

    def setAnsible_ssh_key_files_Dir(self, in_indir):
        """
        inディレクトリからのSSH秘密鍵ファイル格納ディレクトリパス(ssh_key_files)を記憶
        Arguments:
            in_dir:      ssh_key_filesディレクトリ
        Returns:
            なし
        """
        self.lv_Ansible_ssh_key_files_Dir = in_indir

    def getAnsible_ssh_key_files_Dir(self):
        """
        inディレクトリからのSSH秘密鍵ファイル格納ディレクトリパス(ssh_key_files)を取得
        Arguments:
            なし
        Returns:
            inディレクトリからのSSH秘密鍵ファイル格納ディレクトリパス(ssh_key_files)
        """
        return self.lv_Ansible_ssh_key_files_Dir

    def getITA_ssh_key_file(self, in_key, in_filename):
        """
        ITAが機器一覧で管理しているSSH秘密鍵ファイルのパスを取得
        Arguments:
            in_key:        SSH秘密鍵ファイルのPkey(データベース)
            in_filename:   SSH秘密鍵ファイル名
        Returns:
            ITAが機器一覧で管理しているSSH秘密鍵ファイルのパス
        """
        path = "{}/{}/{}".format(getDeviceListSSHPrivateKeyUploadDirPath(), in_key, in_filename)
        return path

    def getIN_ssh_key_file(self, in_pkey, in_file):
        """
        inディレクトリのSH秘密鍵ファイルパス(ssh_key_files)を取得
        Arguments:
            in_pkey: SSH秘密鍵ファイルのPkey(データベース)
            in_file: SSH秘密鍵ファイル
        Returns:
            inディレクトリ内のSSH認証ファイルパス
        """
        path = "{}/{}-{}".format(self.getAnsible_ssh_key_files_Dir(), in_pkey, in_file)
        return path

    def CreateSSH_key_file(self, in_pkey, in_ssh_key_file):
        """
        inディレクトリからのSSH秘密鍵ファイルパス(ssh_key_files)を取得
        Arguments:
            in_pkey:             SSH秘密鍵ファイルのPkey(データベース)
            in_file:             SSH秘密鍵ファイル
        Returns:
            True/False, mt_dir_ssh_key_file
        """
        ssh_key_file = ""
        # SSH秘密鍵ファイルが存在しているか確認
        src_file = self.getITA_ssh_key_file(in_pkey, in_ssh_key_file)
        if os.path.isfile(src_file) is False:
            #
            msgstr = g.appmsg.get_api_message("MSG-10526", [in_pkey, src_file])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, ssh_key_file

        # Ansible実行時のSSH秘密鍵ファイルパス取得
        dst_file = self.getIN_ssh_key_file(in_pkey, in_ssh_key_file)

        # ky_encryptで中身がスクランブルされているので復元する
        # SSH認証ファイルをansible用ディレクトリにコピーする。
        ret = ky_file_decrypt(src_file, dst_file)
        if ret is False:
            #
            msgstr = g.appmsg.get_api_message("MSG-10647", [src_file])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, ssh_key_file

        # パミッション設定
        os.chmod(dst_file, 0o600)

        # Ansible実行時のSSH秘密鍵ファイルパス退避
        ssh_key_file = dst_file
        return True, ssh_key_file

    def setAnsible_win_key_files_Dir(self, in_indir):
        """
        inディレクトリからのwinRM鍵ファイル格納ディレクトリパス(win_key_files)を記憶
        Arguments:
            in_pkey:    win_key_filesディレクトリ
        Returns:
            なし
        """
        self.lv_Ansible_win_key_files_Dir = in_indir

    def getAnsible_win_key_files_Dir(self):
        """
        inディレクトリからのSSH秘密鍵ファイルパス(ssh_key_files)を取得
        Arguments:
            in_pkey:    SSH秘密鍵ファイルのPkey(データベース)
            in_file:    SSH秘密鍵ファイル
        Returns:
            inディレクトリ内のSSH秘密鍵ファイルパス
        """
        return self.lv_Ansible_win_key_files_Dir


    def getITA_win_private_key_file(self, in_pkey, in_file):
        """
        inディレクトリからのwinRM秘密鍵ファイルパス(win_ca_files)を取得
        Arguments:
            in_pkey: winRM秘密鍵ファイルのPkey(データベース)
            in_file: winRM秘密鍵ファイル名
        Returns:
            inディレクトリ内のwinRM秘密鍵ファイルパス
        """
        path = "{}/{}/{}".format(getDeviceListWinrmPrivateKeyFileUploadDirPath(), in_pkey, in_file)
        return path

    def getITA_win_public_key_file(self, in_pkey, in_file):
        """
        inディレクトリからのwinRM公開鍵ファイルパス(win_ca_files)を取得
        Arguments:
            in_pkey: winRM公開鍵ファイルのPkey(データベース)
            in_file: winRM公開鍵ファイル名
        Returns:
            inディレクトリ内のwinRM公開鍵ファイルパス
        """
        path = "{}/{}/{}".format(getDeviceListWinrmPublicKeyFileUploadDirPath(), in_pkey, in_file)
        return path

    def getIN_win_key_file(self, in_pkey, in_file):
        """
        inディレクトリからのwinRMサーバー証明書ファイルパス(win_ca_files)を取得
        Arguments:
            in_pkey: winRMサーバー証明書ファイルのPkey(データベース)
            in_file: winRMサーバー証明書ファイル名
        Returns:
            inディレクトリ内のSSH認証ファイルパス
        """
        path = "{}/{}-{}".format(self.getAnsible_win_key_files_Dir(), in_pkey, in_file)
        return path

    def CreateWinrmPublicKeyFile(self, in_pkey, in_win_key_file):
        """
        inディレクトリにwinRM公開鍵ファイルをコピーする。
        Arguments:
            in_pkey:            winRM公開鍵ファイルのPkey(データベース)
            in_win_key_file:    winRM公開鍵ファイル
        Returns:
            inディレクトリにwinRM公開鍵ファイルパス
        """
        win_key_file = ""
        # winRM公開鍵ファイルが存在しているか確認
        src_file = self.getITA_win_public_key_file(in_pkey, in_win_key_file)
        if os.path.isfile(src_file) is False:
            msgstr = g.appmsg.get_api_message("MSG-10945", [in_pkey, in_win_key_file])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, win_key_file

        #  Ansible実行時のwinRM公開鍵ファイルパス取得
        dst_file = self.getIN_win_key_file(in_pkey, in_win_key_file)

        # Ansible実行時のwinRM公開鍵ファイルをansible用ディレクトリにコピーする。
        shutil.copyfile(src_file, dst_file)

        # パミッション設定
        os.chmod(dst_file, 0o600)

        # 今後修正が必要
        # 実行ユーザーがroot以外の場合、鍵ファイルのオーナーを変更

        # Ansible実行時のwinrm公開鍵ファイルパス退避
        win_key_file = dst_file
        return True, win_key_file

    def CreateWinrmPrivateKeyFile(self, in_pkey, in_win_key_file):
        """
        inディレクトリにwinRM秘密鍵ファイルをコピーする。
        Arguments:
            in_pkey:            winRM秘密鍵ファイルのPkey(データベース)
            in_win_key_file:    winRM秘密鍵ファイル
        Returns:
            inディレクトリにwinRM秘密鍵ファイルパス
        """
        win_key_file = ""

        # winrm秘密鍵ファイルが存在しているか確認
        src_file = self.getITA_win_private_key_file(in_pkey, in_win_key_file)
        if os.path.isfile(src_file) is False:
            msgstr = g.appmsg.get_api_message("MSG-10946", [in_pkey, in_win_key_file])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, win_key_file

        #  Ansible実行時のwinrm秘密鍵ファイルパス取得
        dst_file = self.getIN_win_key_file(in_pkey, in_win_key_file)

        # サーバー証明書をansible用ディレクトリにコピーする。
        shutil.copyfile(src_file, dst_file)

        # パミッション設定
        os.chmod(dst_file, 0o600)

        # Ansible実行時のwinrm秘密鍵ファイルパス退避
        win_key_file = dst_file
        return True, win_key_file

    def LegacyRoleCheckConcreteValueIsVarTemplatefile(self,
                                                      in_host_name,
                                                      ina_var_list,
                                                      in_tpf_val_name,
                                                      in_tpf_key,
                                                      in_tpf_file_name,
                                                      ina_tpf_vars_struct_json):

        """
        テンプレートで使用しているITA独自変数がホストの変数に登録されているか判定
        Arguments:
            in_host_name:         ホスト名
            ina_var_list:         ホスト変数リスト
            in_tpf_val_name:      テンプレート変数名
            in_tpf_key:           テンプレートファイルPkey
            in_tpf_file_name:     テンプレートファイル名
            ina_tpf_vars_struct_json: テンプレートで使用している変数の変数構造(JSON)
        Returns:
            True/False
        """
        result_code = True

        templatefile = self.getITA_template_file(in_tpf_key, in_tpf_file_name)
        if os.path.isfile(templatefile) is False:
            msgstr = g.appmsg.get_api_message("MSG-10121", [in_tpf_key, os.path.basename(templatefile)])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False

        # テンプレートに登録されているITA変数を抜出す。
        # #2079 /storage配下は/tmpを経由してアクセスする
        obj = storage_read()
        obj.open(templatefile)
        dataString = obj.read()
        obj.close()

        objConv = VarStructAnalJsonConv()
        retAry = objConv.TemplateVarStructAnalJsonLoads(ina_tpf_vars_struct_json)
        # Vars_list = retAry[0]
        # Array_vars_list = retAry[1]
        # LCA_vars_use = retAry[2]
        # Array_vars_use = retAry[3]
        GBL_vars_info = retAry[4]
        # VarVal_list = retAry[5]

        use_gbl_vars_list = {}
        # テンプレートに登録されているグローバル変数のデータベース登録確認
        if isinstance(GBL_vars_info, dict):
            if '1' in GBL_vars_info.keys():
                for var_name, dummy in GBL_vars_info['1'].items():
                    if var_name not in self.lva_global_vars_list:
                        msgstr = g.appmsg.get_api_message("MSG-10530", [os.path.basename(templatefile), var_name])
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        return False
                    use_gbl_vars_list[var_name] = 1
                    self.lv_use_gbl_vars_list[var_name] = 1

        # ITA独自変数のリスト作成
        local_vars = self.setITALocalVars()

        file_vars_list = []
        # テンプレートからローカル変数を抜出す
        varsLineArray = []
        file_vars_list = []
        FillterVars = True  # Fillterを含む変数の抜き出しあり
        obj = WrappedStringReplaceAdmin(self.lv_objDBCA)
        obj.SimpleFillterVerSearch(self.AnscObj.DF_HOST_VAR_HED, dataString, varsLineArray, file_vars_list, local_vars, FillterVars)

        # ITA独自変数以外を除外する。
        ita_var_list = []
        for var_name in local_vars:
            if var_name in file_vars_list:
                ita_var_list.append(var_name)
        file_vars_list = ita_var_list

        # Roleの処理なのでina_tpf_vars_struct_array['Vars_list']にリストアップされている変数をチェックする必要なし

        # Roleの処理なのでテンプレートで変数が使用されているかのチェックも不要

        # テンプレートで使用されているITA独自変数が利用可能か判定
        for var_name in file_vars_list:
            if var_name in ina_var_list:
                # ITA独自変数の具体値確認
                chkVarDict = {}
                chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_PROTOCOL_VAR_NAME] = "MSG-10534"
                chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_USERNAME_VAR_NAME] = "MSG-10535"
                chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_PASSWD_VAR_NAME] = "MSG-10536"
                chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_DNSHOSTNAME_VAR_NAME] = "MSG-10916"
                chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_IPADDRESS_VAR_NAME] = "MSG-10917"
                chkVarDict[self.AnscObj.ITA_SP_VAR_CONDUCTOR_ID] = "MSG-10927"
                errParamList = [os.path.basename(templatefile), var_name, in_host_name]
                other_Var_chk_error_no = None
                ret = self.chkVariableValue(var_name, ina_var_list, chkVarDict, errParamList, other_Var_chk_error_no)
                if ret is False:
                    result_code = False

        return result_code

    def LegacyRoleCheckConcreteValueIsVar(self, in_var_val, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list):
        """
        変数の具体値にファイル/テンプレート変数が使用されてるかを判定
        使用されている場合に各ファイルを所定のディレクトリにコピーする。
        Arguments:
            in_var_val:                    変数の具体値
            mt_legacy_Role_cpf_vars_list:  変数の具体値にファイル変数が使用されている変数リスト
            mt_legacy_Role_tpf_vars_list:  変数の具体値にテンプレート変数が使用されている変数リスト
        Returns:
            True/False, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list
        """
        vars_list = {}
        var_type = ""

        if not in_var_val:
            return True, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list
        # ファイル管理変数　{{ CPF_[a-zA-Z0-9_] }} を取出す
        keyFilter = r"{{[\s]CPF_[a-zA-Z0-9_]*[\s]}}"
        var_match = re.findall(keyFilter, in_var_val)
        for var_name_str in var_match:
            # 両端の{{}}を取り除く
            keyFilter = r"CPF_[a-zA-Z0-9_]*"
            var_names = re.findall(keyFilter, in_var_val)
            for var_name in var_names:
                if var_name not in mt_legacy_Role_cpf_vars_list:
                    vars_list[var_name] = "CPF"

        # テンプレート変数　{{ TPF_[a-zA-Z0-9_] }} を取出す
        keyFilter = r"{{[\s]TPF_[a-zA-Z0-9_]*[\s]}}"
        var_match = re.findall(keyFilter, in_var_val)
        for var_name_str in var_match:
            # 両端の{{}}を取り除く
            keyFilter = r"TPF_[a-zA-Z0-9_]*"
            var_names = re.findall(keyFilter, in_var_val)
            for var_name in var_names:
                if var_name not in mt_legacy_Role_tpf_vars_list:
                    vars_list[var_name] = "TPF"

        if len(vars_list) == 0:
            return True, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list

        tpf_fileInfo = {}
        cpf_fileInfo = {}
        # unuse strErrMsg = ""
        # unuse strErrDetailMsg = ""
        key = ""
        file_name = ""
        for var_name, var_type in vars_list.items():
            if var_type == "CPF":
                if var_name not in mt_legacy_Role_cpf_vars_list:
                    # ファイル管理変数名からコピーファイル名とPkeyを取得する。
                    key = ""
                    file_name = ""
                    retAry = self.getDBCopyMaster(var_name, key, file_name)
                    ret = retAry[0]
                    key = retAry[1]
                    file_name = retAry[2]
                    if ret is False:
                        msgstr = g.appmsg.get_api_message("MSG-10543", [var_name])
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        return False, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list

                    # コピーファイル名が未登録の場合
                    if not file_name:
                        msgstr = g.appmsg.get_api_message("MSG-10544", [var_name])
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        return False, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list

                    # inディレクトリ配下のファイルバスを取得
                    path = self.getHostvarsfile_copy_file_value(key, file_name)
                    path = self.setAnsibleSideFilePath(path, self.LC_ITA_IN_DIR)

                    # mt_legacy_Role_cpf_vars_list[copy変数]=inディレクトリ配下のファイルパス
                    mt_legacy_Role_cpf_vars_list[var_name] = path

                    # copyファイルのpkeyとファイル名を退避
                    cpf_fileInfo[key] = file_name

            else:
                if var_name not in mt_legacy_Role_tpf_vars_list:
                    # template変数名からtemplateファイル名とPkeyを取得する。
                    tpf_var_name = var_name
                    tpf_key = ""
                    tpf_file_name = ""
                    role_only = ""
                    tpf_vars_struct_json = {}
                    retAry = self.getDBTemplateMaster(tpf_var_name, tpf_key, tpf_file_name, role_only, tpf_vars_struct_json)
                    ret = retAry[0]
                    tpf_key = retAry[1]
                    tpf_file_name = retAry[2]
                    role_only = retAry[3]
                    tpf_vars_struct_json = retAry[4]
                    if ret is False or not tpf_key:
                        # テンプレート変数名が未登録の場合
                        msgstr = g.appmsg.get_api_message("MSG-10531", [tpf_var_name])
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        return False, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list

                    if not tpf_file_name:
                        # テンプレートファイル名が未登録の場合
                        msgstr = g.appmsg.get_api_message("MSG-10558", [tpf_var_name])
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        return False, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list

                    # inディレクトリ配下のテンプレートファイルバスを取得
                    path = self.getHostvarsfile_template_file_path(tpf_key, tpf_file_name)
                    path = self.setAnsibleSideFilePath(path, self.LC_ITA_IN_DIR)

                    # mt_legacy_Role_tpf_vars_list[copy変数]=inディレクトリ配下のテンプレートファイルパス
                    mt_legacy_Role_tpf_vars_list[tpf_var_name] = path

                    # テンプレートファイルのpkeyとファイル名を退避
                    tpf_fileInfo[tpf_key] = tpf_file_name

                    # 呼び元からパラメータで受け取ることが困難なので、クラス変数経由で受け取る
                    host_name = self.LegacyRoleCheckConcreteValueIsVar_use_host_name

                    # テンプレートファイル内のホスト変数を確認
                    ret = self.LegacyRoleCheckConcreteValueIsVarTemplatefile(host_name,
                                                                             self.LegacyRoleCheckConcreteValueIsVar_use_var_list[host_name],
                                                                             tpf_var_name,
                                                                             tpf_key,
                                                                             tpf_file_name,
                                                                             tpf_vars_struct_json)
                    if ret is False:
                        return False, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list

        # ファイル管理ファイルを所定のディレクトリにコピーする。
        if len(cpf_fileInfo) > 0:
            ret = self.CreateCopyfiles(cpf_fileInfo)
            if ret is False:
                return False, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list

        # テンプレートファイルを所定のディレクトリにコピーする。
        if len(tpf_fileInfo) > 0:
            ret = self.CreateTemplatefiles(tpf_fileInfo)
            if ret is False:
                return False, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list

        return True, mt_legacy_Role_cpf_vars_list, mt_legacy_Role_tpf_vars_list

    def CreateLegacyRoleTemplateFiles(self, ina_hosts, ina_rolenames, ina_tpf_vars_list):
        """
        playbook内で使用しているテンプレート管理のファイルを所定の場所にコピーする
        Arguments:
            ina_hosts:         機器一覧ホスト一覧
                               {SYSTEM_ID:HOST_NAME}, , ,
            ina_rolenames:     処理対象ロールリスト
            ina_tpf_vars_list: テンプレート変数リスト
        Returns:
            True/False
        """
        # 処理対象のロール名抽出
        tgt_role_list = {}
        for no, rolename_list in ina_rolenames.items():
            for rolepkey, rolename in rolename_list.items():
                tgt_role_list[rolename] = 1

        # 処理対象のロールで使用しているテンプレート変数か判定
        la_tpf_files = {}
        la_tpf_path = {}
        for role_name, tgt_file_list in ina_tpf_vars_list.items():
            if role_name not in tgt_role_list:
                continue
            for tgt_file, line_no_list in tgt_file_list.items():
                for line_no, tpf_var_name_list in line_no_list.items():
                    for tpf_var_name, file_info_list in tpf_var_name_list.items():
                        # inディレクトリ配下のcopyファイルバスを取得
                        tpf_path = self.getHostvarsfile_template_file_path(file_info_list['CONTENTS_FILE_ID'], file_info_list['CONTENTS_FILE'])

                        # ファイルパスをansible側から見たパスに変更する。
                        tpf_path = self.setAnsibleSideFilePath(tpf_path, self.LC_ITA_IN_DIR)

                        # la_tpf_path[テンプレート変数]=inディレクトリ配下ののファイルパス
                        la_tpf_path[tpf_var_name] = tpf_path

                        # テンプレートファイルのpkeyとファイル名を退避
                        la_tpf_files[file_info_list['CONTENTS_FILE_ID']] = file_info_list['CONTENTS_FILE']

        # テンプレート変数kのファイルを所定の場所にコピー
        if len(la_tpf_files) > 0:
            ret = self.CreateTemplatefiles(la_tpf_files)
            if ret is False:
                return False

        # ホスト変数定義ファイルにテンプレート変数を追加
        if len(la_tpf_files) > 0:
            # 作業対象ホスト分ループ
            for host_key, host_name in ina_hosts.items():
                # ホスト変数定義ファイル名を取得
                file_name = self.getAnsible_host_var_file(host_name)
                # ホスト変数定義ファイルにテンプレート変数を追加
                if self.CreateRoleHostvarsfile("TPF", file_name, la_tpf_path, "", "", "", "", "a") is False:
                    return False

        return True

    def makeAnsibleVaultPassword(self, in_pass, in_vaultpass, in_indento, in_system_id):
        """
        指定文字列の暗号化及びインデント付加
        Arguments:
            in_pass: 暗号化する文字列
            in_vaultpass: 暗号化した文字列
            in_indento: 暗号化した文字列に付加するインデント
            in_system_id: 機器一覧のPkey
        Returns:
            False/暗号化された文字列
        """
        out_vaultpass = ""

        # unuse update_key = "key_{}_{}".format(in_system_id, in_pass)

        obj = AnsibleVault()

        if not in_vaultpass:

            # パスワードが暗号化されているか判定
            if in_pass in self.lv_vault_pass_list:
                out_vaultpass = self.lv_vault_pass_list[in_pass]
            else:
                VaultPasswordFilePath = obj.CreateVaultPasswordFilePath()
                # in_passはrot13+base64で複合化されている
                if not self.lv_ans_if_info['ANSIBLE_VAULT_PASSWORD']:
                    self.lv_ans_if_info['ANSIBLE_VAULT_PASSWORD'] = ky_encrypt(AnscConst.DF_ANSIBLE_VAULT_PASSWORD)
                obj.CreateVaultPasswordFile(VaultPasswordFilePath, self.lv_ans_if_info['ANSIBLE_VAULT_PASSWORD'])
                # AnsibleのPATHは指定無し
                retAry = obj.Vault("",
                                   self.getAnsibleExecuteUser(),
                                   VaultPasswordFilePath,
                                   in_pass,
                                   "",
                                   self.lv_engine_virtualenv_name,
                                   True)
                ret = retAry[0]
                out_vaultpass = retAry[1]
                if ret is False:
                    # ansible-vault失敗
                    msgstr = g.appmsg.get_api_message("MSG-10646", [in_system_id])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    # 標準エラー出力を出力
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), out_vaultpass)
                    return False
                self.lv_vault_pass_list[in_pass] = out_vaultpass
            out_vaultpass = " !vault |" + out_vaultpass
        else:
            out_vaultpass = in_vaultpass

        # ansible-vaultで暗号化された文字列のインデントを調整
        out_vaultpass = obj.setValutPasswdIndento(out_vaultpass, in_indento)

        return out_vaultpass

    def makeAnsibleVaultValue(self, in_pass, in_vaultpass, in_indento, in_assign_id):
        """
        指定文字列をansible-vaultで暗号化する
        Arguments:
            in_pass:        暗号化したい文字列
            in_vaultpass:   暗号化されている場合の暗号化文字列
            in_indento:     暗号化文字列に付加するインデント
            in_assign_id:   代入値管理項番
        Returns:
            [ 暗号化された文字列]
        """
        out_vaultpass = ""

        # unuse update_key = "key_{}_{}".format(in_assign_id, in_pass)

        obj = AnsibleVault()

        if not in_vaultpass:

            # パスワードが暗号化されているか判定
            if in_pass in self.lv_vault_value_list:
                # 既に暗号化されている場合
                out_vaultpass = self.lv_vault_value_list[in_pass]
            else:
                # in_passはrot13+base64で暗号化されている
                # unuse enc_in_pass = in_pass
                VaultPasswordFilePath = obj.CreateVaultPasswordFilePath()
                # in_passはrot13+base64で暗号化されている
                if not self.lv_ans_if_info['ANSIBLE_VAULT_PASSWORD']:
                    self.lv_ans_if_info['ANSIBLE_VAULT_PASSWORD'] = ky_encrypt(AnscConst.DF_ANSIBLE_VAULT_PASSWORD)
                obj.CreateVaultPasswordFile(VaultPasswordFilePath, self.lv_ans_if_info['ANSIBLE_VAULT_PASSWORD'])
                # AnsibleのPATHは指定無し
                retAry = obj.Vault("",
                                   self.getAnsibleExecuteUser(),
                                   VaultPasswordFilePath,
                                   in_pass,
                                   "",
                                   self.lv_engine_virtualenv_name, True)
                ret = retAry[0]
                out_vaultpass = retAry[1]
                if ret is False:
                    # ansible-vault失敗
                    msgstr = g.appmsg.get_api_message("MSG-10626", [in_assign_id])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    # 標準エラー出力を出力
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), out_vaultpass)
                    return False
                self.lv_vault_value_list[in_pass] = out_vaultpass
            out_vaultpass = " !vault |" + out_vaultpass
        else:
            # このルートは基本的デットルート
            out_vaultpass = in_vaultpass

        # ansible-vaultで暗号化された文字列のインデントを調整
        out_vaultpass = obj.setValutPasswdIndento(out_vaultpass, in_indento)

        return out_vaultpass

    def getAnsibleExecuteUser(self):
        """
        ansibleコマンド実行ユーザー取得
        Arguments:
        Returns:
            ansibleコマンド実行ユーザー
        """
        return self.ansible_exec_user

    def setAnsibleExecuteUser(self, user_name):
        """
        ansibleコマンド実行ユーザー退避
        Arguments:
            ansibleコマンド実行ユーザー
        Returns:
            なし
        """
        if user_name:
            # 非コンテナ版ではuser名の指定がない場合はrootにする。
            # コンテナ版ではuser名の指定出来ないのでコメントなする
            # user_name = 'root'
            user_name = ""
        self.ansible_exec_user = user_name

    def HostVarEdit(self, val, NumPadding):
        """
        ホスト変数の具体値を指定サイズでパディングする
        Arguments:
            val:
            NumPadding: パディングサイズ
        Returns:
            パディングされたホスト変数の具体値
        """
        # josn形式(複数具体値)か判定
        if self.isJsonString(val) is False:
            val = self.MultilineValueEdit(val, NumPadding)
        else:
            val = self.MultiValueEdit(val, NumPadding)
        return val

    def MultilineValueEdit(self, val, NumPadding):
        """
        複数行複数具体値にインデントを設定する。 (ArrayTypeValue_decode)
        Arguments:
            jsonstr: 複数行複数具体値
            NumPadding: パディング文字数
        Returns:
            複数行複数具体値にインデントを設定した文字列
        """
        # 具体値がNoneの場合に空白に置換える
        if not val:
            val = ""
            return val
        strpad = "".ljust(NumPadding)
        if len(val.split("\n")) > 1:
            val = val.replace("\n", "\n" + strpad)
        return val

    def chkMultilineValue(self, val):
        """
        Pioneerの場合に具体値が複数行でないか判定
        Arguments:
            val: 具体値
        Returns:
            True/False
        """
        if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
            if not val:  # 空の場合のガード
                return True
            if len(val.split("\n")) > 1:
                return False
        return True

    def makeMultilineValue(self, val):
        """
        複数行具体値の場合に複数行の扱いの記号を付ける
        Arguments:
            val: 複数行具体値
        Returns:
            複数行の扱いの記号を付加した具体値
        """
        if not val:
            return val
        if len(val.split("\n")) > 1:
            val = "|-\n" + val
        return val

    def ArrayTypeValue_encode(seld, mt_jsonstr, val):
        """
        複数行具体値をjson形式で収める
        Arguments:
            mt_jsonstr: 現在の具体値
            val: 追加する具体値
        Returns:
            複数行具体値の数, 追加結果
        """
        if len(mt_jsonstr) == 0:
            ary = []
        else:
            ary = json.loads(mt_jsonstr)

        ary.append(val)
        mt_jsonstr = json.dumps(ary)

        return len(ary), mt_jsonstr

    def MultiValueEdit(self, jsonstr, NumPadding):
        """
        JSON文字列内の複数具体値にインデントを設定する。
            ArrayTypeValue_decode
        Arguments:
            jsonstr: JSON文字列
            NumPadding: パディング文字数
        Returns:
            複数具体にインデントを設定したJSON文字列
        """
        val = ""
        strpad = "".ljust(NumPadding)
        indstrpad = "".ljust(NumPadding + 2)
        # 具体値が空の場合
        ary = json.loads(jsonstr)
        for line in ary:
            # 具体値が空か判定
            if line:
                # 空以外
                if len(line.split("\n")) != 1:
                    line = line.replace("\n", "\n" + indstrpad)
                    val += "\n{}- {}".format(strpad, line)
                else:
                    val += "\n{}- {}".format(strpad, line)
            else:
                # 空
                line = ""
                val += "\n{}- {}".format(strpad, line)

        return val

    def isJsonString(self, json_str):
        """
        指定文字列がJSON形式か判定する (isArrayTypeValue)
        Arguments:
            string: 文字列
        Returns:
            True/False
        """
        try:
            ret = json.loads(json_str)
            if isinstance(ret, list) is False:
                return False
            return True
        except Exception:
            # #2199 list形式か判定しているだけなのでログ出力不要
            return False

    def getAnsible_vault_host_var_file(self, in_hostname):
        """
        暗号化されているホスト変数定義ファイルパスを取得
        Arguments:
            in_hostname: ホスト名
        Returns:
            暗号化されているホスト変数定義ファイルパス
        """
        file = "{}/{}".format(self.getAnsible_vault_hosts_vars_Dir(), in_hostname)
        return file

    def CreateDirectoryForCollectionProcess(self, ina_hostinfolist, mt_host_vars, mt_pioneer_template_host_vars):
        """
        収集機能用ディレクトリ生成
        Arguments:
            ina_hostinfolist:   機器一覧ホスト情報
                                {HOST_NAME:{機器一覧各項目:xx, ....}} ...
            mt_host_vars: ホスト変数定義配列
            mt_pioneer_template_host_vars: pioneer tamplate用 ホスト変数定義配列
        Returns:
            True, mt_host_vars mt_pioneer_template_host_vars
        """
        driver_list = {}
        driver_list[self.AnscObj.DF_LEGACY_DRIVER_ID] = 'ansible/legacy'
        driver_list[self.AnscObj.DF_PIONEER_DRIVER_ID] = 'ansible/pioneer'
        driver_list[self.AnscObj.DF_LEGACY_ROLE_DRIVER_ID] = 'ansible/legacy_role'

        # ドライバ種別
        driver_id = self.getAnsibleDriverID()
        # 作業番号
        execute_no = self.lv_exec_no
        # データリレイストレージパス(ITA)
        ita_base_dir = self.getAnsibleBaseDir('ANSIBLE_SH_PATH_ITA')
        # データリレイストレージパス(ansible)
        ans_base_dir = self.getAnsibleBaseDir('ANSIBLE_SH_PATH_ANS')

        for host_name, hostinfo in ina_hostinfolist.items():
            host_var_name = self.AnscObj.ITA_SP_VAR_IN_PARAM_DIR_EPC

            mkdir = "{}/{}/{}/in/_parameters/{}".format(ita_base_dir, driver_list[driver_id], execute_no, host_name)
            scpsrcdir = "{}/{}/{}/in/_parameters".format(ita_base_dir, driver_list[driver_id], execute_no)
            if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_ANSIBLE:  # enomomto AGの場合を追加
                host_var_vaule = "{}/{}/{}/in/_parameters".format(ans_base_dir, driver_list[driver_id], execute_no)

            elif self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG:  # enomomto AGの場合を追加
                host_var_vaule = "_parameters"

            else:
                host_var_vaule = "{}/_parameters".format(self.getTowerProjectDirPath("ExastroPath"))
                self.setTowerProjectsScpPath(self.AnscObj.DF_SCP_IN_PARAMATERS_ITA_PATH, scpsrcdir)
                self.setTowerProjectsScpPath(self.AnscObj.DF_SCP_IN_PARAMATERS_TOWER_PATH, host_var_vaule)

            # ディレクトリ生成
            self.makeDir(mkdir)

            if host_name not in mt_host_vars:
                mt_host_vars[host_name] = {}
            mt_host_vars[host_name][host_var_name] = host_var_vaule
            if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                if host_name not in mt_pioneer_template_host_vars:
                    mt_pioneer_template_host_vars[host_name] = {}
                mt_pioneer_template_host_vars[host_name][host_var_name] = host_var_vaule

            host_var_name = self.AnscObj.ITA_SP_VAR_OUT_PARAM_DIR

            mkdir = "{}/{}/{}/out/_parameters/{}".format(ita_base_dir, driver_list[driver_id], execute_no, host_name)
            host_var_vaule = "{}/{}/{}/out/_parameters".format(ita_base_dir, driver_list[driver_id], execute_no)

            if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_ANSIBLE: # enomomto AGの場合を追加
                host_var_vaule = "{}/{}/{}/out/_parameters".format(ans_base_dir, driver_list[driver_id], execute_no)

            elif self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG: # enomomto AGの場合を追加
                host_var_vaule = "/outdir/out/_parameters".format(ans_base_dir, driver_list[driver_id], execute_no)
            else:
                host_var_vaule = "{}/{}/_parameters".format(self.getTowerProjectDirPath("ExastroPath"), self.LC_ITA_OUT_DIR)

            # ディレクトリ生成
            self.makeDir(mkdir)

            if host_name not in mt_host_vars:
                mt_host_vars[host_name] = {}
            mt_host_vars[host_name][host_var_name] = host_var_vaule
            if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                if host_name not in mt_pioneer_template_host_vars:
                    mt_pioneer_template_host_vars[host_name] = {}
                mt_pioneer_template_host_vars[host_name][host_var_name] = host_var_vaule

            host_var_name = self.AnscObj.ITA_SP_VAR_IN_PARAM_FILE_DIR_EPC

            mkdir = "{}/{}/{}/in/_parameters_file/{}".format(ita_base_dir, driver_list[driver_id], execute_no, host_name)
            scpsrcdir = "{}/{}/{}/in/_parameters_file".format(ita_base_dir, driver_list[driver_id], execute_no)
            host_var_vaule = "{}/{}/{}/in/_parameters_file".format(ita_base_dir, driver_list[driver_id], execute_no)

            if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_ANSIBLE: # enomomto AGの場合を追加
                host_var_vaule = "{}/{}/{}/in/_parameters_file".format(ans_base_dir, driver_list[driver_id], execute_no)

            elif self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG: # enomomto AGの場合を追加
                host_var_vaule = "_parameters_file"

            else:
                host_var_vaule = "{}/_parameters_file".format(self.getTowerProjectDirPath("ExastroPath"))
                self.setTowerProjectsScpPath(self.AnscObj.DF_SCP_IN_PARAMATERS_FILE_ITA_PATH, scpsrcdir)
                self.setTowerProjectsScpPath(self.AnscObj.DF_SCP_IN_PARAMATERS_FILE_TOWER_PATH, host_var_vaule)

            # ディレクトリ存在確認
            self.makeDir(mkdir)

            if host_name not in mt_host_vars:
                mt_host_vars[host_name] = {}
            mt_host_vars[host_name][host_var_name] = host_var_vaule
            if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                if host_name not in mt_pioneer_template_host_vars:
                    mt_pioneer_template_host_vars[host_name] = {}
                mt_pioneer_template_host_vars[host_name][host_var_name] = host_var_vaule

            host_var_name = self.AnscObj.ITA_SP_VAR_OUT_PARAM_FILE_DIR

            mkdir = "{}/{}/{}/out/_parameters_file/{}".format(ita_base_dir, driver_list[driver_id], execute_no, host_name)
            host_var_vaule = "{}/{}/{}/out/_parameters_file".format(ita_base_dir, driver_list[driver_id], execute_no)
            if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_ANSIBLE: # enomomto AGの場合を追加
                host_var_vaule = "{}/{}/{}/out/_parameters_file".format(ans_base_dir, driver_list[driver_id], execute_no)

            elif self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG: # enomomto AGの場合を追加
                host_var_vaule = "/outdir/out/_parameters_file"

            else:
                host_var_vaule = "{}/{}/_parameters_file".format(self.getTowerProjectDirPath("ExastroPath"), self.LC_ITA_OUT_DIR)

            # ディレクトリ存在確認
            self.makeDir(mkdir)

            if host_name not in mt_host_vars:
                mt_host_vars[host_name] = {}
            mt_host_vars[host_name][host_var_name] = host_var_vaule
            if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                if host_name not in mt_pioneer_template_host_vars:
                    mt_pioneer_template_host_vars[host_name] = {}
                mt_pioneer_template_host_vars[host_name][host_var_name] = host_var_vaule

        return True, mt_host_vars, mt_pioneer_template_host_vars

    def makeDir(self, mkdir):
        """
        ディレクトリ生成
        Arguments:
            mkdir: ディレクトリパス
        Returns:
            なし
        """
        dirsLlist = mkdir.split("/")
        dirsLlist.pop(0)
        makeDirName = ""
        for dir in dirsLlist:
            makeDirName += "/" + dir
            if os.path.isdir(makeDirName) is False:
                os.mkdir(makeDirName)
                os.chmod(makeDirName, 0o777)

    def CreateMovementStatusFileVariables(self, ina_hostinfolist, mt_host_vars, mt_pioneer_template_host_vars):
        """
        Movementステータスファイル変数生成
        Arguments:
            ina_hostinfolist:   機器一覧ホスト情報
                                {HOST_NAME:{機器一覧各項目:xx, ....}} ...
            mt_host_vars:       ホスト変数定義配列
            mt_pioneer_template_host_vars: pioneer tamplate用 ホスト変数定義配列
        Returns:
            True, mt_host_vars mt_pioneer_template_host_vars
        """
        driver_list = {}
        driver_list[self.AnscObj.DF_LEGACY_DRIVER_ID] = 'ansible/legacy'
        driver_list[self.AnscObj.DF_PIONEER_DRIVER_ID] = 'ansible/pioneer'
        driver_list[self.AnscObj.DF_LEGACY_ROLE_DRIVER_ID] = 'ansible/legacy_role'

        # ドライバ種別
        driver_id = self.getAnsibleDriverID()
        # 作業番号
        execute_no = self.lv_exec_no
        # データリレイストレージパス(ITA)
        # unuse ita_base_dir = self.getAnsibleBaseDir('ANSIBLE_SH_PATH_ITA')
        # データリレイストレージパス(ansible)
        ans_base_dir = self.getAnsibleBaseDir('ANSIBLE_SH_PATH_ANS')

        for host_name, hostinfo in ina_hostinfolist.items():

            host_var_name = self.AnscObj.ITA_SP_VAR_MOVEMENT_STS_FILE

            host_var_vaule = "{}/{}/{}/out/MOVEMENT_STATUS_FILE".format(ans_base_dir, driver_list[driver_id], execute_no)
            if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_ANSIBLE: # enomomto AGの場合を追加
                host_var_vaule = "{}/{}/{}/out/MOVEMENT_STATUS_FILE".format(ans_base_dir, driver_list[driver_id], execute_no)

            elif self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG: # enomomto AGの場合を追加
                host_var_vaule = "/outdir/out/MOVEMENT_STATUS_FILE"

            else:
                host_var_vaule = "{}/{}/MOVEMENT_STATUS_FILE".format(self.getTowerProjectDirPath("ExastroPath"), self.LC_ITA_OUT_DIR)

            if host_name not in mt_host_vars:
                mt_host_vars[host_name] = {}
            mt_host_vars[host_name][host_var_name] = host_var_vaule
            if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                if host_name not in mt_pioneer_template_host_vars:
                    mt_pioneer_template_host_vars[host_name] = {}
                mt_pioneer_template_host_vars[host_name][host_var_name] = host_var_vaule

        return True, mt_host_vars, mt_pioneer_template_host_vars

    def CreatePioneerOtherVariables(self, ina_hostinfolist, mt_host_vars):
        """
        Pioneer LAMG用 ローカル変数設定
        Arguments:
            ina_hostinfolist:   機器一覧ホスト情報
                                {HOST_NAME:{機器一覧各項目:xx, ....}} ...
            mt_host_vars:       ホスト変数定義配列
        Returns:
            True, mt_host_vars
        """
        if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
            for host_name, hostinfo in ina_hostinfolist.items():
                if host_name not in ina_hostinfolist:
                    mt_host_vars[host_name] = {}
                mt_host_vars[host_name][self.LC_ANS_PIONEER_LANG_VAR_NAME] = hostinfo['PIONEER_LANG_STRING']

                path = "{}/{}".format(self.setAnsibleSideFilePath(self.getAnsible_original_dialog_files_Dir(), self.LC_ITA_TMP_DIR), host_name)
                if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG: # enomomto AGの場合を追加
                    path = Replace_HostVrasFilepath("tmp", path, "outdir/tmp")
                else:
                    pass
                mt_host_vars[host_name][self.LC_ANS_PIONEER_ORIGINAL_EXEC_FILE_DIR] = path

                path = "{}/{}".format(self.setAnsibleSideFilePath(self.getAnsible_vault_hosts_vars_Dir(), self.LC_ITA_TMP_DIR), host_name)
                if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG: # enomomto AGの場合を追加
                    path = Replace_HostVrasFilepath("tmp", path, "outdir/tmp")
                else:
                    pass
                mt_host_vars[host_name][self.LC_ANS_PIONEER_ENCODE_COLUMN_ENCODE_VALUE_FILE] = path

                mt_host_vars[host_name][self.LC_ANS_PIONEER_SSH_PHRASES_FLG] = '"No"'
                if self.lv_ans_if_info['ANSIBLE_EXEC_MODE'] == self.AnscObj.DF_EXEC_MODE_AG: # Ansible Execution Agentで実行
                   if ina_hostinfolist[host_name]['LOGIN_AUTH_TYPE'] == self.AnscObj.DF_LOGIN_AUTH_TYPE_KEY_PP_USE:
                       mt_host_vars[host_name][self.LC_ANS_PIONEER_SSH_PHRASES_FLG] = '"Yes"'
                       mt_host_vars[host_name][self.LC_ANS_PIONEER_SSH_PHRASES] = self.ky_pioneer_encrypt(ina_hostinfolist[host_name]['SSH_KEY_FILE_PASSPHRASE'])
        return True, mt_host_vars

    def CreateOperationVariables(self, in_operation_id, ina_hostinfolist, mt_host_vars, mt_pioneer_template_host_vars):
        """
        オペレーション用 予約変数設定
        Arguments:
            in_operation_id:                オペレーションID
            ina_hostinfolist:               機器一覧ホスト情報
                                            {HOST_NAME:{機器一覧各項目:xx, ....}} ...
            mt_host_vars:                   ホスト変数定義配列
            mt_pioneer_template_host_vars:  pioneer tamplate用 ホスト変数定義配列
        Returns:
            Bool, mt_host_vars, mt_pioneer_template_host_vars
        """
        sql = '''
        SELECT
            OPERATION_NAME,
            DATE_FORMAT(OPERATION_DATE, '%%Y/%%m/%%d %%H:%%i') OPERATION_DATE
        FROM
            T_COMN_OPERATION
        WHERE
            OPERATION_ID = %s
                '''
        rows = self.lv_objDBCA.sql_execute(sql, [in_operation_id])
        if len(rows) != 1:
            msgstr = g.appmsg.get_api_message("MSG-10178", [os.path.basename(inspect.currentframe().f_code.co_filename),
                                                            str(inspect.currentframe().f_lineno)])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, mt_host_vars, mt_pioneer_template_host_vars

        operationStr = ""
        operationStr = "{}_{}:{}".format(rows[0]['OPERATION_DATE'], in_operation_id, rows[0]['OPERATION_NAME'])

        # オペレーション用の予約変数生成
        for host_name, hostinfo in ina_hostinfolist.items():
            if host_name not in mt_host_vars:
                mt_host_vars[host_name] = {}
            mt_host_vars[host_name][self.AnscObj.ITA_SP_VAR_OPERATION_VAR_NAME] = operationStr

            if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                if host_name not in mt_pioneer_template_host_vars:
                    mt_pioneer_template_host_vars[host_name] = {}
                mt_pioneer_template_host_vars[host_name][self.AnscObj.ITA_SP_VAR_OPERATION_VAR_NAME] = operationStr
        return True, mt_host_vars, mt_pioneer_template_host_vars

    def CreateSSHAgentConfigInfoFile(self, file, hostname, ssh_key_file, pssphrase):
        """
        ssh-agentの設定に必要な情報を一時ファイルに出力
        Arguments:
            file:          一時ファイル名
            hostname:      ホスト名
            ssh_key_file:  秘密鍵ファイル
            pssphrase      パスフレーズ
        Returns:
            True/False
        """

        row = "{}\t{}\t{}\t\n".format(hostname, ssh_key_file, pssphrase)
        # #2079 /storage配下は/tmpを経由してアクセスする
        obj = storage_write()
        obj.open(file, 'a')
        obj.write(row)
        obj.close()

        return True

    def setFileUploadCloumnFileEnv(self, row):
        """
        代入値管理の具体値がファイルアップロードカラムの場合
        アップロードされているファイルを所定のフォルダーにコピーする。
        Arguments:
            row:            代入値管理の情報
        Returns:
            True/False
        """

        if not row['VARS_ENTRY_FILE']:
            return True

        if self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_DRIVER_ID:
            srcFilePath = "{}/{}/{}".format(getFileupLoadColumnPath('20207', 'file'), row['ASSIGN_ID'], row['VARS_ENTRY_FILE'])
        elif self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
            srcFilePath = "{}/{}/{}".format(getFileupLoadColumnPath('20309', 'file'), row['ASSIGN_ID'], row['VARS_ENTRY_FILE'])
        elif self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_ROLE_DRIVER_ID:
            srcFilePath = "{}/{}/{}".format(getFileupLoadColumnPath('20409', 'file'), row['ASSIGN_ID'], row['VARS_ENTRY_FILE'])

        if os.path.isfile(srcFilePath) is False:
            msgstr = g.appmsg.get_api_message("MSG-10171", [row['ASSIGN_ID']])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False

        ITADestDirPath = "{}/{}".format(self.getAnsible_upload_files_Dir(), row['ASSIGN_ID'])

        AnsDestDirPath = self.setAnsibleSideFilePath(ITADestDirPath, self.LC_ITA_IN_DIR)
        if os.path.isdir(ITADestDirPath) is False:
            os.mkdir(ITADestDirPath)
            os.chmod(ITADestDirPath, 0o777)

        ITADestDirPath += "/" + row['VARS_ENTRY_FILE']
        AnsDestDirPath += "/" + row['VARS_ENTRY_FILE']

        shutil.copyfile(srcFilePath, ITADestDirPath)

        # 実行エンジンがAnsible Agentの場合、ホスト変数のパスを加工する
        if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG:
            AnsDestDirPath = Replace_HostVrasFilepath("in", AnsDestDirPath)

        row['VARS_ENTRY'] = AnsDestDirPath
        row['VARS_ENTRY_FILE'] = ""
        return True

    def AnsibleEnginVirtualenvPathCheck(self):
        """
        仮想環境存在確認
        2.0ではコンテナ版のみなので空処理にしておく
        Arguments:
            なし
        Returns:
            True
        """
        return True

    def getTowerProjectDirPath(self, PathId):
        """
        Towerプロジェクトパス取得
        Arguments:
            PathId: TowerPath/ExastroPath
        Returns:
            Towerプロジェクトパス
        """
        # lv_TowerInstanceDirPath["TowerPath"]   "Tower Projects Ptah
        # lv_TowerInstanceDirPath["ExastroPath"] "Tower Exastro Projects Ptah
        return self.lv_TowerInstanceDirPath[PathId]

    def getTowerInstanceDirPath(self):
        """
        Tower/Exastorプロジェクトパス取得()
        Arguments:
            なし
        Returns:
            Towerプロジェクトパス
        """
        return self.lv_TowerInstanceDirPath

    def setTowerProjectDirPath(self):
        """
        AAC側のProjectディレクトリパス生成
        Arguments:
            なし
        Returns:
            True
        """
        gobj = AnscConst()

        if self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_DRIVER_ID:
            driver_name = "ita_legacy_executions"
        elif self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
            driver_name = "ita_pioneer_executions"
        elif self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_ROLE_DRIVER_ID:
            driver_name = "ita_legacy_role_executions"

        self.lv_TowerInstanceDirPath = {}

        # /var/lib/awx/projects/{{ driver_name }}-{{ 作業番号 }}
        self.lv_TowerInstanceDirPath["TowerPath"] = "{}/{}_{}".format(gobj.DF_TowerProjectPath, driver_name, self.lv_exec_no)
        # /var/lib/exastro/{{ driver_name }}-{{ 作業番号 }}
        self.lv_TowerInstanceDirPath["ExastroPath"] = "{}/{}_{}".format(gobj.DF_TowerExastroProjectPath, driver_name, self.lv_exec_no)

        return True

    def setAnsibleSideFilePath(self, in_Path, in_DirId):
        """
        指定ファイルのパスをAnsible側のパスに変更
        Arguments:
            in_Path: ファイルのパス
            in_DirId: ディレクトリ
        Returns:
            Upd_Path Ansible側のパス
        """
        if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_ANSIBLE:
            Upd_Path = in_Path.replace(self.getAnsibleBaseDir('ANSIBLE_SH_PATH_ITA'), self.getAnsibleBaseDir('ANSIBLE_SH_PATH_ANS'))
        elif self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG:  # enomomto AGの場合を追加
            Upd_Path = in_Path
        else:
            Upd_Path = self.setAnsibleTowerSideFilePath(in_Path, in_DirId)

        return Upd_Path

    def setAnsibleTowerSideFilePath(self, in_Path, in_DirId):
        """
        指定ファイルのパスをTower側のパスに変更
        Arguments:
            in_Path: ファイルのパス
            in_DirId: ディレクトリ
        Returns:
            Upd_Path Tower側のパス
        """
        # ホスト変数定義ファイルに記載するパスなのでAnsible側のストレージパスに変更
        if in_DirId == self.LC_ITA_OUT_DIR:
            Aft_Path = "{}/{}".format(self.getTowerProjectDirPath("ExastroPath"), in_DirId)
            Upd_Path = in_Path.replace(self.getAnsible_out_Dir(), Aft_Path)
        elif in_DirId == self.LC_ITA_IN_DIR:
            Aft_Path = self.getTowerProjectDirPath("ExastroPath")
            Upd_Path = in_Path.replace(self.getAnsible_in_Dir(), Aft_Path)
        elif in_DirId == self.LC_ITA_TMP_DIR:
            Aft_Path = "{}/{}".format(self.getTowerProjectDirPath("ExastroPath"), in_DirId)
            Upd_Path = in_Path.replace(self.getAnsible_tmp_Dir(), Aft_Path)

        return Upd_Path

    def setTowerProjectsScpPath(self, id, path):
        """
        AACへのSCPパス退避
        Arguments:
            id:  SCPパスID
            path: AACへのSCPパス
        Returns:
            なし
        """
        self.vg_TowerProjectsScpPathArray[id] = path

    def getTowerProjectsScpPath(self):
        """
        AACへのSCPパス取得
        Arguments:
            なし
        Returns:
            AACへのSCPパス
        """
        return self.vg_TowerProjectsScpPathArray

    def CopyAnsibleConfigFile(self):
        """
        Movement一覧に登録されているansible.cnfを所定の場所にコピーする。
        Arguments:
            なし
        Returns:
            True/False
        """
        src_file = "{}/{}/{}".format(getMovementAnsibleCnfUploadDirPath(), self.run_pattern_id, self.lv_ansible_cnf_file)
        dest_file = "{}/{}".format(self.getAnsible_in_Dir(), "/ansible.cfg")
        if os.path.isfile(src_file) is False:
            msgstr = g.appmsg.get_api_message("MSG-10068", [self.run_pattern_id])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False
        shutil.copyfile(src_file, dest_file)
        return True

    def CopysshAgentExpectfile(self):
        """
        Ansible実行時、aah-agentで必要なexpectファイルを所定の場所にコピーする。
        Arguments:
            なし
        Returns:
            True/False
        """
        src_file = "/exastro/common_libs/ansible_driver/shells/{}".format(self.LC_ANS_SSHAGENTEXPECT_FILE)
        dest_file = "{}/.{}".format(self.getTemporary_file_Dir(), self.LC_ANS_SSHAGENTEXPECT_FILE)
        if os.path.isfile(dest_file) is False:
            shutil.copyfile(src_file, dest_file)
        return True

    def CreateHostvarsfiles(self, ina_host_vars, ina_pioneer_template_host_vars,
                            ina_host_child_vars, ina_DB_child_vars_master):
        """
        ホスト変数ファイルを作成する。
        Arguments:
            ina_host_vars:          ホスト変数配列
                                    [ホスト名][ 変数名 ]=>具体値
            ina_pioneer_template_host_vars:
                                    ホスト変数配列 (passwordcolumnの項目がansible-vaultで暗号化されている)
                                    [ipaddress][ 変数名 ]=>具体値
            ina_host_child_vars:    配列変数一覧返却配列(変数一覧に配列変数含む)
                                    [ホスト名(IP)][ 変数名 ][列順序][メンバー変数]=[具体値]
            ina_DB_child_vars_master:
                                    メンバー変数マスタの配列変数のメンバー変数リスト返却
                                    [変数名][メンバー変数名]=0
        Returns:
            True/False
        """
        # ホスト分繰返し
        for host_name in ina_host_vars.keys():
            host_vars_file = self.getAnsible_host_var_file(host_name)
            host_vars_list = ina_host_vars[host_name]

            host_vars_list = {}
            if len(ina_host_vars[host_name]) != 0:
                host_vars_list = ina_host_vars[host_name]

            # ホスト変数定義ファイル作成
            if self.CreateHostvarsfile("VAR", host_name, host_vars_file, host_vars_list) is False:
                return False

            # Pioneer template用ホスト変数作成
            if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                pioneer_template_vars_list = {}
                if len(ina_pioneer_template_host_vars[host_name]) != 0:
                    pioneer_template_vars_list = ina_pioneer_template_host_vars[host_name]

                host_vars_file = self.getAnsible_pioneer_template_host_var_file(host_name)
                if self.CreatePioneerTemplateHostvarsfile("VAR", host_name,
                                                          host_vars_file, pioneer_template_vars_list) is False:
                    return False
        return True

    def CreateHostvarsfile(self, in_var_type, in_host_name, in_file_name, ina_var_list, in_mode="w"):
        """
        ホスト変数定義ファイル(1ホスト)を作成する。
        Arguments:
          in_var_type:      登録対象の変数タイプ
                            "VAR"/"CPF"/"TPF"/"CMT"
          in_host_name:     ホスト名
          in_file_name:     ホスト変数定義ファイル名
          ina_var_list:     ホスト変数配列
                            legacyの場合
                            [ 変数名 ]=>具体値
                            pioneerの場合
                            [対話ファイル変数名]=対話ファイル名
          in_mode:          書込モード
                            "w":上書   デフォルト
                            "a":追加
        Returns:
            True/False
        """
        var_str = ""
        if in_var_type != "CMT":
            for var, val in ina_var_list.items():
                keystr = "{}_{}".format(in_host_name, var)
                if keystr in self.lv_parent_vars_list:
                    continue
                self.lv_parent_vars_list[keystr] = 0

                # 機器一覧のプロトコルが未登録の場合を判定
                if self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_DRIVER_ID and \
                   var == self.AnscObj.ITA_SP_VAR_ANS_PROTOCOL_VAR_NAME and \
                   val == self.LC_ANS_UNDEFINE_NAME:
                    # __loginprotocol__をホスト変数に出力しない
                    continue

                # ホスト変数ファイルのレコード生成
                # 変数名: 具体値
                # 機器一覧のパスワードをansible-vaultで暗号化
                if var == self.AnscObj.ITA_SP_VAR_ANS_PASSWD_VAR_NAME and val != self.LC_ANS_UNDEFINE_NAME:
                    if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                        # rot13+base64で暗号化
                        val = self.ky_pioneer_encrypt(val)
                    else:
                        # ansible-vaultで暗号化された文字列のインデントを調整
                        indento_sp4 = "".ljust(4)

                        login_pw_ansible_vault = ""
                        make_vaultpass = self.makeAnsibleVaultPassword(val,
                                                                       login_pw_ansible_vault,
                                                                       indento_sp4,
                                                                       self.lv_hostinfolist[in_host_name]['SYSTEM_ID'])
                        if make_vaultpass is False:
                            return False

                        val = make_vaultpass
                else:
                    # 複数行具体値のyaml書式対応
                    NumPadding = 2
                    val = self.HostVarEdit(val, NumPadding)

                var_str += "{}: {}\n".format(var, val)

                if in_var_type == "VAR":
                    # テンプレートファイル内の変数具体値登録をチェックする設定にする。
                    temp_vars_chk = True

                    # 具体値にコピー/テンプレート変数が使用されているか判定する。
                    # 変数の具体値にテンプレート変数かコピー変数が設定されている場合
                    # 各変数に紐づくファイルを所定のディレクトリにコピーする。
                    # テンプレート変数の場合、テンプレートファイル内に変数がある場合
                    # 変数の具体値が登録されているか判定する。
                    retAry = self.CheckConcreteValueIsVar(temp_vars_chk,
                                                          val,
                                                          ina_var_list,
                                                          in_host_name,
                                                          self.lv_tpf_vars_list,
                                                          self.lv_cpf_vars_list)
                    ret = retAry[0]
                    self.lv_tpf_vars_list = retAry[1]
                    self.lv_cpf_vars_list = retAry[2]
                    if ret is False:
                        return False
        # ファイル管理とテンプレート管理の変数を使用していないケースは CPF/TPF で
        # このモジュールが呼ばれない。
        # グローバル変数の情報をホスト変数ファイルに出力するタイミングでファイル管理とテンプレート管理の変数を出力する。
        if in_var_type == "CMT":
            # グローバル変数をホスト変数ファイルに登録する。
            for var, val in self.lva_global_vars_list.items():
                # Playbookで使用しているグローバル変数のみを対象にする。
                if var in self.lv_use_gbl_vars_list:
                    keystr = "{}_{}".format(in_host_name, var)
                    if keystr in self.lv_parent_vars_list:
                        continue
                    self.lv_parent_vars_list[keystr] = 0

                    # ホスト変数ファイルのレコード生成
                    # 変数名: 具体値
                    # 複数行具体値の場合に複数行の扱い記号を付ける
                    edit_val = self.makeMultilineValue(val)
                    NumPadding = 2
                    out_val = self.MultilineValueEdit(edit_val, NumPadding)
                    var_str = var_str + "%s: %s\n" % (var, out_val)

            # 変数の具体値に使用しているテンプレート変数の情報をホスト変数ファイルに出力
            if in_host_name in self.lv_tpf_vars_list:
                for var, val in self.lv_tpf_vars_list[in_host_name].items():
                    keystr = "{}_{}".format(in_host_name, var)
                    if keystr in self.lv_parent_vars_list:
                        continue
                    self.lv_parent_vars_list[keystr] = 0

                    var_str = var_str + "%s: %s\n" % (var, val)

            # 変数の具体値に使用しているコピー変数の情報をホスト変数ファイルに出力
            if in_host_name in self.lv_cpf_vars_list:
                for var, val in self.lv_cpf_vars_list[in_host_name].items():
                    keystr = "{}_{}".format(in_host_name, var)
                    if keystr in self.lv_parent_vars_list:
                        continue
                    self.lv_parent_vars_list[keystr] = 0

                    var_str = var_str + "%s: %s\n" % (var, val)

        if var_str:
            # #2079 /storage配下は/tmpを経由してアクセスする
            obj = storage_write()
            obj.open(in_file_name, in_mode)

            obj.write(var_str)

            obj.close()

        return True

    def CreatePioneerTemplateHostvarsfile(self,
                                          in_var_type,
                                          in_host_name,
                                          in_file_name,
                                          ina_var_list,
                                          in_mode="w"):
        """
        ホスト変数ファイルを作成する。
        Arguments:
          in_var_type:      登録対象の変数タイプ
                            "VAR"/"CPF"/"TPF"/"CMT"
          in_host_name:     ホスト名
          in_file_name:     ホスト変数定義ファイル名
          ina_var_list:     ホスト変数配列
                            [対話ファイル変数名]=対話ファイル名
          in_mode:          書込モード
                            "w":上書   デフォルト
                            "a":追加
        Returns:
          True/False
        """
        var_str = ""
        if in_var_type != "CMT":
            for var, val in ina_var_list.items():
                # if len(self.lv_pioneer_template_parent_vars_list[in_host_name][var]) != 0:
                if self.nestArrayDefineCheck(self.lv_pioneer_template_parent_vars_list, in_host_name, var) is True:
                    continue
                if in_host_name not in self.lv_pioneer_template_parent_vars_list:
                    self.lv_pioneer_template_parent_vars_list[in_host_name] = {}
                self.lv_pioneer_template_parent_vars_list[in_host_name][var] = 0

                # 機器一覧のプロトコルが未登録の場合を判定
                if self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_DRIVER_ID and \
                   var == self.AnscObj.ITA_SP_VAR_ANS_PROTOCOL_VAR_NAME and \
                   val == self.LC_ANS_UNDEFINE_NAME:
                    #  __loginprotocol__をホスト変数に出力しない
                    continue
                # 機器一覧のパスワードをansible-vaultで暗号化
                if var == self.AnscObj.ITA_SP_VAR_ANS_PASSWD_VAR_NAME and val != self.LC_ANS_UNDEFINE_NAME:

                    indento_sp4 = "".ljust(4)

                    login_pw_ansible_vault = ""
                    make_vaultpass = self.makeAnsibleVaultPassword(val,
                                                                   login_pw_ansible_vault,
                                                                   indento_sp4,
                                                                   self.lv_hostinfolist[in_host_name]['SYSTEM_ID'])
                    if make_vaultpass is False:
                        return False

                    val = make_vaultpass
                else:
                    # 複数行具体値のyaml書式対応
                    NumPadding = 2
                    val = self.HostVarEdit(val, NumPadding)

                var_str += "{}: {}\n".format(var, val)

        # ファイル管理とテンプレート管理の変数を使用していないケースは CPF/TPF で
        # このモジュールが呼ばれない。
        # グローバル変数の情報をホスト変数ファイルに出力するタイミングでファイル管理とテンプレート管理の変数を出力する。
        if in_var_type == "CMT":
            # グローバル変数をホスト変数ファイルに登録する。
            for var, val in self.lva_global_vars_list.items():
                # Playbookで使用しているグローバル変数のみを対象にする。
                if var in self.lv_use_gbl_vars_list:
                    # if len(self.lv_pioneer_template_parent_vars_list[in_host_name][var]) != 0:
                    if self.nestArrayDefineCheck(self.lv_pioneer_template_parent_vars_list, in_host_name, var) is True:
                        continue
                    if in_host_name not in self.lv_pioneer_template_parent_vars_list:
                        self.lv_pioneer_template_parent_vars_list[in_host_name] = {}
                    self.lv_pioneer_template_parent_vars_list[in_host_name][var] = 0

                    # 複数行具体値の場合に複数行の扱い記号を付ける
                    edit_val = self.makeMultilineValue(val)

                    NumPadding = 2
                    out_val = self.MultilineValueEdit(edit_val, NumPadding)

                    var_str += "{}: {}\n".format(var, out_val)

            # 変数の具体値に使用しているテンプレート変数の情報をホスト変数ファイルに出力
            if in_host_name in self.lv_tpf_vars_list:
                for var, val in self.lv_tpf_vars_list[in_host_name].items():
                    # if len(self.lv_pioneer_template_parent_vars_list[in_host_name][var]) != 0:
                    if self.nestArrayDefineCheck(self.lv_pioneer_template_parent_vars_list, in_host_name, var) is True:
                        continue
                    if in_host_name not in self.lv_pioneer_template_parent_vars_list:
                        self.lv_pioneer_template_parent_vars_list[in_host_name] = {}
                    self.lv_pioneer_template_parent_vars_list[in_host_name][var] = 0

                    var_str += "{}: {}\n".format(var, val)

            # 変数の具体値に使用しているコピー変数の情報をホスト変数ファイルに出力
            if in_host_name in self.lv_cpf_vars_list:
                for var, val in self.lv_cpf_vars_list[in_host_name].items():
                    # if len(self.lv_pioneer_template_parent_vars_list[in_host_name][var]) != 0:
                    if self.nestArrayDefineCheck(self.lv_pioneer_template_parent_vars_list, in_host_name, var) is True:
                        continue
                    if in_host_name not in self.lv_pioneer_template_parent_vars_list:
                        self.lv_pioneer_template_parent_vars_list[in_host_name] = {}
                    self.lv_pioneer_template_parent_vars_list[in_host_name][var] = 0

                    var_str += "{}: {}\n".format(var, val)

        if var_str:
            # #2079 /storage配下は/tmpを経由してアクセスする
            obj = storage_write()
            obj.open(in_file_name, in_mode)

            obj.write(var_str)

            obj.close()

        return True

    def CheckConcreteValueIsVar(self,
                                in_temp_vars_chk,
                                in_var_val,
                                ina_var_list,
                                in_host_name,
                                mt_tpf_vars_list,
                                mt_cpf_vars_list):
        """
          Legacy/Pioneer用
          変数の具体値にコピー/テンプレート変数が使用されてるかを判定
          使用されている場合に各ファイルを所定のディレクトリにコピーする。
        Arguments:
          in_temp_vars_chk:         テンプレート変数の場合にテンプレートファイル内の変数具体値チェック有無
                                    False:チェック有 False:チェック無
          in_var_name:              変数名
          in_var_val:               変数の具体値
          ina_var_list:             ホスト変数配列
                                    [ 変数名 ]=>具体値
          in_host_name:             ホスト名
          mt_tpf_vars_list:        変数の具体値にテンプレート変数が使用されているコピー変数のリスト
          mt_cpf_vars_list:        変数の具体値にコピー変数が使用されているコピー変数のリスト
        Returns:
          True/False, mt_tpf_vars_list, mt_cpf_vars_list
        """
        tpf_vars_list = {}
        cpf_vars_list = {}
        # テンプレート変数　{{ TPF_[a-zA-Z0-9_] }} を取出す
        keyFilter = r"{{[\s]TPF_[a-zA-Z0-9_]*[\s]}}"
        var_match = re.findall(keyFilter, in_var_val)
        for var_name_str in var_match:
            # 両端の{{}}を取り除く
            keyFilter = r"TPF_[a-zA-Z0-9_]*"
            var_names = re.findall(keyFilter, in_var_val)
            for var_name in var_names:
                # if var_name not in mt_tpf_vars_list[in_host_name]:
                ret = self.nestArrayDefineCheck(mt_tpf_vars_list, in_host_name, var_name)
                if ret is False:
                    tpf_vars_list[var_name] = ""

        # コピー変数　{{ CPF_[a-zA-Z0-9_] }} を取出す
        keyFilter = r"{{[\s]CPF_[a-zA-Z0-9_]*[\s]}}"
        var_match = re.findall(keyFilter, in_var_val)
        for var_name_str in var_match:
            # 両端の{{}}を取り除く
            keyFilter = r"CPF_[a-zA-Z0-9_]*"
            var_names = re.findall(keyFilter, in_var_val)
            for var_name in var_names:
                # if var_name in mt_cpf_vars_list[in_host_name]:
                ret = self.nestArrayDefineCheck(mt_cpf_vars_list, in_host_name, var_name)
                if ret is False:
                    cpf_vars_list[var_name] = ""

        # テンプレート変数
        la_tpf_files = {}
        for tpf_var_name, dummy in tpf_vars_list.items():
            # if len(mt_tpf_vars_list[in_host_name][tpf_var_name]) == 0:
            ret = self.nestArrayDefineCheck(mt_tpf_vars_list, in_host_name, tpf_var_name)
            if ret is False:
                # テンプレート変数に紐づくテンプレートファイルの情報を取得
                tpf_key = ""
                tpf_file_name = ""
                tpf_role_only = ""
                tpf_vars_struct_array = {}
                # テンプレート変数名からテンプレートファイル名とPkeyを取得する。
                tpf_key, tpf_file_name, tpf_role_only, tpf_vars_struct_array
                ret, tpf_key, tpf_file_name, tpf_role_only, tpf_vars_struct_array = self.getDBTemplateMaster(tpf_var_name, tpf_key, tpf_file_name,
                                                                                                             tpf_role_only, tpf_vars_struct_array)
                if ret is False or not tpf_key:
                    # テンプレート変数名が未登録
                    msgstr = g.appmsg.get_api_message("MSG-10531", [tpf_var_name])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    return False, mt_tpf_vars_list, mt_cpf_vars_list

                # テンプレートファイル名が未登録の場合
                if not tpf_file_name:
                    msgstr = g.appmsg.get_api_message("MSG-10532", [tpf_var_name])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    return False, mt_tpf_vars_list, mt_cpf_vars_list

                # 多段/読替変数を含んでいるか判定
                if tpf_role_only == '1':
                    msgstr = g.appmsg.get_api_message("MSG-10599", [tpf_var_name])
                    msgstr = g.appmsg.get_api_message("MSG-10579", [msgstr])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    return False, mt_tpf_vars_list, mt_cpf_vars_list

                # テンプレート変数に紐づくテンプレートファイル内の変数確認
                # テンプレートファイルのpkeyとファイル名を退避
                la_tpf_files[tpf_key] = tpf_file_name
                if self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_DRIVER_ID:
                    # テンプレートファイルバスを取得
                    tpf_path = self.getHostvarsfile_template_file_value(tpf_key, tpf_file_name)
                    tpf_path = self.setAnsibleSideFilePath(tpf_path, self.LC_ITA_IN_DIR)

                elif self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                    # templateモジュールのコピー先パス生成
                    tpf_path = self.getHostvarsfile_pioneer_template_file_value(tpf_key, tpf_file_name, in_host_name)
                    tpf_path = self.setAnsibleSideFilePath(tpf_path, self.LC_ITA_IN_DIR)

                    # templateモジュールのコピー先パス生成 ホスト名は__inventory_hostname__
                    tmpmod_tpf_path = self.getHostvarsfile_pioneer_template_file_value(tpf_key, tpf_file_name,
                                                                                       '{{ ' + self.AnscObj.ITA_SP_VAR_ANS_INVENTORYHOST_VAR_NAME + ' }}')
                    tmpmod_tpf_path = self.setAnsibleSideFilePath(tmpmod_tpf_path, self.LC_ITA_IN_DIR)

                    tpf_src_path = self.getHostvarsfile_pioneer_template_file(tpf_key, tpf_file_name)
                    tpf_src_path = self.setAnsibleSideFilePath(tpf_src_path, self.LC_ITA_IN_DIR)

                    # templateモジュールのsrc/destパス退避
                    self.lv_tpf_var_file_path_list[tpf_var_name] = {}
                    self.lv_tpf_var_file_path_list[tpf_var_name]['src'] = tpf_src_path
                    self.lv_tpf_var_file_path_list[tpf_var_name]['dest'] = tmpmod_tpf_path

                # テンプレートファイルパスのパスを退避
                if in_host_name not in mt_tpf_vars_list:
                    mt_tpf_vars_list[in_host_name] = {}
                #  実行エンジンがAnsible Agentの場合、、ホスト変数のパスを加工する。
                if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG:
                    tpf_path = Replace_HostVrasFilepath("in", tpf_path)

                mt_tpf_vars_list[in_host_name][tpf_var_name] = tpf_path

                if in_temp_vars_chk is True:
                    # テンプレートファイル内のホスト変数を確認
                    ret = self.CheckConcreteValueIsVarTemplatefile(in_host_name, ina_var_list,
                                                                   tpf_var_name, tpf_key, tpf_file_name,
                                                                   tpf_vars_struct_array)
                    if ret is False:
                        return False, mt_tpf_vars_list, mt_cpf_vars_list

        # テンプレート変数に紐づくテンプレートファイルを所定のディレクトリに配置
        if len(la_tpf_files) > 0:
            # テンプレートファイルを所定のディレクトリにコピーする。
            ret = self.CreateTemplatefiles(la_tpf_files)
            if ret is False:
                return False, mt_tpf_vars_list, mt_cpf_vars_list

        # ファイル管理変数
        la_cpf_files = {}
        for cpf_var_name, dummy in cpf_vars_list.items():
            # if len(mt_cpf_vars_list[in_host_name][cpf_var_name]) == 0:
            ret = self.nestArrayDefineCheck(mt_cpf_vars_list, in_host_name, cpf_var_name)
            if ret is False:
                # コピー変数に紐づくファイルの情報を取得
                cpf_key = ""
                cpf_file_name = ""
                # copy変数名からコピーファイル名とPkeyを取得する。
                retAry = self.getDBCopyMaster(cpf_var_name, cpf_key, cpf_file_name)
                ret = retAry[0]
                cpf_key = retAry[1]
                cpf_file_name = retAry[2]
                if ret is False or not cpf_key:
                    # コピー変数名が未登録の場合
                    msgstr = g.appmsg.get_api_message("MSG-10543", [cpf_var_name])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    return False, mt_tpf_vars_list, mt_cpf_vars_list

                if not cpf_file_name:
                    msgstr = g.appmsg.get_api_message("MSG-10544", [cpf_var_name])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    return False, mt_tpf_vars_list, mt_cpf_vars_list

                # copyファイルのpkeyとファイル名を退避
                la_cpf_files[cpf_key] = cpf_file_name
                if self.getAnsibleDriverID() == self.AnscObj.DF_LEGACY_DRIVER_ID:
                    # inディレクトリ配下のcopyファイルバスを取得
                    cpf_path = self.getHostvarsfile_copy_file_value(cpf_key, cpf_file_name)

                elif self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                    cpf_path = self.getHostvarsfile_pioneer_copy_file_value(cpf_key, cpf_file_name)

                cpf_path = self.setAnsibleSideFilePath(cpf_path, self.LC_ITA_IN_DIR)

                # mt_cpf_vars_list[copy変数]=inディレクトリ配下ののcopyファイルパス
                if in_host_name not in mt_cpf_vars_list:
                    mt_cpf_vars_list[in_host_name] = {}
                # 実行エンジンがAnsible Agentの場合、、ホスト変数のパスを加工する。
                if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG:
                    cpf_path = Replace_HostVrasFilepath("in", cpf_path)

                mt_cpf_vars_list[in_host_name][cpf_var_name] = cpf_path

        # コピー変数に紐づくファイルを所定のディレクトリに配置
        if len(la_cpf_files) > 0:
            # copyファイルを所定のディレクトリにコピーする。
            ret = self.CreateCopyfiles(la_cpf_files)
            if ret is False:
                return False, mt_tpf_vars_list, mt_cpf_vars_list

        return True, mt_tpf_vars_list, mt_cpf_vars_list

    def CheckConcreteValueIsVarTemplatefile(self, in_host_name, ina_var_list,
                                            in_tpf_val_name, in_tpf_key, in_tpf_file_name,
                                            ina_tpf_vars_struct_array):
        """
         変数の具体値にテンプレート変数が使用されていた場合にテンプレートで使用
         している変数がホスト変数に登録されているかチェックする。
        Arguments:
          in_host_name:         ホスト名
          ina_var_list:         ホスト変数配列
                                [ 変数名 ]=>具体値
          in_tpf_val_name:      テンプレート変数名
          in_tpf_key:           テンプレートファイルPkey
          in_tpf_file_name:     テンプレートファイル名
          ina_tpf_vars_struct_array:
                              テンプレートで使用している変数の変数構造
                              [Vars_list] => stdClass Object
                              (
                                  [VAR_legacy_VAR] => 0
                                  [GBL_legacy_VAR] => 0
                              )
                              [GBL_vars_info] => stdClass Object
                              (
                                  [1] => stdClass Object
                                  (
                                      [GBL_legacy_VAR] => 0
                                  )

                              )
                              [Array_vars_list] => Array
                              [LCA_vars_use] =>
                              [Array_vars_use] =>
        Returns:
          True/False, mt_tpf_vars_list, mt_cpf_vars_list
        """
        result_code = True

        templatefile = self.getITA_template_file(in_tpf_key, in_tpf_file_name)
        if os.path.isfile(templatefile) is False:
            msgstr = g.appmsg.get_api_message("MSG-10121", [in_tpf_key, os.path.basename(templatefile)])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False

        # テンプレートに登録されているITA変数を抜出す。
        # #2079 /storage配下は/tmpを経由してアクセスする
        obj = storage_read()
        obj.open(templatefile)
        dataString = obj.read()
        obj.close()

        # テンプレートに登録されている変数を抜出す。
        objConv = VarStructAnalJsonConv()
        retAry = objConv.TemplateVarStructAnalJsonLoads(ina_tpf_vars_struct_array)
        # Vars_list = retAry[0]
        # Array_vars_list = retAry[1]
        # LCA_vars_use = retAry[2]
        # Array_vars_use = retAry[3]
        GBL_vars_info = retAry[4]
        # VarVal_list = retAry[5]

        use_gbl_vars_list = {}

        if isinstance(GBL_vars_info, dict):
            if '1' in GBL_vars_info.keys():
                # テンプレートに登録されているグローバル変数のデータベース登録確認
                for var_name, dummy in GBL_vars_info['1'].items():
                    if var_name not in self.lva_global_vars_list:
                        msgstr = g.appmsg.get_api_message("MSG-10530", [os.path.basename(templatefile), var_name])
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        return False

                    use_gbl_vars_list[var_name] = 1
                    self.lv_use_gbl_vars_list[var_name] = 1

        # ITA独自変数のリスト作成
        local_vars = self.setITALocalVars()

        # テンプレートからローカル変数を抜出す
        varsLineArray = []
        file_vars_list = []
        if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
            FillterVars = False  # Fillterを含む変数の抜き出しなし
        else:
            FillterVars = True   # Fillterを含む変数の抜き出しあり
        obj = WrappedStringReplaceAdmin(self.lv_objDBCA)
        obj.SimpleFillterVerSearch(self.AnscObj.DF_HOST_VAR_HED, dataString, varsLineArray, file_vars_list, local_vars, FillterVars)

        # ITA独自変数以外を除外する。
        ita_var_list = []
        for var_name in local_vars:
            if var_name in file_vars_list:
                ita_var_list.append(var_name)
        file_vars_list = ita_var_list
        # テンプレートで使用されているITA独自変数が利用可能か判定
        for var_name in file_vars_list:
            # ITA独自変数の具体値確認
            chkVarDict = {}
            chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_PROTOCOL_VAR_NAME] = "MSG-10534"
            chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_USERNAME_VAR_NAME] = "MSG-10535"
            chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_PASSWD_VAR_NAME] = "MSG-10536"
            chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_DNSHOSTNAME_VAR_NAME] = "MSG-10916"
            chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_IPADDRESS_VAR_NAME] = "MSG-10917"
            chkVarDict[self.AnscObj.ITA_SP_VAR_CONDUCTOR_ID] = "MSG-10927"
            errParamList = [os.path.basename(templatefile), var_name, in_host_name]
            other_Var_chk_error_no = None
            ret = self.chkVariableValue(var_name, ina_var_list, chkVarDict, errParamList, other_Var_chk_error_no)
            if ret is False:
                result_code = False
        return result_code

    def getHostvarsfile_template_file_value(self, in_pkey, in_file):
        """
          inディレクトリ配下のテンプレートファイルパスを取得
        Arguments:
          in_pkey:         テンプレートファイル Pkey
          in_file:         テンプレートファイル
        Returns:
          テンプレートファイルパス
        """
        file = "{}/{}-{}".format(self.getHostvarsfile_template_file_Dir(), in_pkey, in_file)
        return file

    def getHostvarsfile_pioneer_template_file_value(self, in_pkey, in_file, in_hostname):
        """
           inディレクトリ配下のテンプレートファイルパスを取得
        Arguments:
          in_pkey:         テンプレートファイル Pkey
          in_file:         テンプレートファイル
          in_hostname:     ホスト名
        Returns:
          テンプレートファイルパス
        """
        file = "{}-{}".format(in_pkey, in_file)
        file = "{}/{}-{}".format(self.getAnsible_template_files_Dir(), in_hostname, file)
        return file

    def getHostvarsfile_pioneer_template_file(self, in_pkey, in_file):
        """
          inディレクトリ配下のテンプレートファイルパスを取得
        Arguments:
          in_pkey:         テンプレートファイル Pkey
          in_file:         テンプレートファイル
          in_hostname:     ホスト名
        Returns:
          テンプレートファイルパス
        """
        file = "{}/{}-{}".format(self.getAnsible_template_files_Dir(), in_pkey, in_file)
        return file

    def getHostvarsfile_pioneer_copy_file_value(self, in_pkey, in_file):
        """
           inディレクトリ配下のファイル管理 ファイルパスを取得
        Arguments:
          in_pkey:         ファイル管理 Pkey
          in_file:         ファイル管理 ファイル
          in_hostname:     ホスト名
        Returns:
          ファイル管理 ファイルパス
        """
        file = "{}/{}-{}".format(self.getAnsible_copy_files_Dir(), in_pkey, in_file)
        return file

    def CreateLegacyPlaybookfiles(self, ina_child_playbooks, in_exec_mode, in_exec_playbook_hed_def):
        """
        Legacy用 PlayBookファイルを作成する。
        Arguments:
            ina_child_playbooks:      子PlayBookファイル配列
                                      [INCLUDE順序][素材管理Pkey]=>素材ファイル
            in_exec_mode:             実行エンジン
                                      1: Ansible  2: Ansible Tower
            in_exec_playbook_hed_def: 親Playbookヘッダセクション
        Returns:
            True/False
        """
        # 子PlayBookファイル作成
        if self.CreateChildPlaybookfiles(ina_child_playbooks) is False:
            return False

        # 親PlayBookファイル作成(Legacy)
        file_name = self.getAnsible_playbook_file()

        if self.CreatePlaybookfile(file_name, ina_child_playbooks, in_exec_mode, in_exec_playbook_hed_def) is False:
            return False

        return True

    def CreateChildPlaybookfiles(self, ina_child_playbooks):
        """
        Legacy用 PlayBookファイルを作成する。
        Arguments:
            ina_child_playbooks:      子PlayBookファイル配列
                                      [INCLUDE順序][素材管理Pkey]=>素材ファイル
        Returns:
            True/False
        """
        for seqno, playbook_list in ina_child_playbooks.items():
            for pkey, playbook in playbook_list.items():
                # 子Playbookが存在しているか確認
                src_file = self.getITA_child_playbiook_file(pkey, playbook)
                if os.path.isfile(src_file) is False:
                    msgstr = g.appmsg.get_api_message("MSG-10092", [pkey, os.path.basename(src_file)])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    return False

                # Ansible実行時の子Playbookファイル名は Pkey(10桁)-子Playbookファイル名 する。
                dst_file = self.getAnsible_child_playbiook_file(pkey, playbook)

                # 子Playbookをansible用ディレクトリにコピーする。
                shutil.copyfile(src_file, dst_file)

        return True

    def CheckLegacyPlaybookfiles(self, ina_hosts, ina_host_vars, ina_child_playbooks):
        """
        Legacy用 Playbookのフォーマットをチェックする
        Playbookで使用している変数がホスト変数に登録されているかチェックする。
        Arguments:
            ina_hosts:              機器一覧ホスト一覧
                                    {SYSTEM_ID:HOST_NAME}, , ,
            ina_host_vars:          ホスト変数配列
                                    [ホスト名][ 変数名 ]=>具体値
            ina_child_playbooks:    子PlayBookファイル配列
                                    [INCLUDE順序][素材管理Pkey]=>素材ファイル
        Returns:
            True/False
        """
        result_code = True

        for no, playbook_list in ina_child_playbooks.items():
            # 子PlayBook分の繰返し
            for playbookpkey, playbook in playbook_list.items():
                # Ansible実行時の子Playbookファイル名は Pkey(10桁)-子Playbookファイル名 する。
                # 子PlayBookのバスを取得
                file_name = self.getAnsible_child_playbiook_file(playbookpkey, playbook)

                # ローカル変数のリスト作成
                local_vars = []

                # 子PlayBookに登録されている変数を抜出す。
                # #2079 /storage配下は/tmpを経由してアクセスする
                obj = storage_read()
                obj.open(file_name)
                dataString = obj.read()
                obj.close()

                # グローバル変数を子PlayBookから抜出しグローバル変数管理に登録されていることを確認する。
                varsArray = []
                file_global_vars_list = []
                FillterVars = True  # Fillterを含む変数の抜き出しあり

                obj = WrappedStringReplaceAdmin(self.lv_objDBCA)
                obj.SimpleFillterVerSearch(self.AnscObj.DF_HOST_GBL_HED, dataString, file_global_vars_list, varsArray, local_vars, FillterVars)

                if len(file_global_vars_list) != 0:
                    # グローバル変数管理にグローバル変数が未定義の判定
                    if len(self.lva_global_vars_list) == 0:
                        msgstr = g.appmsg.get_api_message("MSG-10461", [])
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        return False

                    # Playbookから抜き出したグローバル変数がグローバル変数管理に登録されているか判定
                    for var_list in file_global_vars_list:
                        for line_no, var_name in var_list.items():
                            if var_name not in self.lva_global_vars_list:
                                msgstr = g.appmsg.get_api_message("MSG-10462", [os.path.basename(file_name), var_name])
                                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                                   str(inspect.currentframe().f_lineno), msgstr)
                                result_code = False
                            # 対話ファイルで使用されているグローバル変数退避
                            self.lv_use_gbl_vars_list[var_name] = "1"

                    # ITA独自変数のリスト作成
                local_vars = self.setITALocalVars()

                # ホスト変数の抜出を示すパラメータを追加
                varsArray = []
                file_vars_list = []
                FillterVars = True  # Fillterを含む変数の抜き出しあり
                obj = WrappedStringReplaceAdmin(self.lv_objDBCA)
                obj.SimpleFillterVerSearch(self.AnscObj.DF_HOST_VAR_HED, dataString, file_vars_list, varsArray, local_vars, FillterVars)

                # 子PlayBookで変数が使用されているか判定
                if len(file_vars_list) == 0:
                    # 子PlayBookで変数が使用されていない場合は以降のチェックをスキップ
                    continue
                # PlayBookに登録されている変数のデータベース登録確認
                for var_list in file_vars_list:
                    for var_line, var_name in var_list.items():
                        # ホスト配列のホスト分繰り返し
                        for host_key, host_name in ina_hosts.items():
                            # ITA独自変数の具体値確認
                            chkVarDict = {}
                            chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_PROTOCOL_VAR_NAME] = "MSG-10206"
                            chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_USERNAME_VAR_NAME] = "MSG-10204"
                            chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_PASSWD_VAR_NAME] = "MSG-10205"
                            chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_DNSHOSTNAME_VAR_NAME] = "MSG-10918"
                            chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_IPADDRESS_VAR_NAME] = "MSG-10919"
                            chkVarDict[self.AnscObj.ITA_SP_VAR_CONDUCTOR_ID] = "MSG-10928"
                            errParamList = [playbook, var_name, host_name]
                            other_Var_chk_error_no = None
                            ret = self.chkVariableValue(var_name, ina_host_vars[host_name], chkVarDict, errParamList, other_Var_chk_error_no)
                            if ret is False:
                                result_code = False

        return result_code

    def getITA_child_playbiook_file(self, in_key, in_filename):
        """
        ITA 子PlayBookファイル名(Legacy)を取得
        Arguments:
            in_key:        子PlayBookファイルのPkey(データベース)
            in_filename:   子PlayBookファイル名
        Returns:
            作業実行inディレクトリ配下のchild_playbooksディレクトリパス
        """
        file = "{}/{}/{}".format(getLegacyPlaybookUploadDirPath(), in_key, in_filename)
        return file

    def getAnsible_child_playbiook_file(self, in_pkey, in_filename):
        """
        ITA 子PlayBookファイル名(Legacy)を取得
        Arguments:
            in_key:        子PlayBookファイルのPkey(データベース)
            in_filename:   子PlayBookファイル名
        Returns:
            子PlayBookファイル名(Legacy)ディレクトリパス
        """
        # Ansible実行時の子Playbookファイル名は Pkey(10桁)-子Playbookファイル名 する。
        file = "{}/{}-{}".format(self.getAnsible_child_playbooks_Dir(), in_pkey, in_filename)
        return file

    def CheckVariablesDefinedInDeviceList(self, ina_hostinfolist, ina_host_vars):
        """
        機器一覧のインベントファイル追加オプションで使用している変数がホスト変数に登録されているかチェックする。
        Arguments:
            ina_hostinfolist:       機器一覧ホスト情報
                                    {HOST_NAME:{機器一覧各項目:xx,  ....}} ...
            ina_host_vars:          ホスト変数配列
                                    [ホスト名][ 変数名 ]=>具体値
        Returns:
            True/False
        """
        result_code = True
        for host_name, row in ina_hostinfolist.items():
            # 機器一覧のインベントファイル追加オプションを取得
            InventryFileAddOptionStr = row['HOSTS_EXTRA_ARGS']
            if not InventryFileAddOptionStr:
                continue
            out_yaml_array = ""
            error_line = ""
            ret, out_yaml_array, error_line = self.InventryFileAddOptionCheckFormat(InventryFileAddOptionStr, out_yaml_array, error_line)
            if ret is False:
                msgstr = g.appmsg.get_api_message("MSG-10625", [host_name, error_line])
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)
                result_code = False
                # 次のホストへ
                continue

            # ITA独自変数のリスト作成
            local_vars = self.setITALocalVars()
            varsLineArray = []
            varsArray = []
            FillterVars = True  # Fillterを含む変数の抜き出しあり

            # インベントリ追加オプションに定義されている変数を抜き出す。
            obj = WrappedStringReplaceAdmin(self.lv_objDBCA)
            obj.SimpleFillterVerSearch(self.AnscObj.DF_HOST_VAR_HED, InventryFileAddOptionStr, varsLineArray, varsArray, local_vars, FillterVars)

            for var_name in varsArray:
                # ITA独自変数の具体値確認
                chkVarDict = {}
                chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_PROTOCOL_VAR_NAME] = "MSG-10246"
                chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_USERNAME_VAR_NAME] = "MSG-10244"
                chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_PASSWD_VAR_NAME] = "MSG-10245"
                chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_DNSHOSTNAME_VAR_NAME] = "MSG-10920"
                chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_IPADDRESS_VAR_NAME] = "MSG-10921"
                chkVarDict[self.AnscObj.ITA_SP_VAR_CONDUCTOR_ID] = "MSG-10929"
                errParamList = [var_name, host_name]
                other_Var_chk_error_no = "MSG-10164"
                ret = self.chkVariableValue(var_name, ina_host_vars[host_name], chkVarDict, errParamList, other_Var_chk_error_no)
                if ret is False:
                    result_code = False

        return result_code

    def CreateLegacytemplatefiles(self, ina_hosts, ina_child_playbooks, ina_host_vars):
        """
        Playbookよりtemplateモジュールで使用しているテンプレート変数を抜出しホスト変数ファイルに追加する。
        Arguments:
            ina_hosts:              機器一覧ホスト一覧
                                    {SYSTEM_ID:HOST_NAME}, , ,
            ina_child_playbooks:    子PlayBookファイル配列
                                    [INCLUDE順序][素材管理Pkey]=>素材ファイル
            ina_host_vars:          ホスト変数配列
                                    [ホスト名][ 変数名 ]=>具体値
        Returns:
          True/False
        """
        result_code = True
        la_tpf_path = {}

        for no, playbook_list in ina_child_playbooks.items():
            # 子PlayBook分の繰返し
            for playbookpkey, playbook in playbook_list.items():
                # 子PlayBookのバスを取得
                file_name = self.getAnsible_child_playbiook_file(playbookpkey, playbook)

                # #2079 /storage配下は/tmpを経由してアクセスする
                obj = storage_read()
                obj.open(file_name)
                dataString = obj.read()
                obj.close()

                # 子PlayBookのtemplateモジュールが使用されているか確認
                # la_tpf_vars[行番号]=テンプレート変数を返す
                local_vars = []
                la_tpf_vars = []
                varsArray = []
                FillterVars = True  # Fillterを含む変数の抜き出しあり
                obj = WrappedStringReplaceAdmin(self.lv_objDBCA)
                obj.SimpleFillterVerSearch(self.AnscObj.DF_HOST_TPF_HED, dataString, la_tpf_vars, varsArray, local_vars, FillterVars)

                # テンプレート変数に紐づくテンプレートファイルの情報を取得
                la_tpf_files = {}
                for row in la_tpf_vars:
                    for line_no, tpf_var_name in row.items():
                        tpf_key = ""
                        tpf_file_name = ""
                        tpf_role_only = ""
                        tpf_vars_struct_array = {}
                        # テンプレート変数名からテンプレートファイル名とPkeyを取得する。
                        retAry = self.getDBTemplateMaster(tpf_var_name, tpf_key, tpf_file_name, tpf_role_only, tpf_vars_struct_array)
                        ret = retAry[0]
                        tpf_key = retAry[1]
                        tpf_file_name = retAry[2]
                        tpf_role_only = retAry[3]
                        tpf_vars_struct_array = retAry[4]
                        if ret is False or not tpf_key:
                            # テンプレート変数名が未登録の場合
                            msgstr = g.appmsg.get_api_message("MSG-10123", [os.path.basename(playbook), line_no, tpf_var_name])
                            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                               str(inspect.currentframe().f_lineno), msgstr)
                            return False

                        # テンプレートファイル名が未登録の場合
                        if not tpf_file_name:
                            msgstr = g.appmsg.get_api_message("MSG-10152", [os.path.basename(playbook), line_no, tpf_var_name])
                            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                               str(inspect.currentframe().f_lineno), msgstr)
                            return False

                        # 多段/読替変数を含んでいるか判定
                        if tpf_role_only == "1":
                            msgstr = g.appmsg.get_api_message("MSG-10599", [tpf_var_name])
                            msgstr = g.appmsg.get_api_message("MSG-10579", [msgstr])
                            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                               str(inspect.currentframe().f_lineno), msgstr)
                            return False

                        # テンプレートファイルのpkeyとファイル名を退避
                        # la_tpf_files[pkey]=テンプレートファイル
                        la_tpf_files[tpf_key] = tpf_file_name

                        # ホスト変数ファイル内のテンプレートファイルバスを取得
                        tpf_path = self.getHostvarsfile_template_file_value(tpf_key, tpf_file_name)

                        # ファイルパスをansible側から見たパスに変更する。
                        tpf_path = self.setAnsibleSideFilePath(tpf_path, self.LC_ITA_IN_DIR)

                        # la_tpf_path[テンプレート変数]=ホスト変数ファイル内のテンプレートファイルパス
                        # 実行エンジンがAnsible Agentの場合、ホスト変数のパスを加工する
                        if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG:
                            tpf_path = Replace_HostVrasFilepath("in", tpf_path)

                        la_tpf_path[tpf_var_name] = tpf_path

                        # テンプレートファイル内のホスト変数を確認
                        ret = self.CheckTemplatefile(ina_hosts, ina_host_vars, playbook, tpf_key, tpf_file_name,
                                                     tpf_vars_struct_array,
                                                     g.appmsg.get_api_message("MSG-10561"))
                        if ret is False:
                            result_code = False

                # 前処理でエラーが発生している場合は次のファイルへ
                if result_code is False:
                    continue

                if len(la_tpf_files) > 0:
                    # テンプレートファイルを所定のディレクトリにコピーする。
                    ret = self.CreateTemplatefiles(la_tpf_files)
                    if ret is False:
                        return False

        # 前処理でエラーが発生している場合は処理終了
        if result_code is False:
            return False

        if len(la_tpf_path) > 0:
            # ホスト変数配列のホスト)分繰返し
            for host_key, hostname in ina_hosts.items():
                # LEGACY用のホスト変数定義ファイル名を取得
                file_name = self.getAnsible_host_var_file(hostname)
                # ホスト変数定義ファイルにテンプレート変数を追加
                if self.CreateHostvarsfile("TPF", hostname, file_name, la_tpf_path, "a") is False:
                    return False
        return True

    def CheckTemplatefile(self, ina_hosts, ina_host_vars, in_child_playbook, in_tpf_key, in_tpf_file_name,
                          ina_tpf_vars_struct_array, in_file_type_name):
        """
        Playbook内のテンプレートで使用しているITA独自変数がホスト変数に登録されているかチェックする。
        Arguments:
            ina_hosts:              機器一覧ホスト一覧
                                    {SYSTEM_ID:HOST_NAME}, , ,
            ina_host_vars:          ホスト変数配列
                                    [ホスト名][ 変数名 ]=>具体値
            ina_child_playbook:     子PlayBookファイル
            in_tpf_key:             テンプレートファイルPkey
            in_tpf_file_name:       テンプレートファイル名
            ina_tpf_vars_struct_array:
                                    テンプレートで使用している変数の変数構造
                                    [Vars_list] => stdClass Object
                                    (
                                      [VAR_legacy_VAR] => 0
                                      [GBL_legacy_VAR] => 0
                                    )
                                    [GBL_vars_info] => stdClass Object
                                    (
                                      [1] => stdClass Object
                                      (
                                        [GBL_legacy_VAR] => 0
                                      )
                                    )
                                    [Array_vars_list] => Array
                                    [LCA_vars_use] =>
                                    [Array_vars_use] =>
                                    [VarVal_list] => Array
            in_file_type_name:      Playybook/対話ファイル
        Returns:
          True/False
        """
        result_code = True
        use_gbl_vars_list = {}

        templatefile = self.getITA_template_file(in_tpf_key, in_tpf_file_name)
        # #2079 /storage配下は/tmpを経由してアクセスする
        obj = storage_read()
        obj.open(templatefile)
        dataString = obj.read()
        obj.close()

        # 変数定義の解析結果をデコード
        obj = VarStructAnalJsonConv()
        retAry = obj.TemplateVarStructAnalJsonLoads(ina_tpf_vars_struct_array)
        # Vars_list = retAry[0]
        # Array_vars_list = retAry[1]
        # LCA_vars_use = retAry[2]
        # Array_vars_use = retAry[3]
        GBL_vars_info = retAry[4]
        # VarVal_list = retAry[5]

        # テンプレートに登録されているグローバル変数のデータベース登録確認
        if "1" in GBL_vars_info:
            for var_name, vaule in GBL_vars_info["1"].items():
                if var_name not in self.lva_global_vars_list:
                    msgstr = g.appmsg.get_api_message("MSG-10463", [in_file_type_name, os.path.basename(in_child_playbook),
                                                      os.path.basename(templatefile), var_name])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    return False

                use_gbl_vars_list[var_name] = 1
                self.lv_use_gbl_vars_list[var_name] = 1

        # ITA独自変数のリスト作成
        local_vars = self.setITALocalVars()

        varsLineArray = []
        file_vars_list = []

        if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
            FillterVars = False  # Fillterを含む変数の抜き出しなし
        else:
            FillterVars = True  # Fillterを含む変数の抜き出しあり

        # テンプレートからITA独自変数を抜出す
        obj = WrappedStringReplaceAdmin(self.lv_objDBCA)
        obj.SimpleFillterVerSearch(self.AnscObj.DF_HOST_VAR_HED, dataString, varsLineArray, file_vars_list, local_vars, FillterVars)

        # テンプレートで変数が使用されているか判定
        if len(file_vars_list) > 0:
            # テンプレートに登録されているITA独自変数の機器一覧入力確認
            for var_name in file_vars_list:
                # ホスト配列のホスト分繰り返し
                for host_key, host_name in ina_hosts.items():
                    chkVarDict = {}
                    chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_PROTOCOL_VAR_NAME] = "MSG-10135"
                    chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_USERNAME_VAR_NAME] = "MSG-10136"
                    chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_PASSWD_VAR_NAME] = "MSG-10137"
                    chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_DNSHOSTNAME_VAR_NAME] = "MSG-10924"
                    chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_IPADDRESS_VAR_NAME] = "MSG-10925"
                    chkVarDict[self.AnscObj.ITA_SP_VAR_CONDUCTOR_ID] = "MSG-10931"
                    errParamList = [in_file_type_name, os.path.basename(in_child_playbook), os.path.basename(templatefile), var_name, host_name]
                    other_Var_chk_error_no = None
                    ret = self.chkVariableValue(var_name, ina_host_vars[host_name], chkVarDict, errParamList, other_Var_chk_error_no)
                    if ret is False:
                        result_code = False

        return result_code

    def CreateLegacyCopyFiles(self, ina_hosts, ina_child_playbooks):
        """
        Playbookよりcopyモジュールで使用している変数を抜出しホスト変数ファイルに追加する。
        Arguments:
            ina_hosts:              機器一覧ホスト一覧
                                    {SYSTEM_ID:HOST_NAME}, , ,
            ina_child_playbooks:    子PlayBookファイル配列
                                    [INCLUDE順序][素材管理Pkey]=>素材ファイル
        Returns:
            True/False
        """
        result_code = True
        la_cpf_path = {}

        for no, playbook_list in ina_child_playbooks.items():
            for playbookpkey, playbook in playbook_list.items():
                # 子PlayBookのバスを取得
                file_name = self.getAnsible_child_playbiook_file(playbookpkey, playbook)

                # 子PlayBookの内容を取得 ここまでの過程でファイルの存在は確認
                # #2079 /storage配下は/tmpを経由してアクセスする
                obj = storage_read()
                obj.open(file_name)
                dataString = obj.read()
                obj.close()

                # 子PlayBookのファイル管理変数が使用されているか確認
                local_vars = []
                la_cpf_vars = []
                varsArray = []
                FillterVars = True  # Fillterを含む変数の抜き出しあり
                obj = WrappedStringReplaceAdmin(self.lv_objDBCA)
                obj.SimpleFillterVerSearch(self.AnscObj.DF_HOST_CPF_HED, dataString, la_cpf_vars, varsArray, local_vars, FillterVars)

                # copy変数に紐づくファイルの情報を取得
                la_cpf_files = {}
                for var_list in la_cpf_vars:
                    for line_no, cpf_var_name in var_list.items():
                        cpf_key = ""
                        cpf_file_name = ""
                        # copy変数名からコピーファイル名とPkeyを取得する。
                        retAry = self.getDBCopyMaster(cpf_var_name, cpf_key, cpf_file_name)
                        ret = retAry[0]
                        cpf_key = retAry[1]
                        cpf_file_name = retAry[2]
                        if ret is False or not cpf_key:
                            # copy変数名が未登録の場合
                            msgstr = g.appmsg.get_api_message("MSG-10543", [cpf_var_name])
                            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                               str(inspect.currentframe().f_lineno), msgstr)
                            return False

                        # copyファイル名が未登録の場合
                        if not cpf_file_name:
                            prastr = g.appmsg.get_api_message("MSG-10615", [os.path.basename(playbook), line_no, cpf_var_name])
                            msgstr = g.appmsg.get_api_message("MSG-10409", [prastr])
                            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                               str(inspect.currentframe().f_lineno), msgstr)
                            return False

                        # copyファイルのpkeyとファイル名を退避
                        la_cpf_files[cpf_key] = cpf_file_name

                        # inディレクトリ配下のcopyファイルバスを取得
                        cpf_path = self.getHostvarsfile_copy_file_value(cpf_key, cpf_file_name)
                        # ファイルパスをansible側から見たパスに変更する。
                        cpf_path = self.setAnsibleSideFilePath(cpf_path, self.LC_ITA_IN_DIR)

                        # 実行エンジンがAnsible Agentの場合、ホスト変数のパスを加工する
                        if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG:
                            cpf_path = Replace_HostVrasFilepath("in", cpf_path)

                        la_cpf_path[cpf_var_name] = cpf_path

                # 前処理でエラーが発生している場合は次のファイルへ
                if result_code is False:
                    continue

                if len(la_cpf_files) > 0:
                    # copyファイルを所定のディレクトリにコピーする。
                    ret = self.CreateCopyfiles(la_cpf_files)
                    if ret is False:
                        return False

        # 前処理でエラーが発生している場合は処理終了
        if result_code is False:
            return False

        if len(la_cpf_path) > 0:
            # ホスト変数配列のホスト)分繰返し
            for host_key, hostname in ina_hosts.items():
                # ホスト変数定義ファイル名を取得
                file_name = self.getAnsible_host_var_file(hostname)
                # ホスト変数定義ファイルにコピー変数を追加
                if self.CreateHostvarsfile("CPF", hostname, file_name, la_cpf_path, "a") is False:
                    return False

        return True

    def CommitHostVarsfiles(self, ina_hosts, ina_host_vars, ina_pioneer_template_host_vars):
        """
        グローバル変数・テンプレート変数・コピー変数をホスト変数の情報を
        ホスト変数ファイルに追加する。
        Arguments:
            ina_hosts:              ホスト名(IP)配列
                                    [管理システム項番]=ホスト名(IP)
            ina_host_vars:          ホスト変数配列
                                    [ホスト名][ 変数名 ]=>具体値
            ina_pioneer_template_host_vars:
                                    ホスト変数配列 pioneer template用 変数一覧返却配列 (passwordColumnの具体値がansible-vaultで暗号化)
                                    [ホスト名][ 変数名 ]=>具体値
        Returns:
            True/False
        """
        # ホスト変数配列のホスト)分繰返し
        for host_key, host_name in ina_hosts.items():
            host_vars_file = host_name
            # 該当ホストの変数配列を取得
            vars_list = ina_host_vars[host_name]
            file_name = self.getAnsible_host_var_file(host_vars_file)
            # グローバル変数・テンプレート変数・コピー変数をホスト変数ファイルに出力
            if self.CreateHostvarsfile("CMT", host_name, file_name, vars_list, "a") is False:
                return False

            # Pioneer template用ホスト変数作成
            if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                file_name = self.getAnsible_pioneer_template_host_var_file(host_vars_file)
                pioneer_template_vars_list = {}
                if len(ina_pioneer_template_host_vars[host_name]) != 0:
                    pioneer_template_vars_list = ina_pioneer_template_host_vars[host_name]

                if self.CreatePioneerTemplateHostvarsfile("CMT", host_name, file_name, pioneer_template_vars_list, "a") is False:
                    return False

                # Pioneerの場合、オリジナル ホスト変数ファイルを生成
                src_file = self.getAnsible_host_var_file(host_vars_file)
                dest_file = self.getAnsible_org_host_var_file(host_vars_file)
                shutil.copyfile(src_file, dest_file)

        return True

    def CreateVaultHostvarsfiles(self, ina_vault_host_vars_file_list, ina_host_vars, ina_hostinfolist):
        """
        グローバル変数・テンプレート変数・コピー変数をホスト変数の情報を
        ホスト変数ファイルに追加する。
        Arguments:
            ina_vault_host_vars_file_list: 暗号化されてい変数配列
                                           [ホスト名][ 変数名 ]=> {{ 変数名 }}
            ina_host_vars:                 ホスト変数配列
                                           [ホスト名][ 変数名 ]=>具体値
            ina_hostinfolist:              機器一覧ホスト情報
                                           {HOST_NAME:{機器一覧各項目:xx, ....}} ...
        Returns:
            True/False
        """
        # 作業対象ホスト分繰り返し
        for host_name, host_info in ina_hostinfolist.items():
            host_vars_file = host_name
            # 暗号化されているホスト変数定義ファイル名を取得
            file_name = self.getAnsible_vault_host_var_file(host_vars_file)
            var_str = ""
            # 機器一覧のパスワードを取得
            if self.AnscObj.ITA_SP_VAR_ANS_PASSWD_VAR_NAME in ina_host_vars[host_name]:
                if ina_host_vars[host_name][self.AnscObj.ITA_SP_VAR_ANS_PASSWD_VAR_NAME] != self.LC_ANS_UNDEFINE_NAME:
                    # 具体値はrot13+base64で暗号化
                    var_str = var_str + "{}: {}\n".format(self.AnscObj.ITA_SP_VAR_ANS_PASSWD_VAR_NAME,
                                                          self.ky_pioneer_encrypt(ina_host_vars[host_name][self.AnscObj.ITA_SP_VAR_ANS_PASSWD_VAR_NAME]))
            # 暗号化している変数の有無判定
            if host_name in ina_vault_host_vars_file_list:
                # 該当ホストの変数配列を取得
                vars_list = ina_vault_host_vars_file_list[host_name]

                for var, val in vars_list.items():
                    # 具体値はrot13+base64で暗号化されている
                    var_str = var_str + "{}: {}\n".format(var, val)

            # 空でも作成
            # #2079 /storage配下は/tmpを経由してアクセスする
            obj = storage_write()
            obj.open(file_name, 'w')
            obj.write(var_str)
            obj.close()
        return True

    def CreatePioneerDialogfiles(self, ina_hostinfolist,
                                 ina_dialog_files,
                                 ina_host_vars,
                                 ina_pioneer_sshkeyfilelist,
                                 ina_pioneer_sshextraargslist,
                                 in_exec_mode):
        """
        Pioneer用 PlayBook(対話ファイル)を作成する。
        Arguments:
            ina_hostinfolist:     機器一覧ホスト情報
                                  {HOST_NAME:{機器一覧各項目:xx, ....}} ...
            ina_dialog_files:     対話ファイル配列
                                  [ホスト名(IP)][INCLUDE順番][素材管理Pkey]=対話ファイル
            ina_host_vars:        ホスト変数配列
                                  [ホスト名][ 変数名 ]=>具体値
            pioneer_sshkeyfilelist:
                                  SSH秘密鍵ファイルリスト
                                  [ホスト名(IP)] = SSH秘密鍵ファイル
            ina_pioneer_sshextraargslist:
                                  SSH_EXTRA_ARGSリスト(pioneer専用)
                                  [ホスト名(IP)] = SSH秘密鍵ファイル
            in_exec_mode:         実行エンジン
                                  1: Ansible  2: Ansible Tower
        Returns:
            True/False
        """
        max_file = 0
        host_list = ina_dialog_files.keys()

        # 対話ファイル配列のホスト)分繰返し 各ホストでの最大対話ファイル数を記憶
        for host_name in host_list:
            # 対話ファイル配列より該当ホストの対話リスト配列を取得
            dialog_file_list = ina_dialog_files[host_name]
            # 各ホストでの最大対話ファイル数を記憶
            if max_file < len(dialog_file_list):
                max_file = len(dialog_file_list)

        max_vars = 0
        # 対話ファイル配列のホスト)分繰返し
        for host_name in host_list:
            dialog_file_list = ina_dialog_files[host_name]

            # 対話ファイル数を取得
            if max_vars < len(dialog_file_list):
                max_vars = len(dialog_file_list)
                var_name_list = {}
                for idx in range(1, max_vars + 1):
                    # ホスト変数ファイルに登録する対話ファイルの変数名(var%d)配列作成
                    # [通番][pkey固定][変数名(var%d)]
                    if idx not in var_name_list:
                        var_name_list[idx] = {}
                    var_name_list[idx] = {"pkey": self.LC_PLAYBOOK_DIALOG_FILE_VARNAME_MK % (idx)}

            # 対話ファイル作成
            if self.CreateDialogfiles(host_name, dialog_file_list) is False:
                return False

            # 対話ファイルの変数名(var%d)配列作成
            host_vars_list = {}
            idx = 0
            for inclodeno, pkeylist in dialog_file_list.items():
                for pkey, dialog_file in pkeylist.items():
                    idx = idx + 1
                    # 変数名生成 var%d
                    arry_key = self.LC_PLAYBOOK_DIALOG_FILE_VARNAME_MK % (idx)
                    #  Ansible実行時の対話ファイル名は Pkey(10桁)-対話ファイル名 する。

                    # 対話ファイル名(絶対パス)生成
                    arry_val = "{}/{}/{}-{}".format(self.getAnsible_dialog_files_Dir(), host_name, pkey, dialog_file)
                    file_path = self.setAnsibleSideFilePath(arry_val, self.LC_ITA_IN_DIR)
                    # AGの場合、パス加工
                    if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG:
                        file_path = Replace_HostVrasFilepath("in", file_path)
                    # [対話ファイル変数名]=対話ファイル名
                    host_vars_list[arry_key] = file_path

            # システム予約変数をホスト変数ファイルに登録する為の準備
            host_vars_list[self.AnscObj.ITA_SP_VAR_ANS_PROTOCOL_VAR_NAME] = ina_host_vars[host_name][self.AnscObj.ITA_SP_VAR_ANS_PROTOCOL_VAR_NAME]
            host_vars_list[self.AnscObj.ITA_SP_VAR_ANS_USERNAME_VAR_NAME] = ina_host_vars[host_name][self.AnscObj.ITA_SP_VAR_ANS_USERNAME_VAR_NAME]
            if self.AnscObj.ITA_SP_VAR_ANS_PASSWD_VAR_NAME in ina_host_vars[host_name]:
                host_vars_list[self.AnscObj.ITA_SP_VAR_ANS_PASSWD_VAR_NAME] = ina_host_vars[host_name][self.AnscObj.ITA_SP_VAR_ANS_PASSWD_VAR_NAME]

            host_vars_list[self.AnscObj.ITA_SP_VAR_ANS_INVENTORYHOST_VAR_NAME] = ina_host_vars[host_name][self.AnscObj.ITA_SP_VAR_ANS_INVENTORYHOST_VAR_NAME]

            #   ansible_host: ip/dnshost
            #  1/None: ip  2: host
            if self.lv_hostaddress_type == '2':
                host_vars_list[self.AnscObj.ITA_SP_VAR_TARGETHOSTNAME_VAR_NAME] = ina_hostinfolist[host_name]["HOST_DNS_NAME"]
            else:
                host_vars_list[self.AnscObj.ITA_SP_VAR_TARGETHOSTNAME_VAR_NAME] = ina_hostinfolist[host_name]["IP_ADDRESS"]

            # SSH秘密鍵での接続の場合にSSH秘密鍵ファイルを変数として登録する。
            if host_name in ina_pioneer_sshkeyfilelist:
                host_vars_list[self.LC_ANS_SSH_KEY_FILE_VAR_NAME] = ina_pioneer_sshkeyfilelist[host_name]
            else:
                host_vars_list[self.LC_ANS_SSH_KEY_FILE_VAR_NAME] = self.LC_ANS_UNDEFINE_NAME

            # SSH_EXTRA_ARGSを変数として登録する。
            if host_name in ina_pioneer_sshextraargslist:
                # SSH_EXTRA_ARGSは"で囲む
                host_vars_list[self.LC_ANS_SSH_EXTRA_ARGS_VAR_NAME] = '"' + ina_pioneer_sshextraargslist[host_name] + '"'
            else:
                host_vars_list[self.LC_ANS_SSH_EXTRA_ARGS_VAR_NAME] = self.LC_ANS_UNDEFINE_NAME

            # 実行エンジンがAnsible Agentの場合、__workflowdir__と__conductor_workflowdir__のパスを変更
            if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG:
                # 実行エンジンがAnsible Agentの場合、__workflowdir__と__conductor_workflowdir__のパスを変更
                if self.lv_conductor_instance_no:
                    # ユーザー公開用データリレイストレージパス 変数の名前
                    host_vars_list[self.AnscObj.ITA_SP_VAR_ANS_OUTDIR_VAR_NAME] = "{}/{}".format("/outdir/out", os.path.basename(self.lv_user_out_Dir))
                    # ユーザー公開用 conductorインスタンス作業用データリレイストレージパス 変数の名前
                    host_vars_list[self.AnscObj.ITA_SP_VAR_CONDUCTO_DIR_VAR_NAME] = "{}".format("/outdir/conductor")
                else:
                    # ユーザー公開用データリレイストレージパス 変数の名前
                    host_vars_list[self.AnscObj.ITA_SP_VAR_ANS_OUTDIR_VAR_NAME] = "{}/{}".format("/outdir/out", os.path.basename(self.lv_user_out_Dir))
                    # ユーザー公開用 conductorインスタンス作業用データリレイストレージパス 変数の名前
                    host_vars_list[self.AnscObj.ITA_SP_VAR_CONDUCTO_DIR_VAR_NAME] = "{}/{}".format("/outdir/out", os.path.basename(self.lv_user_out_Dir))
            else:
                # ユーザー公開用データリレイストレージパス 変数の名前
                host_vars_list[self.AnscObj.ITA_SP_VAR_ANS_OUTDIR_VAR_NAME] = self.lv_user_out_Dir
                # ユーザー公開用 conductorインスタンス作業用データリレイストレージパス 変数の名前
                host_vars_list[self.AnscObj.ITA_SP_VAR_CONDUCTO_DIR_VAR_NAME] = self.lv_conductor_instance_Dir

            # ホスト変数定義ファイル名を取得
            file_name = self.getAnsible_host_var_file(host_name)

            # ホスト変数ファイル作成(Pioneer)
            if self.CreateHostvarsfile("SYS_VAR", host_name, file_name, host_vars_list, "a") is False:
                return False

            # Pioneer template用ホスト変数作成
            if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                file_name = self.getAnsible_pioneer_template_host_var_file(host_name)
                if self.CreatePioneerTemplateHostvarsfile("SYS_VAR", host_name, file_name, host_vars_list, "a") is False:
                    return False

        # in/original_dialog_filesに加工前の対話ファイルをコピー
        shutil.copytree(self.getAnsible_original_dialog_files_Dir(), self.getAnsible_in_original_dialog_files_Dir(), dirs_exist_ok=True)

        # 親PlayBookファイル作成(Pioneer)
        # var_name_list [通番][pkey固定][変数名(var%d)]
        if self.CreatePlaybookfile(self.getAnsible_playbook_file(), var_name_list, in_exec_mode, "") is False:
            return False

        return True

# var_name_list
    def CreateDialogfiles(self, in_hostname, dialog_file_list):
        """
        対話ファイルをAnsible用ディレクトリにコピーする。
        Arguments:
            in_hostname:       ホスト名
            dialog_file_list:  [INCLUDE順番][素材管理Pkey]=対話ファイル
        Returns:
            True/False
        """
        for includeno, pkeylist in dialog_file_list.items():
            for pkey, dialogfile in pkeylist.items():
                # ITA側で管理されている対話ファイルが存在しているか確認
                src_file = self.getITA_dialog_file(pkey, dialogfile)
                if os.path.exists(src_file) is False:
                    msgstr = g.appmsg.get_api_message("MSG-10094", [pkey, os.path.basename(dialogfile)])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    return False

                # 該当ホスト用加工前対話ファイルディレクトリ取得
                c_dir = self.getAnsible_org_dialog_file_host_Dir(in_hostname)

                # ディレクトリが存在している場合はなにもしない
                if os.path.isdir(c_dir) is False:
                    os.mkdir(c_dir)
                    os.chmod(c_dir, 0o777)

                # 対話ファイルをオリジナル用対話ファイルディレクトリにコピーする。
                dst_file = self.getAnsible_org_dialog_file(in_hostname, pkey, dialogfile)

                shutil.copyfile(src_file, dst_file)

                # 該当ホスト用加工後対話ファイルディレクトリ取得
                c_dir = self.getAnsible_dialog_file_host_Dir(in_hostname)

                # ディレクトリが存在している場合はなにもしない
                if os.path.isdir(c_dir) is False:
                    os.mkdir(c_dir)
                    os.chmod(c_dir, 0o777)

                # 対話ファイルをansible用加工後対話ファイルディレクトリにコピーする。
                dst_file = self.getAnsible_dialog_file(in_hostname, pkey, dialogfile)
                shutil.copyfile(src_file, dst_file)

        return True

    def getAnsible_dialog_file(self, in_hostname, in_pkey, in_filename):

        file = "{}/{}/{}-{}".format(self.getAnsible_dialog_files_Dir(), in_hostname, in_pkey, in_filename)
        return file

    def getAnsible_dialog_file_host_Dir(self, in_hostname):
        """
        ホスト毎の加工後の対話ファイル(Pioneer)格納ディレクトリを取得
        Arguments:
            in_hostname:   ホスト名
        Returns:
            ITA管理 対話ファイルパス(Pioneer)
        """
        file = "{}/{}".format(self.getAnsible_dialog_files_Dir(), in_hostname)
        return file

    def getAnsible_org_dialog_file_host_Dir(self, in_hostname):
        """
        ホスト毎の加工前の対話ファイル(Pioneer)格納ディレクトリを取得
        Arguments:
            in_hostname:   ホスト名
        Returns:
            ITA管理 対話ファイルパス(Pioneer)
        """
        file = "{}/{}".format(self.getAnsible_original_dialog_files_Dir(), in_hostname)
        return file

    def getITA_dialog_file(self, in_key, in_filename):
        """
        Pioneer用 PlayBook(対話ファイル)を作成する。
        Arguments:
            in_key:        対話ファイルのPkey(データベース)
            in_filename:   対話ファイル名
        Returns:
            ITA管理 対話ファイルパス(Pioneer)
        """
        file = "{}/{}/{}".format(getPioneerDialogUploadDirPath(), in_key, in_filename)
        return file

    def CreatePioneertemplatefiles(self, ina_hosts, ina_dialog_files, ina_host_vars):
        """
        Pioneer用 対話ファイルよりtemplateモジュールで使用しているテンプレート変数を抜出しホスト変数ファイルに追加する。
        Arguments:
            ina_hosts:              機器一覧ホスト一覧
                                    {SYSTEM_ID:HOST_NAME}, , ,
            ina_dialog_files:    子PlayBookファイル配列
                                    [ホスト名][INCLUDE順番][素材管理Pkey]=対話ファイル
            ina_host_vars:          ホスト変数配列
                                    [ホスト名][ 変数名 ]=>具体値
        Returns:
          True/False
        """
        result_code = True
        la_tpf_files = {}

        # 対話ファイル配列のホスト分繰返し
        for host_key, host_name in ina_hosts.items():
            la_tpf_path = {}

            # 対話ファイル配列より該当ホストの対話ファイル配列取得
            dialog_file_list = ina_dialog_files[host_name]
            for includeno, pkeylist in dialog_file_list.items():
                for pkey, playbook in pkeylist.items():
                    # Ansible実行時の対話ファイル名は Pkey(10桁)-対話ファイル名 とする
                    # 対話ファイルのパス取得
                    file_name = self.getAnsible_dialog_file(host_name, pkey, playbook)

                    # 対話ファイルの内容を取得 ここまでの過程でファイルの存在は確認
                    # #2079 /storage配下は/tmpを経由してアクセスする
                    obj = storage_read()
                    obj.open(file_name)
                    dataString = obj.read()
                    obj.close()

                    # 対話ファイルでtemplate変数が使用されているか確認
                    # la_tpf_vars [行番号]=テンプレート変数を返す
                    local_vars = []
                    la_tpf_vars = []
                    varsArray = []
                    FillterVars = False  # Fillterを含む変数の抜き出しあり
                    obj = WrappedStringReplaceAdmin(self.lv_objDBCA)
                    obj.SimpleFillterVerSearch(self.AnscObj.DF_HOST_TPF_HED, dataString, la_tpf_vars, varsArray, local_vars, FillterVars)

                    # template変数に紐づくファイルの情報を取得
                    la_tpf_files = {}
                    for row in la_tpf_vars:
                        for line_no, tpf_var_name in row.items():
                            tpf_key = ""
                            tpf_file_name = ""
                            tpf_role_only = ""
                            tpf_vars_struct_array = {}
                            # テンプレート変数名からテンプレートファイル名とPkeyを取得する。
                            retAry = self.getDBTemplateMaster(tpf_var_name, tpf_key, tpf_file_name, tpf_role_only, tpf_vars_struct_array)
                            ret = retAry[0]
                            tpf_key = retAry[1]
                            tpf_file_name = retAry[2]
                            tpf_role_only = retAry[3]
                            tpf_vars_struct_array = retAry[4]
                            if ret is False or not tpf_key:
                                # template変数名が未登録の場合
                                msgstr = g.appmsg.get_api_message("MSG-10617", [os.path.basename(playbook), line_no, tpf_var_name])
                                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                                   str(inspect.currentframe().f_lineno), msgstr)
                                return False
                            # テンプレートファイル名が未登録の場合
                            if not tpf_file_name:
                                msgstr = g.appmsg.get_api_message("MSG-10618", [os.path.basename(playbook), line_no, tpf_var_name])

                                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                                   str(inspect.currentframe().f_lineno), msgstr)
                                return False

                            # 多段/読替変数を含んでいるか判定
                            if tpf_role_only == "1":
                                msgstr = g.appmsg.get_api_message("MSG-10599", [])
                                msgstr = g.appmsg.get_api_message("MSG-10579", [msgstr])
                                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                                   str(inspect.currentframe().f_lineno), msgstr)
                                return False

                            # templateファイルのpkeyとファイル名を退避
                            # la_tpf_files[pkey] = テンプレートファイル
                            la_tpf_files[tpf_key] = tpf_file_name

                            # ホスト変数ファイル内のテンプレートファイルバスを取得
                            tpf_path = self.getHostvarsfile_pioneer_template_file_value(tpf_key, tpf_file_name, host_name)

                            # inディレクトリ配下のtemplateファイルバスを取得
                            tpf_path = self.setAnsibleSideFilePath(tpf_path, self.LC_ITA_IN_DIR)

                            # $la_tpf_path[template変数]=inディレクトリ配下のtemplateファイルパス
                            # 実行エンジンがAnsible Agentの場合、ホスト変数のパスを加工する
                            if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG:
                                tpf_path = Replace_HostVrasFilepath("in", tpf_path)

                            la_tpf_path[tpf_var_name] = tpf_path

                            # templateモジュールのコピー先パス生成 ホスト名は__inventory_hostname__
                            login_host_var_name = '{{ ' + self.AnscObj.ITA_SP_VAR_ANS_INVENTORYHOST_VAR_NAME + ' }}'
                            tmpmod_tpf_path = self.getHostvarsfile_pioneer_template_file_value(tpf_key, tpf_file_name, login_host_var_name)
                            tmpmod_tpf_path = self.setAnsibleSideFilePath(tmpmod_tpf_path, self.LC_ITA_IN_DIR)

                            # templateモジュールのコピー元パス生成
                            src_tpf_path = self.getHostvarsfile_pioneer_template_file(tpf_key, tpf_file_name)
                            src_tpf_path = self.setAnsibleSideFilePath(src_tpf_path, self.LC_ITA_IN_DIR)

                            # templateモジュールのsrc/destパス退避
                            self.lv_tpf_var_file_path_list[tpf_var_name] = {}
                            self.lv_tpf_var_file_path_list[tpf_var_name]['src'] = src_tpf_path
                            self.lv_tpf_var_file_path_list[tpf_var_name]['dest'] = tmpmod_tpf_path

                            # テンプレートファイル内のホスト変数を確認
                            ret = self.CheckTemplatefile(ina_hosts, ina_host_vars, playbook, tpf_key, tpf_file_name,
                                                         tpf_vars_struct_array,
                                                         g.appmsg.get_api_message("MSG-10560"))
                            if ret is False:
                                result_code = False

                # 前処理でエラーが発生している場合は次のファイルへ
                if result_code is False:
                    continue
            # 前処理でエラーが発生している場合は次のホストへ
            if result_code is False:
                continue
            if len(la_tpf_path) > 0:

                # Pioneer用のホスト変数定義ファイル名を取得
                file_name = self.getAnsible_host_var_file(host_name)
                # ホスト変数定義ファイルにテンプレート変数を追加
                if self.CreateHostvarsfile("TPF", host_name, file_name, la_tpf_path, "a") is False:
                    return False

                # Pioneer template用ホスト変数作成
                file_name = self.getAnsible_pioneer_template_host_var_file(host_name)
                if self.CreatePioneerTemplateHostvarsfile("TPF", host_name, file_name, la_tpf_path, "a") is False:
                    return False
        # 前処理でエラーが発生している場合は処理終了
        if result_code is False:
            return False

        if len(la_tpf_files) > 0:
            # templateファイルを所定のディレクトリにコピーする。
            ret = self.CreateTemplatefiles(la_tpf_files)
            if ret is False:
                return False

        return True

    def CreatePioneerCopyFiles(self, ina_hosts, ina_dialog_files):
        """
        Arguments:
            ina_hosts:              機器一覧ホスト一覧
                                    {SYSTEM_ID:HOST_NAME}, , ,
            ina_dialog_files:    子PlayBookファイル配列
                                    [ホスト名][INCLUDE順番][素材管理Pkey]=対話ファイル
        Returns:
          True/False
        """
        result_code = True

        la_cpf_files = {}

        # 対話ファイル配列のホスト分繰返し
        for host_key, host_name in ina_hosts.items():
            la_cpf_path = {}

            # 対話ファイル配列より該当ホストの対話ファイル配列取得
            dialog_file_list = ina_dialog_files[host_name]
            for includeno, pkeylist in dialog_file_list.items():
                for playbook_pkey, playbook in pkeylist.items():

                    # 対話ファイルのパス取得
                    file_name = self.getAnsible_dialog_file(host_name, playbook_pkey, playbook)

                    # 対話ファイルの内容を取得 ここまでの過程でファイルの存在は確認
                    # #2079 /storage配下は/tmpを経由してアクセスする
                    obj = storage_read()
                    obj.open(file_name)
                    dataString = obj.read()
                    obj.close()

                    # 子PlayBookのcopyモジュールが使用されているか確認
                    local_vars = []
                    la_cpf_vars = []
                    varsArray = []
                    FillterVars = False  # Fillterを含む変数の抜き出しなし
                    obj = WrappedStringReplaceAdmin(self.lv_objDBCA)
                    obj.SimpleFillterVerSearch(self.AnscObj.DF_HOST_CPF_HED, dataString, la_cpf_vars, varsArray, local_vars, FillterVars)

                    # copy変数に紐づくファイルの情報を取得
                    la_cpf_files = {}
                    for var_list in la_cpf_vars:
                        for line_no, cpf_var_name in var_list.items():
                            cpf_key = ""
                            cpf_file_name = ""
                            # copy変数名からコピーファイル名とPkeyを取得する。
                            retAry = self.getDBCopyMaster(cpf_var_name, cpf_key, cpf_file_name)
                            ret = retAry[0]
                            cpf_key = retAry[1]
                            cpf_file_name = retAry[2]
                            if ret is False or not cpf_key:
                                # copy変数名が未登録の場合
                                msgstr = g.appmsg.get_api_message("MSG-10543", [cpf_var_name])
                                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                                   str(inspect.currentframe().f_lineno), msgstr)
                                return False
                            # copyファイル名が未登録の場合
                            if not cpf_file_name:
                                prastr = g.appmsg.get_api_message("MSG-10616", [os.path.basename(playbook), line_no, cpf_var_name])
                                msgstr = g.appmsg.get_api_message("MSG-10409", [prastr])
                                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                                   str(inspect.currentframe().f_lineno), msgstr)
                                return False

                            # copyファイルのpkeyとファイル名を退避
                            # la_cpf_files[pkey]=copyファイル
                            la_cpf_files[cpf_key] = cpf_file_name

                            # inディレクトリ配下のcopyファイルバスを取得
                            cpf_path = self.getHostvarsfile_pioneer_copy_file_value(cpf_key, cpf_file_name)
                            cpf_path = self.setAnsibleSideFilePath(cpf_path, self.LC_ITA_IN_DIR)

                            # la_cpf_path[copy変数]=inディレクトリ配下のcopyファイルパス
                            # 実行エンジンがAnsible Agentの場合、ホスト変数のパスを加工する
                            if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG:
                                cpf_path = Replace_HostVrasFilepath("in", cpf_path)

                            la_cpf_path[cpf_var_name] = cpf_path
                            self.lv_cpf_var_file_path_list[cpf_var_name] = cpf_path

                # 前処理でエラーが発生している場合は次のファイルへ
                if result_code is False:
                    continue

            # 前処理でエラーが発生している場合は次のホストへ
            if result_code is False:
                continue

            if len(la_cpf_path) > 0:
                # Pioneer用のホスト変数定義ファイル名を取得
                file_name = self.getAnsible_host_var_file(host_name)

                # ホスト変数定義ファイルにコピー変数を追加
                if self.CreateHostvarsfile("CPF", host_name, file_name, la_cpf_path, "a") is False:
                    return False

                # Pioneer template用ホスト変数作成
                file_name = self.getAnsible_pioneer_template_host_var_file(host_name)
                if self.CreatePioneerTemplateHostvarsfile("CPF", host_name, file_name, la_cpf_path, "a") is False:
                    return False
        # 前処理でエラーが発生している場合は処理終了
        if result_code is False:
            return False

        if len(la_cpf_files) > 0:
            # copyファイルを所定のディレクトリにコピーする。
            ret = self.CreateCopyfiles(la_cpf_files)
            if ret is False:
                return False

        return True

    def CheckPioneerPlaybookfiles(self, ina_hosts, ina_host_vars, ina_vault_vars, ina_dialog_files, in_SpecialVarValReplace=False):
        """
        Pioneer用 Playbookのフォーマットをチェックする
        対話ファイルで使用している変数がホスト変数に登録されているかチェックする。
        Arguments:
            ina_hosts:               機器一覧ホスト一覧
                                     {SYSTEM_ID:HOST_NAME}, , ,
            ina_host_vars:           ホスト変数配列
                                     [ホスト名][ 変数名 ]=>具体値
            ina_vault_vars:          PasswordCoulumn変数一覧(Pioneer用)
                                     [ 変数名 ] = << 変数名 >>
            ina_dialog_files:        子PlayBookファイル配列
                                     [INCLUDE順序][素材管理Pkey]=>素材ファイル
            in_SpecialVarValReplace: True:   変数具体値がTPF/CPF変数の場合の具体値置換
                                     False:  変数具体値の具体値置換
        Returns:
            True/False
        """
        result_code = True

        # 対話ファイル配列よりホストリストを取得
        # host_list = ina_dialog_files.keys()

        # 各ホストの対話ファイルがあるか判定
        for host_key, host_name in ina_hosts.items():
            if host_name not in ina_dialog_files:
                msgstr = g.appmsg.get_api_message("MSG-10115", [host_name])
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)
                return False

        # 対話ファイル配列のホスト分繰返し
        for host_key, host_name in ina_hosts.items():
            # 対話ファイル配列より該当ホストの対話ファイル配列取得
            dialog_file_list = ina_dialog_files[host_name]
            for includeno, pkeylist in dialog_file_list.items():
                for playbook_pkey, playbook in pkeylist.items():
                    # 対話ファイルのパス取得(オリジナル版)
                    dialog_file = self.getAnsible_org_dialog_file(host_name, playbook_pkey, playbook)

                    obj = YamlParse()
                    dialog_file_array = obj.Parse(dialog_file)
                    error_detail = obj.GetLastError()
                    del obj
                    if dialog_file_array is False:
                        msgstr = g.appmsg.get_api_message("MSG-10622", [os.path.basename(playbook)])
                        msgstr = "{}\n{}".format(msgstr, error_detail)
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        return False

                    # ホスト変数ファイルのパス取得
                    host_vars_file = self.getAnsible_host_var_file(host_name)

                    obj = YamlParse()
                    host_vars_file_array = obj.Parse(host_vars_file)
                    error_detail = obj.GetLastError()
                    del obj
                    if host_vars_file_array is False:
                        msgstr = g.appmsg.get_api_message("MSG-10623", [host_name])
                        msgstr = "{}\n{}".format(msgstr, error_detail)
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        return False

                    # 複数具体値変数の使い方が正しいか確認
                    dialog_file_vars = []
                    retAry = self.value_extraction(dialog_file_array, "", dialog_file_vars)
                    dialog_file_vars = retAry[1]
                    ret = self.var_check(playbook, host_name, dialog_file_vars, host_vars_file_array)
                    if ret is False:
                        return False

        ProcessedFileList = {}
        # 対話ファイル配列のホスト分繰返し
        for host_key, host_name in ina_hosts.items():
            # 対話ファイル配列より該当ホストの対話ファイル配列取得
            dialog_file_list = ina_dialog_files[host_name]
            for includeno, pkeylist in dialog_file_list.items():
                for playbook_pkey, playbook in pkeylist.items():
                    if host_name not in ProcessedFileList:
                        ProcessedFileList[host_name] = {}
                    if playbook_pkey not in ProcessedFileList[host_name]:
                        ProcessedFileList[host_name][playbook_pkey] = {}
                    if playbook not in ProcessedFileList[host_name][playbook_pkey]:
                        ProcessedFileList[host_name][playbook_pkey][playbook] = 1
                    else:
                        # Movement詳細に同一対話ファイル(TPF/CPF変数を使用)が複数登録された場合
                        # 複数回処理されないようにガードする。
                        # ガードしないと対話ファイル内のTPF/CPF変数が具体値に置き換わる場合がある。
                        continue

                    file_name = self.getAnsible_dialog_file(host_name, playbook_pkey, playbook)

                    # 変数具体値がTPF/CPF変数の場合の具体値置換えでない場合
                    if in_SpecialVarValReplace is False:
                        # 対話ファイルのフォーマットチェックを行う。

                        if self.CheckDialogfileFormat(file_name, host_name) is False:
                            # フォーマットチェックでエラーが発生した場合は変数チェックはしない。
                            result_code = False
                            continue

                    # 子PlayBookで使用している変数がホストの変数に登録されているか判定
                    # 子PlayBookに登録されている変数を抜出す。
                    # #2079 /storage配下は/tmpを経由してアクセスする
                    obj = storage_read()
                    obj.open(file_name)
                    dataString = obj.read()
                    obj.close()

                    # 変数具体値がTPF/CPF変数の場合の具体値置換えでない場合
                    if in_SpecialVarValReplace is False:
                        # グローバル変数を子PlayBookから抜出しグローバル変数管理に登録されていることを確認する。
                        local_vars = []
                        varsArray = []
                        file_global_vars_list = []
                        FillterVars = False  # Fillterを含む変数の抜き出しなし

                        obj = WrappedStringReplaceAdmin(self.lv_objDBCA)
                        obj.SimpleFillterVerSearch(self.AnscObj.DF_HOST_GBL_HED, dataString,
                                                   file_global_vars_list, varsArray, local_vars, FillterVars)

                        globalvarSetTo = []
                        if len(file_global_vars_list) != 0:
                            # グローバル変数管理にグローバル変数が未定義の判定
                            if len(self.lva_global_vars_list) == 0:
                                msgstr = g.appmsg.get_api_message("MSG-10459", [])
                                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                                   str(inspect.currentframe().f_lineno), msgstr)
                                return False

                            # 対話ファイルから抜き出したグローバル変数がグローバル変数管理に登録されているか判定
                            for var_list in file_global_vars_list:
                                for line_no, var_name in var_list.items():
                                    if var_name not in self.lva_global_vars_list:
                                        msgstr = g.appmsg.get_api_message("MSG-10460", [os.path.basename(file_name), var_name])
                                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                                           str(inspect.currentframe().f_lineno), msgstr)
                                        return False

                                    # 対話ファイルで使用されているグローバル変数退避
                                    self.lv_use_gbl_vars_list[var_name] = "1"

                                    # グローバル変数の具体値を退避
                                    globalvarSetTo.append({var_name: self.lva_global_vars_list[var_name]})

                                    # 複数行具体値判定
                                    ret = self.chkMultilineValue(self.lva_global_vars_list[var_name])
                                    if ret is False:
                                        msgstr = g.appmsg.get_api_message("MSG-10473", [var_name])
                                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                                           str(inspect.currentframe().f_lineno), msgstr)
                                        return False

                    # copy変数を対話ファイルから抜出しファイル管理に登録されていることを確認する。
                    local_vars = []
                    file_copy_vars_list = []
                    varsArray = []
                    FillterVars = False  # Fillterを含む変数の抜き出しあり
                    obj = WrappedStringReplaceAdmin(self.lv_objDBCA)
                    obj.SimpleFillterVerSearch(self.AnscObj.DF_HOST_CPF_HED, dataString, file_copy_vars_list, varsArray, local_vars, FillterVars)

                    if len(file_copy_vars_list) == 0:
                        # 対話ファイルで変数が使用されていない場合は以降のチェックをスキップ
                        pass
                    else:
                        # 該当ホストのホスト変数が登録されているか判定
                        if host_name not in ina_host_vars:
                            msgstr = g.appmsg.get_api_message("MSG-10097", [host_name])
                            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                               str(inspect.currentframe().f_lineno), msgstr)
                            result_code = False
                            continue

                    copyvarSetTo = []
                    copy_list = {}
                    host_vars_file = host_name
                    file_name2 = self.getAnsible_host_var_file(host_vars_file)

                    obj = YamlParse()
                    copy_list = obj.Parse(file_name2)
                    error_detail = obj.GetLastError()
                    del obj
                    if copy_list is False:
                        msgstr = g.appmsg.get_api_message("MSG-10623", [host_name])
                        msgstr = "{}\n{}".format(msgstr, error_detail)
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        result_code = False
                        continue

                    # copy_list[ 変数名 ]=>具体値
                    for var_name_list in file_copy_vars_list:
                        for no, var_name in var_name_list.items():
                            # 対話ファイルで使用している変数がホストの変数に登録されているか判定
                            if var_name not in copy_list:
                                result_code = False
                                # 未登録でも処理は続行する。
                            else:
                                # 変数を置換える具体値を設定
                                copyvarSetTo.append({var_name: copy_list[var_name]})

                    # template変数を対話ファイルから抜出しファイル管理に登録されていることを確認する。
                    local_vars = []
                    la_tpf_vars = []
                    varsArray = []
                    FillterVars = False  # Fillterを含む変数の抜き出しあり
                    obj = WrappedStringReplaceAdmin(self.lv_objDBCA)
                    obj.SimpleFillterVerSearch(self.AnscObj.DF_HOST_TPF_HED, dataString, la_tpf_vars, varsArray, local_vars, FillterVars)

                    if len(la_tpf_vars) == 0:
                        # 対話ファイルで変数が使用されていない場合は以降のチェックをスキップ
                        pass
                    else:
                        # 該当ホストのホスト変数が登録されているか判定
                        if host_name not in ina_host_vars:
                            msgstr = g.appmsg.get_api_message("MSG-10097", [host_name])
                            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                               str(inspect.currentframe().f_lineno), msgstr)
                            result_code = False
                            continue

                    tpfvarSetTo = []
                    tpf_list = {}
                    host_vars_file2 = host_name
                    file_name3 = self.getAnsible_host_var_file(host_vars_file2)

                    obj = YamlParse()
                    tpf_list = obj.Parse(file_name3)
                    error_detail = obj.GetLastError()
                    del obj
                    if tpf_list is False:
                        msgstr = g.appmsg.get_api_message("MSG-10623", [host_name])
                        msgstr = "{}\n{}".format(msgstr, error_detail)
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        result_code = False
                        continue

                    for tpf_var_list in la_tpf_vars:
                        for line_no, tpf_var_name in tpf_var_list.items():
                            # 対話ファイルで使用している変数がホストの変数に登録されているか判定
                            if tpf_var_name not in tpf_list:
                                result_code = False
                                # 未登録でも処理は続行する。
                            else:
                                # 変数を置換える具体値を設定
                                tpfvarSetTo.append({tpf_var_name: tpf_list[tpf_var_name]})

                    # 変数具体値がTPF/CPF変数の場合の具体値置換えでない場合
                    if in_SpecialVarValReplace is False:
                        # ITA独自変数のリスト作成 pioneerなので全ITA独自変数を対象にする
                        local_vars = self.AnscObj.CannotValueAssign_ITA_sp_varlist

                        file_vars_list = []
                        varsArray = []
                        FillterVars = False  # Fillterを含む変数の抜き出しなし
                        obj = WrappedStringReplaceAdmin(self.lv_objDBCA)
                        obj.SimpleFillterVerSearch(self.AnscObj.DF_HOST_VAR_HED, dataString, file_vars_list, varsArray, local_vars, FillterVars)

                        # 対話ファイルで変数が使用されているか判定
                        if len(file_vars_list) == 0:
                            # 対話ファイルで変数が使用されていない場合は以降のチェックをスキップ
                            pass
                        else:
                            # 該当ホストのホスト変数が登録されているか判定
                            if host_name not in ina_host_vars:
                                msgstr = g.appmsg.get_api_message("MSG-10097", [host_name])
                                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                                   str(inspect.currentframe().f_lineno), msgstr)
                                result_code = False
                                continue
                                # ホスト変数が登録されていないので以降のチェックをスキップ

                        # 該当ホストの変数配列を取得
                        varSetTo = []
                        vars_list = ina_host_vars[host_name]
                        # vars_list[ 変数名 ]=>具体値
                        for file_vars_line in file_vars_list:
                            for no, var_name in file_vars_line.items():
                                # 対話ファイルで使用している変数と ITA独自変数がホストの変数に登録されているか判定
                                chkVarDict = {}
                                chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_PROTOCOL_VAR_NAME] = "MSG-10202"
                                chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_USERNAME_VAR_NAME] = "MSG-10200"
                                chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_PASSWD_VAR_NAME] = "MSG-10201"
                                chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_DNSHOSTNAME_VAR_NAME] = "MSG-10922"
                                chkVarDict[self.AnscObj.ITA_SP_VAR_ANS_IPADDRESS_VAR_NAME] = "MSG-10923"
                                chkVarDict[self.AnscObj.ITA_SP_VAR_CONDUCTOR_ID] = "MSG-10930"
                                errParamList = [os.path.basename(playbook), var_name, host_name]
                                other_Var_chk_error_no = "MSG-10098"
                                ret = self.chkVariableValue(var_name, vars_list, chkVarDict, errParamList, other_Var_chk_error_no)
                                if ret is False:
                                    result_code = False
                                    continue

                                var_value = vars_list[var_name]
                                # 変数を置換える具体値を設定
                                # ansible_vaultの対応により、機器一覧のパスワードの具体値を<< self.AnscObj.ITA_SP_VAR_ANS_PASSWD_VAR_NAME >>に置き換える
                                # pioneerモジュール側で置換をする。
                                if var_name == self.AnscObj.ITA_SP_VAR_ANS_PASSWD_VAR_NAME:
                                    var_value = "<< {} >>".format(self.AnscObj.ITA_SP_VAR_ANS_PASSWD_VAR_NAME)
                                # 具体値が暗号化されている変数の具体値を変数名<< 変数名 >>に置き換える
                                if var_name in ina_vault_vars:
                                    var_value = ina_vault_vars[var_name]
                                varSetTo.append({var_name: var_value})

                    # グローバル変数を具体値で置換える
                    book_upd = False

                    obj = WrappedStringReplaceAdmin(self.lv_objDBCA)
                    # 変数具体値がTPF/CPF変数の場合の具体値置換えでない場合
                    if in_SpecialVarValReplace is False:
                        if len(globalvarSetTo) != 0:
                            obj.stringReplace(dataString, globalvarSetTo)
                            dataString = obj.getReplacedString()
                            book_upd = True

                    if len(copyvarSetTo) != 0:
                        obj.stringReplace(dataString, copyvarSetTo)
                        dataString = obj.getReplacedString()
                        book_upd = True

                    if len(tpfvarSetTo) != 0:
                        obj.stringReplace(dataString, tpfvarSetTo)
                        dataString = obj.getReplacedString()
                        book_upd = True

                    # 変数具体値がTPF/CPF変数の場合の具体値置換えでない場合
                    if in_SpecialVarValReplace is False:
                        # 変数を具体値で置換える
                        obj.stringReplace(dataString, varSetTo)
                        dataString = obj.getReplacedString()
                        book_upd = True
                    del obj

                    if book_upd is True:
                        # #2079 /storage配下は/tmpを経由してアクセスする
                        obj = storage_write()
                        obj.open(file_name, 'w')
                        obj.write(dataString)
                        obj.close()

        return result_code

    def TemplateMmoduleAddPlaybook(self, in_tpf_path):
        """
        テンプレート管理を使用している場合、親PlaybookにTemplateMmoduleを追加してテンプレート内の変数解決する。
        Arguments:
            in_tpf_path:    テンプレートファイル配列
        Returns:
            True
        """
        playbookwrite = []

        # playbookの読み込み
        # #2079 /storage配下は/tmpを経由してアクセスする
        obj = storage_read()
        obj.open(self.getAnsible_playbook_file(), 'r')
        value = obj.read()
        playbookread = value.split("\n")
        obj.close()

        # Templateファイルがある場合、TemplateMmoduleを親playbookに追加する
        for line in playbookread:
            # 読み込みデータを書き込みデータに代入
            playbookwrite.append(line)
            if line == '  tasks:':
                host_vars_path = self.setAnsibleSideFilePath(self.getAnsible_pioneer_template_hosts_vars_Dir(), self.LC_ITA_TMP_DIR)
                playbookwrite.append("    - name: include")
                include_vars_path = host_vars_path + "/{{ " + self.AnscObj.ITA_SP_VAR_ANS_INVENTORYHOST_VAR_NAME + " }}"

                #  実行エンジンがAnsible Agentの場合、ホスト変数のパスを加工する
                if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG:
                    include_vars_path = Replace_HostVrasFilepath("tmp", include_vars_path, "outdir/tmp")

                playbookwrite.append("      include_vars: " + include_vars_path)
                for var_name, fileinfo in in_tpf_path.items():
                    src_template_path = in_tpf_path[var_name]['src']
                    dest_template_path = in_tpf_path[var_name]['dest']
                    # 実行エンジンがAnsible Agentの場合、ホスト変数のパスを加工する
                    if self.lv_exec_mode == self.AnscObj.DF_EXEC_MODE_AG:
                        src_template_path = Replace_HostVrasFilepath("in", src_template_path)
                        dest_template_path = Replace_HostVrasFilepath("in", dest_template_path)
                    playbookwrite.append("    - name: Templatefile Create " + "[{}]".format(var_name))
                    playbookwrite.append("      template: src='{}'  dest='{}'".format(src_template_path, dest_template_path))
                    playbookwrite.append("      delegate_to: 127.0.0.1")
                    playbookwrite.append("      when: {} is defined".format(var_name))

        # #2079 /storage配下は/tmpを経由してアクセスする
        obj = storage_write()
        obj = open(self.getAnsible_playbook_file(), "w")
        for line in playbookwrite:
            obj.write(line + "\n")
        obj.close()
        return True

    def CheckDialogfileFormat(self, in_file_name, in_host_name):
        """
        対話ファイルの独自フォーマットをチェックする。
        Arguments:
            in_file_name:  対話ファイル
        Returns:
            True/False
        """
        ignore_errors_preg_match_array = []
        ignore_errors_preg_match_array.append(r'^\s*\S+: {1}\s*"(no|yes|\{\{ {1}\S+ {1}\}\})"\s*$')
        ignore_errors_preg_match_array.append(r"^\s*\S+: {1}\s*'(no|yes|\{\{ {1}\S+ {1}\}\})'\s*$")
        ignore_errors_preg_match_array.append(r"^\s*\S+: {1}\s*(no|yes|\{\{ {1}\S+ {1}\}\})\s*$")

        result_code = True

        # stateコマンドの情報退避
        state_info = []
        state_line_no = 0

        # commandの情報退避
        command_info = []
        command_line_no = 0

        # localactionの情報退避
        localaction_info = []
        localaction_line_no = 0

        try:
            # #2079 /storage配下は/tmpを経由してアクセスする
            obj = storage_read()
            with obj.open(in_file_name) as fd:
                line_no = 0

                # mystsの値
                # 0: idle
                # 1: conf=>timeout待ち
                # 2: exec_list待ち
                # 3: ブロック待ち
                # 4: 3でpexpect読み取り          exec待ち
                # 5: 3でstate読み取り            各パラメータ待ち
                # 6: 5でparameter読み取り        - パラメータ待ち
                # 7: 3でcommand読み取り          各パラメータ待ち
                # 8: command=>xxxx_with読み取り  - パラメータ待ち
                # 9: localaction読み取り         各パラメータ待ち
                mysts = 0

                now_cmd = ""
                now_when_cmd = ""

                for rbuff in fd:
                    line_no += 1

                    # 改行を取り除く
                    read_line = rbuff.replace("\n", "")

                    # コメント行の判定
                    if read_line.startswith('#'):
                        continue

                    # #の前の文字がスペースの場合、以降をコメントとして扱う
                    wspstr = read_line.split(' #')
                    read_line = wspstr[0]

                    # TABキー入力の判定
                    if '\t' in read_line:
                        msgstr = g.appmsg.get_api_message("MSG-10105", [in_host_name, os.path.basename(in_file_name), line_no])

                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        result_code = False
                        continue

                    # 空白行の判定
                    if read_line.strip() == "":
                        continue

                    # 先頭が半角スペースか判定
                    # 文字列から配列に変換
                    if read_line[0] == " ":
                        # インデントが半角スペース2文字を使用しているか判定
                        space_count = 1
                        for idx in range(1, len(read_line)):
                            if read_line[idx] == " ":
                                space_count += 1

                            else:
                                if space_count % 2 == 0:
                                    break

                                else:
                                    msgstr = g.appmsg.get_api_message("MSG-10107", [in_host_name, os.path.basename(in_file_name), line_no])
                                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                                       str(inspect.currentframe().f_lineno), msgstr)
                                    result_code = False
                                    break

                    # conf:セクションか判定
                    if read_line.rstrip() == "conf:":
                        if mysts == 0:
                            mysts = 1

                        else:
                            msgstr = g.appmsg.get_api_message("MSG-10108", [in_host_name, os.path.basename(in_file_name), line_no])
                            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                               str(inspect.currentframe().f_lineno), msgstr)
                            result_code = False
                            break

                    # conf=>timeout:キーか判定
                    elif read_line.startswith("  timeout:"):
                        if mysts == 1:
                            arry_list = read_line.split(":")
                            if len(arry_list) != 2:
                                msgstr = g.appmsg.get_api_message("MSG-10109", [in_host_name, os.path.basename(in_file_name), line_no])
                                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                                   str(inspect.currentframe().f_lineno), msgstr)
                                result_code = False
                                break

                            timeout = arry_list[1].strip().rstrip()
                            timeout = self.str_to_num(timeout)
                            if timeout is False:
                                msgstr = g.appmsg.get_api_message("MSG-10110", [in_host_name, os.path.basename(in_file_name), line_no])
                                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                                   str(inspect.currentframe().f_lineno), msgstr)
                                result_code = False
                                break

                            if timeout < 1 or timeout > 3600:
                                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                                   str(inspect.currentframe().f_lineno), msgstr)
                                result_code = False
                                break

                            mysts = 2

                        else:
                            msgstr = g.appmsg.get_api_message("MSG-10111", [in_host_name, os.path.basename(in_file_name), line_no])
                            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                               str(inspect.currentframe().f_lineno), msgstr)
                            result_code = False
                            break

                    # exec_list:セクションか判定
                    elif read_line.rstrip() == "exec_list:":
                        if mysts == 2:
                            mysts = 3

                        else:
                            msgstr = g.appmsg.get_api_message("MSG-10112", [in_host_name, os.path.basename(in_file_name), line_no])
                            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                               str(inspect.currentframe().f_lineno), msgstr)
                            result_code = False
                            break

                    # exec_list=>expect:キーか判定
                    elif read_line.startswith("  - expect:"):
                        # 一個前のコマンドに問題がないか判定
                        ret, mysts, result_code, state_info, state_line_no, command_info, command_line_no = self.beforCommandCheck(
                            mysts, result_code, state_info, state_line_no, command_info, command_line_no, in_file_name, in_host_name
                        )
                        if ret is False:
                            break

                        if mysts == 3:
                            arry_list = read_line.split(":")
                            if len(arry_list) < 2:
                                msgstr = g.appmsg.get_api_message("MSG-10118", [in_host_name, os.path.basename(in_file_name), line_no])
                                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                                   str(inspect.currentframe().f_lineno), msgstr)
                                result_code = False
                                break

                            else:
                                expect = arry_list[1].strip().rstrip()
                                if expect == "":
                                    msgstr = g.appmsg.get_api_message("MSG-10118", [in_host_name, os.path.basename(in_file_name), line_no])
                                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                                       str(inspect.currentframe().f_lineno), msgstr)
                                    result_code = False
                                    break

                            # エラーでも状態は進める
                            mysts = 4

                        else:
                            msgstr = g.appmsg.get_api_message("MSG-10113", [in_host_name, os.path.basename(in_file_name), line_no])
                            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                               str(inspect.currentframe().f_lineno), msgstr)
                            result_code = False
                            break

                    # exec_list=>exec:キーか判定
                    elif read_line.startswith("    exec:"):
                        if mysts == 4:
                            arry_list = read_line.split(":")
                            if len(arry_list) < 2:
                                msgstr = g.appmsg.get_api_message("MSG-10119", [in_host_name, os.path.basename(in_file_name), line_no])
                                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                                   str(inspect.currentframe().f_lineno), msgstr)
                                result_code = False
                                break

                            else:
                                exec = arry_list[1].strip().rstrip()
                                if exec == "":
                                    msgstr = g.appmsg.get_api_message("MSG-10119", [in_host_name, os.path.basename(in_file_name), line_no])
                                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                                       str(inspect.currentframe().f_lineno), msgstr)
                                    result_code = False
                                    break

                            # エラーでも状態は進める
                            mysts = 3

                        else:
                            msgstr = g.appmsg.get_api_message("MSG-10116", [in_host_name, os.path.basename(in_file_name), line_no])
                            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                               str(inspect.currentframe().f_lineno), msgstr)
                            result_code = False
                            break

                    #############################################################
                    # exec_list=>localaction:キーか判定
                    #############################################################
                    elif read_line.startswith("  - localaction:"):
                        now_cmd = "localaction"

                        # 一個前のコマンドに問題がないか判定
                        ret, mysts, result_code, state_info, state_line_no, command_info, command_line_no = self.beforCommandCheck(
                            mysts, result_code, state_info, state_line_no, command_info, command_line_no, in_file_name, in_host_name
                        )
                        if ret is False:
                            break

                        if mysts == 3:
                            mysts = 9

                            # localactionコマンドの情報を初期化
                            localaction_info, localaction_line_no = self.initlocalactionInfo(localaction_info, localaction_line_no, line_no)

                            arry_list = read_line.split(":")
                            if len(arry_list) < 2:
                                mysts, result_code, localaction_info, localaction_line_no = self.errorlocalaction(
                                    mysts, result_code, localaction_info, localaction_line_no,
                                    "MSG-10163", [in_host_name, os.path.basename(in_file_name), line_no]
                                )

                                # 終了
                                break

                            expect = arry_list[1].strip().rstrip()
                            if expect == "":
                                mysts, result_code, localaction_info, localaction_line_no = self.errorlocalaction(
                                    mysts, result_code, localaction_info, localaction_line_no,
                                    "MSG-10163", [in_host_name, os.path.basename(in_file_name), line_no]
                                )

                                # localaction終了
                                break

                            else:
                                # localaction 記述済みにマーク
                                localaction_info[now_cmd] = "1"

                        else:
                            mysts, result_code, localaction_info, localaction_line_no = self.errorlocalaction(
                                mysts, result_code, localaction_info, localaction_line_no,
                                "MSG-10160", [in_host_name, os.path.basename(in_file_name), line_no]
                            )

                            # 終了
                            break

                    ################################################################
                    # exec_list=>state:キーか判定
                    ################################################################
                    elif read_line.startswith("  - state:"):
                        now_cmd = "state"

                        # 一個前のコマンドに問題がないか判定
                        ret, mysts, result_code, state_info, state_line_no, command_info, command_line_no = self.beforCommandCheck(
                            mysts, result_code, state_info, state_line_no, command_info, command_line_no, in_file_name, in_host_name
                        )
                        if ret is False:
                            break

                        if mysts == 3:
                            mysts = 5

                            # stateコマンドの情報を初期化
                            state_info, state_line_no = self.initstateCommandInfo(state_info, state_line_no, line_no)

                            arry_list = read_line.split(":")
                            if len(arry_list) < 2:
                                mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                    mysts, result_code, state_info, state_line_no,
                                    "MSG-10125", [in_host_name, os.path.basename(in_file_name), line_no]
                                )

                                # 終了
                                break

                            expect = arry_list[1].strip().rstrip()
                            if expect == "":
                                mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                    mysts, result_code, state_info, state_line_no,
                                    "MSG-10125", [in_host_name, os.path.basename(in_file_name), line_no]
                                )

                                # 終了
                                break

                            else:
                                # state 記述済みにマーク
                                state_info[now_cmd] = "1"

                        else:
                            mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                mysts, result_code, state_info, state_line_no,
                                "MSG-10124", [in_host_name, os.path.basename(in_file_name), line_no]
                            )

                            # 終了
                            break

                    ################################################################
                    # exec_list=>state:->prompt:キーか判定
                    # exec_list=>command:->prompt:キーか判定
                    ################################################################
                    elif read_line.startswith("    prompt:"):
                        now_cmd = "prompt"
                        if mysts in [5, 6]:
                            # コマンドが既に設定済みか判定
                            if state_info[now_cmd] == "1":
                                mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                    mysts, result_code, state_info, state_line_no,
                                    "MSG-10127", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            else:
                                arry_list = read_line.split(":")
                                if len(arry_list) < 2:
                                    mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                        mysts, result_code, state_info, state_line_no,
                                        "MSG-10126", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                    )

                                    # 終了
                                    break

                                expect = arry_list[1].strip().rstrip()
                                if expect == "":
                                    mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                        mysts, result_code, state_info, state_line_no,
                                        "MSG-10126", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                    )

                                    # 終了
                                    break

                                else:
                                    # state 記述済みにマーク
                                    state_info[now_cmd] = "1"

                                    # parameterのリスト取得中の場合にstate中に変更
                                    if mysts == 6:
                                        mysts = 5

                        elif mysts in [7, 8]:
                            # コマンドが既に設定済みか判定
                            if command_info[now_cmd] == "1":
                                mysts, result_code, command_info, command_line_no = self.errorCommand(
                                    mysts, result_code, command_info, command_line_no,
                                    "MSG-10155", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            else:
                                arry_list = read_line.split(":")
                                if len(arry_list) < 2:
                                    mysts, result_code, command_info, command_line_no = self.errorCommand(
                                        mysts, result_code, command_info, command_line_no,
                                        "MSG-10156", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                    )

                                    # 終了
                                    break

                                expect = arry_list[1].strip().rstrip()
                                if expect == "":
                                    mysts, result_code, command_info, command_line_no = self.errorCommand(
                                        mysts, result_code, command_info, command_line_no,
                                        "MSG-10156", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                    )

                                    # 終了
                                    break

                                else:
                                    # command 記述済みにマーク
                                    command_info[now_cmd] = "1"

                                    # リスト取得中の場合にcommand中に変更
                                    if mysts == 8:
                                        mysts = 7

                        else:
                            mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                mysts, result_code, state_info, state_line_no,
                                "MSG-10159", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                            )

                            # 終了
                            break

                    ################################################################
                    # exec_list=>state:->shell:キーか判定
                    ################################################################
                    elif read_line.startswith("    shell:"):
                        now_cmd = "shell"
                        if mysts in [5, 6]:
                            # コマンドが既に設定済みか判定
                            if state_info[now_cmd] == "1":
                                mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                    mysts, result_code, state_info, state_line_no,
                                    "MSG-10127", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            else:
                                arry_list = read_line.split(":")
                                if len(arry_list) < 2:
                                    mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                        mysts, result_code, state_info, state_line_no,
                                        "MSG-10126", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                    )

                                    # 終了
                                    break

                                # パラメータが文字列(ファイル名または変数？)か判定
                                expect = arry_list[1].strip().rstrip()
                                if expect == "":
                                    mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                        mysts, result_code, state_info, state_line_no,
                                        "MSG-10126", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                    )

                                    # 終了
                                    break

                                else:
                                    # state 記述済みにマーク
                                    state_info[now_cmd] = "1"

                                    # parameterのリスト取得中の場合にstate中に変更
                                    if mysts == 6:
                                        mysts = 5

                        else:
                            mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                mysts, result_code, state_info, state_line_no,
                                "MSG-10128", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                            )

                            # 終了
                            break

                    ################################################################
                    # exec_list=>state:->parameter:キーか判定
                    ################################################################
                    elif read_line.startswith("    parameter:"):
                        now_cmd = "parameter"
                        if mysts == 5:
                            # コマンドが既に設定済みか判定　　　※デットルート
                            if state_info[now_cmd] == "1":
                                mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                    mysts, result_code, state_info, state_line_no,
                                    "MSG-10127", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            # パラメータが空白か判定
                            ret = re.match(r"^( ){4}(\S)+:(\s)*$", read_line)
                            if not ret:
                                mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                    mysts, result_code, state_info, state_line_no,
                                    "MSG-10126", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )
                                # 終了
                                break

                            else:
                                # parameter 記述済みにマーク
                                state_info[now_cmd] = "1"

                                # parameterのリスト取得中
                                mysts = 6

                        else:
                            mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                mysts, result_code, state_info, state_line_no,
                                "MSG-10128", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                            )

                            # 終了
                            break
                    ################################################################
                    # exec_list=>state:->parameter:->-キーか判定
                    # exec_list=>command:->with_items:->-キーか判定
                    # exec_list=>command:->when:->-キーか判定:1
                    # exec_list=>command:->exec_when:->-キーか判定:1
                    # exec_list=>command:->failed_when:->-キーか判定:1
                    ################################################################
                    # - # xx の場合にread_line.splitで-の後ろのスペースが削られる
                    elif read_line.startswith("      - ") or read_line.startswith("      -"):
                        if mysts == 6:
                            now_cmd = "- (parameter)"
                            arry_list = read_line.split("-")
                            if len(arry_list) < 2:
                                mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                    mysts, result_code, state_info, state_line_no,
                                    "MSG-10126", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            expect = arry_list[1].strip().rstrip()
                            if expect == "":
                                mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                    mysts, result_code, state_info, state_line_no,
                                    "MSG-10126", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            else:
                                # parameter - 記述済みにマーク
                                state_info[now_cmd] = "1"

                        elif mysts == 8:
                            now_cmd = "- (%s)" % (now_when_cmd)
                            arry_list = read_line.split("-")
                            if len(arry_list) < 2:
                                mysts, result_code, command_info, command_line_no = self.errorCommand(
                                    mysts, result_code, command_info, command_line_no,
                                    "MSG-10156", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            expect = arry_list[1].strip().rstrip()
                            if expect == "":
                                mysts, result_code, command_info, command_line_no = self.errorCommand(
                                    mysts, result_code, command_info, command_line_no,
                                    "MSG-10156", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            else:
                                # 記述済みにマーク
                                command_info[now_cmd] = "1"

                        else:
                            mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                mysts, result_code, state_info, state_line_no,
                                "MSG-10159", [in_host_name, os.path.basename(in_file_name), line_no, read_line]
                            )

                            # 終了
                            break

                    ################################################################
                    # exec_list=>state:->stdout_file:キーか判定:1
                    ################################################################
                    elif read_line.startswith("    stdout_file:"):
                        now_cmd = "stdout_file"
                        if mysts in [5, 6]:
                            # コマンドが既に設定済みか判定
                            if state_info[now_cmd] == "1":
                                mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                    mysts, result_code, state_info, state_line_no,
                                    "MSG-10127", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            # パラメータが文字列か判定
                            arry_list = read_line.split("stdout_file:")
                            if len(arry_list) < 2:
                                mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                    mysts, result_code, state_info, state_line_no,
                                    "MSG-10126", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            stdout_file = arry_list[1].strip().rstrip()
                            if stdout_file == "":
                                mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                    mysts, result_code, state_info, state_line_no,
                                    "MSG-10126", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            else:
                                # state 記述済みにマーク
                                state_info[now_cmd] = "1"

                                # parameterのリスト取得中の場合にstate中に変更
                                if mysts == 6:
                                    mysts = 5

                        else:
                            mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                mysts, result_code, state_info, state_line_no,
                                "MSG-10128", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                            )

                            # 終了
                            break

                    ################################################################
                    # exec_list=>state:->success_exit:キーか判定:1
                    ################################################################
                    elif read_line.startswith("    success_exit:"):
                        now_cmd = "success_exit"
                        if mysts in [5, 6]:
                            # コマンドが既に設定済みか判定
                            if state_info[now_cmd] == "1":
                                mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                    mysts, result_code, state_info, state_line_no,
                                    "MSG-10127", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            # パラメータにyes/noか変数が指定されているか判定
                            ret = 0
                            for ignore_errors_preg_match in ignore_errors_preg_match_array:
                                if re.match(ignore_errors_preg_match, read_line):
                                    ret = 1

                            if ret != 1:
                                mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                    mysts, result_code, state_info, state_line_no,
                                    "MSG-10126", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            else:
                                # state 記述済みにマーク
                                state_info[now_cmd] = "1"

                                # parameterのリスト取得中の場合にstate中に変更
                                if mysts == 6:
                                    mysts = 5

                        else:
                            mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                mysts, result_code, state_info, state_line_no,
                                "MSG-10128", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                            )

                            # 終了
                            break

                    ################################################################
                    # exec_list=>state:->ignore_errors:キーか判定:1
                    ################################################################
                    elif read_line.startswith("    ignore_errors:"):
                        now_cmd = "ignore_errors"
                        if mysts == 9:
                            # コマンドが既に設定済か判定
                            if localaction_info[now_cmd] == "1":
                                mysts, result_code, localaction_info, localaction_line_no = self.errorlocalaction(
                                    mysts, result_code, localaction_info, localaction_line_no,
                                    "MSG-10162", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            # パラメータにyes/noか変数が指定されているか判定
                            ret = 0
                            for ignore_errors_preg_match in ignore_errors_preg_match_array:
                                if re.match(ignore_errors_preg_match, read_line):
                                    ret = 1

                            if ret != 1:
                                mysts, result_code, localaction_info, localaction_line_no = self.errorlocalaction(
                                    mysts, result_code, localaction_info, localaction_line_no,
                                    "MSG-10161", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            mysts = 3

                        elif mysts in [5, 6]:
                            # コマンドが既に設定済みか判定
                            if state_info[now_cmd] == "1":
                                mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                    mysts, result_code, state_info, state_line_no,
                                    "MSG-10127", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            # パラメータにyes/noか変数が指定されているか判定
                            ret = 0
                            for ignore_errors_preg_match in ignore_errors_preg_match_array:
                                if re.match(ignore_errors_preg_match, read_line):
                                    ret = 1

                            if ret != 1:
                                mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                    mysts, result_code, state_info, state_line_no,
                                    "MSG-10126", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            else:
                                # state 記述済みにマーク
                                state_info[now_cmd] = "1"

                                # parameterのリスト取得中の場合にstate中に変更
                                if mysts == 6:
                                    mysts = 5

                        else:
                            mysts, result_code, state_info, state_line_no = self.errorstateCommand(
                                mysts, result_code, state_info, state_line_no,
                                "MSG-10128", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                            )

                            # 終了
                            break

                    ################################################################
                    # exec_list=>command:キーか判定:1
                    ################################################################
                    elif read_line.startswith("  - command:"):
                        now_cmd = "command"

                        # 一個前のコマンドに問題がないか判定
                        ret, mysts, result_code, state_info, state_line_no, command_info, command_line_no = self.beforCommandCheck(
                            mysts, result_code, state_info, state_line_no, command_info, command_line_no,
                            in_file_name, in_host_name
                        )
                        if ret is False:
                            break

                        if mysts == 3:
                            mysts = 7

                            # commandの情報を初期化
                            command_info, command_line_no = self.initCommandInfo(command_info, command_line_no, line_no)

                            arry_list = read_line.split(":")
                            if len(arry_list) < 2:
                                mysts, result_code, command_info, command_line_no = self.errorCommand(
                                    mysts, result_code, command_info, command_line_no,
                                    "MSG-10153", [in_host_name, os.path.basename(in_file_name), line_no]
                                )

                                # 終了
                                break

                            expect = arry_list[1].strip().rstrip()
                            if expect == "":
                                mysts, result_code, command_info, command_line_no = self.errorCommand(
                                    mysts, result_code, command_info, command_line_no,
                                    "MSG-10153", [in_host_name, os.path.basename(in_file_name), line_no]
                                )

                                # 終了
                                break

                            else:
                                # command 記述済みにマーク
                                command_info[now_cmd] = "1"

                        else:
                            mysts, result_code, command_info, command_line_no = self.errorCommand(
                                mysts, result_code, command_info, command_line_no,
                                "MSG-10154", [in_host_name, os.path.basename(in_file_name), line_no]
                            )

                            # 終了
                            break

                    ################################################################
                    # exec_list=>command:->timeout:キーか判定:1
                    ################################################################
                    elif read_line.startswith("    timeout:"):
                        now_cmd = "timeout"
                        if mysts in [7, 8]:
                            # コマンドが既に設定済みか判定
                            if command_info[now_cmd] == "1":
                                mysts, result_code, command_info, command_line_no = self.errorCommand(
                                    mysts, result_code, command_info, command_line_no,
                                    "MSG-10155", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            else:
                                arry_list = read_line.split(":")
                                if len(arry_list) < 2:
                                    mysts, result_code, command_info, command_line_no = self.errorCommand(
                                        mysts, result_code, command_info, command_line_no,
                                        "MSG-10156", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                    )
                                    break

                                timeout = arry_list[1].strip().rstrip()
                                if timeout == "":
                                    mysts, result_code, command_info, command_line_no = self.errorCommand(
                                        mysts, result_code, command_info, command_line_no,
                                        "MSG-10156", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                    )
                                    break

                                # パラメータ記述済みにマーク
                                command_info[now_cmd] = "1"

                                # リスト取得中の場合にcommand中に変更
                                if mysts == 8:
                                    mysts = 7

                        else:
                            mysts, result_code, command_info, command_line_no = self.errorCommand(
                                mysts, result_code, command_info, command_line_no,
                                "MSG-10157", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                            )
                            break

                    ################################################################
                    # exec_list=>command:->register:キーか判定:1
                    ################################################################
                    elif read_line.startswith("    register:"):
                        now_cmd = "register"
                        if mysts in [7, 8]:
                            # コマンドが既に設定済みか判定
                            if command_info[now_cmd] == "1":
                                mysts, result_code, command_info, command_line_no = self.errorCommand(
                                    mysts, result_code, command_info, command_line_no,
                                    "MSG-10155", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            else:
                                arry_list = read_line.split(":")
                                if len(arry_list) < 2:
                                    mysts, result_code, command_info, command_line_no = self.errorCommand(
                                        mysts, result_code, command_info, command_line_no,
                                        "MSG-10156", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                    )

                                    # 終了
                                    break

                                if arry_list[1].strip().rstrip() == "":
                                    mysts, result_code, command_info, command_line_no = self.errorCommand(
                                        mysts, result_code, command_info, command_line_no,
                                        "MSG-10156", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                    )

                                    # 終了
                                    break

                                else:
                                    # パラメータ記述済みにマーク
                                    command_info[now_cmd] = "1"

                                    # リスト取得中の場合にcommand中に変更
                                    if mysts == 8:
                                        mysts = 7

                        else:
                            mysts, result_code, command_info, command_line_no = self.errorCommand(
                                mysts, result_code, command_info, command_line_no,
                                "MSG-10157", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                            )

                            # 終了
                            break

                    ################################################################
                    # exec_list=>command:->with_items:キーか判定:1
                    ################################################################
                    elif read_line.startswith("    with_items:"):
                        now_cmd = "with_items"
                        if mysts in [7, 8]:
                            # コマンドが既に設定済みか判定
                            if command_info[now_cmd] == "1":
                                mysts, result_code, command_info, command_line_no = self.errorCommand(
                                    mysts, result_code, command_info, command_line_no,
                                    "MSG-10155", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            else:
                                arry_list = read_line.split(":")
                                if len(arry_list) < 2:
                                    mysts, result_code, command_info, command_line_no = self.errorCommand(
                                        mysts, result_code, command_info, command_line_no,
                                        "MSG-10156", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                    )

                                    # 終了
                                    break

                                # パラメータが空白か判定
                                ret = re.match(r"^( ){4}(\S)+:(\s)*$", read_line)
                                if not ret:
                                    mysts, result_code, command_info, command_line_no = self.errorCommand(
                                        mysts, result_code, command_info, command_line_no,
                                        "MSG-10156", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                    )

                                    # 終了
                                    break

                                else:
                                    # パラメータ記述済みにマーク
                                    command_info[now_cmd] = "1"
                                    now_when_cmd = now_cmd

                                    # with_itemsのリスト取得中
                                    mysts = 8

                        else:
                            mysts, result_code, command_info, command_line_no = self.errorCommand(
                                mysts, result_code, command_info, command_line_no,
                                "MSG-10157", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                            )

                            # 終了
                            break

                    ################################################################
                    # exec_list=>command:->when:キーか判定:1
                    ################################################################
                    elif read_line.startswith("    when:"):
                        now_cmd = "when"
                        if mysts in [7, 8]:
                            # コマンドが既に設定済みか判定
                            if command_info[now_cmd] == "1":
                                mysts, result_code, command_info, command_line_no = self.errorCommand(
                                    mysts, result_code, command_info, command_line_no,
                                    "MSG-10155", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            else:
                                arry_list = read_line.split(":")
                                if len(arry_list) < 2:
                                    mysts, result_code, command_info, command_line_no = self.errorCommand(
                                        mysts, result_code, command_info, command_line_no,
                                        "MSG-10156", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                    )

                                    # 終了
                                    break

                                # パラメータが空白か判定
                                ret = re.match(r"^( ){4}(\S)+:(\s)*$", read_line)
                                if not ret:
                                    mysts, result_code, command_info, command_line_no = self.errorCommand(
                                        mysts, result_code, command_info, command_line_no,
                                        "MSG-10156", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                    )

                                    # 終了
                                    break

                                else:
                                    # パラメータ記述済みにマーク
                                    command_info[now_cmd] = "1"
                                    now_when_cmd = now_cmd

                                    # whenのリスト取得中
                                    mysts = 8

                        else:
                            mysts, result_code, command_info, command_line_no = self.errorCommand(
                                mysts, result_code, command_info, command_line_no,
                                "MSG-10157", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                            )

                            # 終了
                            break

                    ################################################################
                    # exec_list=>command:->failed_when:キーか判定:1
                    ################################################################
                    elif read_line.startswith("    failed_when:"):
                        now_cmd = "failed_when"
                        if mysts in [7, 8]:
                            # コマンドが既に設定済みか判定
                            if command_info[now_cmd] == "1":
                                mysts, result_code, command_info, command_line_no = self.errorCommand(
                                    mysts, result_code, command_info, command_line_no,
                                    "MSG-10155", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            else:
                                arry_list = read_line.split(":")
                                if len(arry_list) < 2:
                                    mysts, result_code, command_info, command_line_no = self.errorCommand(
                                        mysts, result_code, command_info, command_line_no,
                                        "MSG-10156", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                    )

                                    # 終了
                                    break

                                # パラメータが空白か判定
                                ret = re.match(r"^( ){4}(\S)+:(\s)*$", read_line)
                                if not ret:
                                    mysts, result_code, command_info, command_line_no = self.errorCommand(
                                        mysts, result_code, command_info, command_line_no,
                                        "MSG-10156", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                    )

                                    # 終了
                                    break

                                else:
                                    # パラメータ記述済みにマーク
                                    command_info[now_cmd] = "1"
                                    now_when_cmd = now_cmd

                                    # whenのリスト取得中
                                    mysts = 8

                        else:
                            mysts, result_code, command_info, command_line_no = self.errorCommand(
                                mysts, result_code, command_info, command_line_no,
                                "MSG-10157", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                            )

                            # 終了
                            break

                    ################################################################
                    # exec_list=>command:->exec_when:キーか判定:1
                    ################################################################
                    elif read_line.startswith("    exec_when:"):
                        now_cmd = "exec_when"
                        if mysts in [7, 8]:
                            # コマンドが既に設定済みか判定
                            if command_info[now_cmd] == "1":
                                mysts, result_code, command_info, command_line_no = self.errorCommand(
                                    mysts, result_code, command_info, command_line_no,
                                    "MSG-10155", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                )

                                # 終了
                                break

                            else:
                                arry_list = read_line.split(":")
                                if len(arry_list) < 2:
                                    mysts, result_code, command_info, command_line_no = self.errorCommand(
                                        mysts, result_code, command_info, command_line_no,
                                        "MSG-10156", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                    )

                                    # 終了
                                    break

                                # パラメータが空白か判定
                                ret = re.match(r"^( ){4}(\S)+:(\s)*$", read_line)
                                if not ret:
                                    mysts, result_code, command_info, command_line_no = self.errorCommand(
                                        mysts, result_code, command_info, command_line_no,
                                        "MSG-10156", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                                    )

                                    # 終了
                                    break

                                else:
                                    # パラメータ記述済みにマーク
                                    command_info[now_cmd] = "1"
                                    now_when_cmd = now_cmd

                                    # exec_whenのリスト取得中
                                    mysts = 8

                        else:
                            mysts, result_code, command_info, command_line_no = self.errorCommand(
                                mysts, result_code, command_info, command_line_no,
                                "MSG-10157", [in_host_name, os.path.basename(in_file_name), line_no, now_cmd]
                            )

                            # 終了
                            break

                    elif read_line.strip() != "":
                        msgstr = g.appmsg.get_api_message("MSG-10117", [in_host_name, os.path.basename(in_file_name), line_no])
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        result_code = False
                        break

                # 対話ファイルが正しく終了しているか判定
                if mysts == 0:
                    msgstr = g.appmsg.get_api_message("MSG-10129", [in_host_name, os.path.basename(in_file_name)])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    result_code = False

                elif mysts == 1:
                    msgstr = g.appmsg.get_api_message("MSG-10130", [in_host_name, os.path.basename(in_file_name)])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    result_code = False

                elif mysts == 2:
                    msgstr = g.appmsg.get_api_message("MSG-10131", [in_host_name, os.path.basename(in_file_name)])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    result_code = False

                elif mysts == 4:
                    msgstr = g.appmsg.get_api_message("MSG-10132", [in_host_name, os.path.basename(in_file_name)])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    result_code = False

                elif mysts in [5, 6]:
                    # 1個前のstateコマンドの構文が正しいか判定
                    # result_codeはエラーの場合にFalseになる
                    ret, mysts, result_code, state_info, state_line_no = self.checkstateCommand(
                        mysts, result_code, state_info, state_line_no, in_file_name, in_host_name)

                elif mysts in [7, 8]:
                    # 1個前のstateコマンドの構文が正しいか判定
                    # result_codeはエラーの場合にFalseになる
                    ret, mysts, result_code, command_info, command_line_no = self.checkCommand(
                        mysts, result_code, command_info, command_line_no, in_file_name, in_host_name)

                elif mysts == 9:
                    pass
            obj.close()
        except Exception as e:
            msgstr = g.appmsg.get_api_message("MSG-10104", [in_host_name, os.path.basename(in_file_name)])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            result_code = False
            raise Exception(e)

        return result_code

    def str_to_num(self, s):
        try:
            n = float(s)
        except ValueError:
            # #2199 数値判定をしているだけなのでログ出力不要
            return False

        return n

    def beforCommandCheck(self, mysts, result_code, state_info, state_line_no, command_info, command_line_no, in_file_name, in_host_name):
        """
        一個前のコマンドに問題がないか判定
        Arguments:
            mysts:   対話ファイルのチェック状態
            result_code:    モジュール戻り値
            state_info:     stateコマンドパラメータ設定有無配列
            state_line_no:  stateコマンド行番号 退避用
            command_info:     commandコマンドパラメータ設定有無配列
            command_line_no:  commandコマンド行番号 退避用
            in_file_name:   対話ファイル名
            in_host_name:   ホスト名
        Returns:
            True/False, mysts, result_code, state_info, state_line_no, command_info, command_line_no
        """
        # 一個前のがlocalactionの場合
        if mysts == 9:
            mysts = 3

        # 一個前のがstateの場合
        elif mysts in [5, 6]:
            ret, mysts, result_code, state_info, state_line_no = self.checkstateCommand(
                mysts, result_code, state_info, state_line_no, in_file_name, in_host_name)
            if ret is False:
                return ret, mysts, result_code, state_info, state_line_no, command_info, command_line_no

            # 対話ファイルのチェック状態を戻す
            mysts = 3

        # 一個前のがCommandの場合
        elif mysts in [7, 8]:
            # 1個前のcommandの構文が正しいか判定
            ret, mysts, result_code, command_info, command_line_no = self.checkCommand(mysts, result_code, command_info, command_line_no, in_file_name, in_host_name)
            #  対話ファイルのチェック状態を戻す
            if ret is False:
                return ret, mysts, result_code, state_info, state_line_no, command_info, command_line_no

            mysts = 3

        return True, mysts, result_code, state_info, state_line_no, command_info, command_line_no

    def checkstateCommand(self, in_state_sts, in_result_code, in_state_info, in_state_line_no, in_file_name, in_host_name):
        """
        一個前のコマンドに問題がないか判定
        Arguments:
            in_mysts:  対話ファイルのチェック状態
            in_result_code:  モジュール戻り値
            in_state_info:     stateコマンドパラメータ設定有無配列
            in_state_line_no:  stateコマンド行番号 退避用
            in_file_name:  対話ファイル名
            in_host_name:  ホスト名
        Returns:
            True/False, in_state_sts, in_result_code, in_state_info, in_state_line_no
        """
        # パラメータリスト
        cmd_list = ["state", "prompt", "shell", "parameter", "- (parameter)", "stdout_file", "success_exit", "ignore_errors"]

        # パラメータ必須設定判定リスト
        ok_list = [
            {
                "state": "1",
                "prompt": "1",
                "shell": "?",
                "parameter": "?",
                "- (parameter)": "?",
                "stdout_file": "?",
                "success_exit": "?",
                "ignore_errors": "?"
            }
        ]

        # パラメータ組み合わせ設定判定リスト
        # check_list:    指定パラメータの設定条件 複数可能(and)
        # relation_list: 指定パラメータと関連するパラメータ設定条件 複数可能(and)
        combination_list = [
            {
                'check_list': {'parameter': '1'},
                'relation_list': {'parameter': '1', '- (parameter)': '1'}
            }
        ]

        result_code = False
        pattern_ret = True
        error_list = {}
        for pattern in ok_list:
            for cmd in cmd_list:
                # 任意入力のパラメータでないか判定
                if pattern[cmd] != "?":
                    # パラメータの設定が正しいか判定
                    if pattern[cmd] != in_state_info[cmd]:
                        # エラーになったパラメータを退避
                        error_list[cmd] = "1"
                        pattern_ret = False

            # チェックがOKなら次のパターンチェックはしない
            if pattern_ret is True:
                result_code = True
                break

        if result_code is True:
            error_list = {}
            for pattern in combination_list:
                hit = True
                for cmd, value in pattern['check_list'].items():
                    if in_state_info[cmd] != value:
                        hit = False
                        break

                if hit is True:
                    for cmd, value in pattern['relation_list'].items():
                        if in_state_info[cmd] != value:
                            error_list[cmd] = "1"
                            result_code = False

        if result_code is False:
            error_str = ""

            # エラーになったパラメータを取出
            for cmd, val in error_list.items():
                if len(error_str) > 0:
                    error_str = '%s/%s:' % (error_str, cmd)

                else:
                    error_str = '%s%s:' % (error_str, cmd)

            # エラーになったパラメータをメッセージで表示
            in_state_sts, in_result_code, in_state_sts, in_state_line_no = self.errorstateCommand(
                in_state_sts, in_result_code, in_state_sts, in_state_line_no,
                "MSG-10133",
                [in_host_name, os.path.basename(in_file_name), in_state_line_no, error_str]
            )

        in_state_info, in_state_line_no = self.initstateCommandInfo(in_state_info, in_state_line_no, 0)

        return result_code, in_state_sts, in_result_code, in_state_info, in_state_line_no

    def errorstateCommand(self, in_mysts, in_result_code, in_state_info, in_state_line_no, in_error_code, ina_error_info):
        """
        stateコマンドのパラメータでエラーがあった場合の処理
        Arguments:
            in_mysts:  対話ファイルのチェック状態
            in_result_code:  モジュール戻り値
            in_state_info:     stateコマンドパラメータ設定有無配列
            in_state_line_no:  stateコマンド行番号 退避用
            in_error_code:   エラーメッセージコード
            ina_error_info:  エラーメッセージパラメータ
        Returns:
            in_mysts, in_result_code, in_state_info, in_state_line_no
        """
        # エラーメッセージを出力
        msgstr = g.appmsg.get_api_message(in_error_code, ina_error_info)
        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                           str(inspect.currentframe().f_lineno), msgstr)

        in_result_code = False
        in_mysts = 3

        # stateコマンドのパラメータ設定有無をクリア
        in_state_info, in_state_line_no = self.initstateCommandInfo(in_state_info, in_state_line_no, in_state_line_no)

        return in_mysts, in_result_code, in_state_info, in_state_line_no

    def initstateCommandInfo(self, in_state_info, in_state_line_no, in_line_no):
        """
        stateコマンドのパラメータ情報初期化
        Arguments:
            in_state_info:     stateコマンドパラメータ設定有無配列
            in_state_line_no:  stateコマンド行番号 退避用
            in_line_no:   エラーメッセージコード
        Returns:
            in_state_info, in_state_line_no
        """
        # stateコマンドのパラメータ設定有無をクリア
        in_state_info = {}
        in_state_info["state"] = "0"
        in_state_info["prompt"] = "0"
        in_state_info["shell"] = "0"
        in_state_info["parameter"] = "0"
        in_state_info["- (parameter)"] = "0"
        in_state_info["stdout_file"] = "0"
        in_state_info["success_exit"] = "0"
        in_state_info["ignore_errors"] = "0"

        # stateコマンドの行番号を退避
        in_state_line_no = in_line_no

        return in_state_info, in_state_line_no

    def checkCommand(self, in_mysts, in_result_code, in_command_info, in_command_line_no, in_file_name, in_host_name):
        """
        対話ファイルの独自フォーマットをチェックする。
        Arguments:
            in_mysts:         対話ファイルのチェック状態
            in_result_code:   モジュール戻り値
            in_command_info:      commandコマンドパラメータ設定有無配列
            in_command_line_no:   commandコマンド行番号 退避用
            in_file_name:   対話ファイル名
            in_host_name:   ホスト名
        Returns:
            True/False, in_mysts, in_result_code, in_command_info, in_command_line_no
        """
        # パラメータリスト
        cmd_list = [
            "command", "prompt", "timeout", "register",
            "with_items", "when", "failed_when", "exec_when",
            "- (with_items)", "- (when)", "- (failed_when)", "- (exec_when)"
        ]

        # パラメータ判定リスト
        ok_list = [
            {
                "command": "1", "prompt": "1", "timeout": "?", "register": "?",
                "with_items": "?", "when": "?", "failed_when": "?", "exec_when": "?",
                "- (with_items)": "?", "- (when)": "?", "- (failed_when)": "?", "- (exec_when)": "?",
            }
        ]

        # パラメータ組み合わせ設定判定リスト
        # check_list:    指定パラメータの設定条件 複数可能(and)
        # relation_list: 指定パラメータと関連するパラメータ設定条件 複数可能(and)
        combination_list = [
            {
                'check_list': {'with_items': '1'},
                'relation_list': {'with_items': '1', '- (with_items)': '1'},
            },
            {
                'check_list': {'when': '1'},
                'relation_list': {'when': '1', '- (when)': '1'},
            },
            {
                'check_list': {'exec_when': '1'},
                'relation_list': {'exec_when': '1', '- (exec_when)': '1'},
            },
            {
                'check_list': {'failed_when': '1'},
                'relation_list': {'failed_when': '1', '- (failed_when)': '1'},
            },
        ]

        result_code = False
        pattern_ret = True
        error_list = {}
        for pattern in ok_list:
            for cmd in cmd_list:
                # 任意入力のパラメータでないか判定
                if pattern[cmd] != "?":
                    # パラメータの設定が正しいか判定
                    if pattern[cmd] != in_command_info[cmd]:
                        # エラーになったパラメータを退避
                        error_list[cmd] = "1"
                        pattern_ret = False

            # チェックがOKなら次のパターンチェックはしない
            if pattern_ret is True:
                result_code = True
                break

        if result_code is True:
            error_list = {}
            for pattern in combination_list:
                hit = True
                for cmd, value in pattern['check_list'].items():
                    if in_command_info[cmd] != value:
                        hit = False
                        break

                if hit is True:
                    for cmd, value in pattern['relation_list'].items():
                        if in_command_info[cmd] != value:
                            error_list[cmd] = "1"
                            result_code = False

        if result_code is False:
            error_str = ""

            # エラーになったパラメータを取出
            for cmd, val in error_list.items():
                if len(error_str) > 0:
                    error_str = '%s/%s:' % (error_str, cmd)

                else:
                    error_str = '%s%s:' % (error_str, cmd)

            # エラーになったパラメータをメッセージで表示
            in_mysts, in_result_code, in_command_info, in_command_line_no = self.errorCommand(
                in_mysts, in_result_code, in_command_info, in_command_line_no,
                "MSG-10158",
                [in_host_name, os.path.basename(in_file_name), in_command_line_no, error_str]
            )

        in_command_info, in_command_line_no = self.initCommandInfo(in_command_info, in_command_line_no, 0)

        return result_code, in_mysts, in_result_code, in_command_info, in_command_line_no

    def errorCommand(self, in_mysts, in_result_code, in_command_info, in_command_line_no, in_error_code, ina_error_info):
        """
        commandコマンドのパラメータでエラーがあった場合の処理
        Arguments:
            in_mysts:         対話ファイルのチェック状態
            in_result_code:   モジュール戻り値
            in_command_info:      commandコマンドパラメータ設定有無配列
            in_command_line_no:   commandコマンド行番号 退避用
            in_error_code:    エラーメッセージコード
            ina_error_info:   エラーメッセージパラメータ
        Returns:
            in_mysts, in_result_code, in_command_info, in_command_line_no
        """
        # エラーメッセージを出力
        msgstr = g.appmsg.get_api_message(in_error_code, ina_error_info)
        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                           str(inspect.currentframe().f_lineno), msgstr)

        in_result_code = False
        in_mysts = 3

        # commandのパラメータ設定有無をクリア
        in_command_info, in_command_line_no = self.initCommandInfo(in_command_info, in_command_line_no, in_command_line_no)

        return in_mysts, in_result_code, in_command_info, in_command_line_no

    def initCommandInfo(self, in_command_info, in_command_line_no, in_line_no):
        """
        commandコマンドのパラメータ情報初期化
        Arguments:
            in_command_info:      commandコマンドパラメータ設定有無配列
            in_command_line_no:   commandコマンド行番号 退避用
            in_line_no:    エラーメッセージコード
        Returns:
            in_command_info, in_command_line_no
        """
        # commandコマンドのパラメータ設定有無をクリア
        in_command_info = {}
        in_command_info["command"] = "0"
        in_command_info["prompt"] = "0"
        in_command_info["timeout"] = "0"
        in_command_info["register"] = "0"
        in_command_info["with_items"] = "0"
        in_command_info["when"] = "0"
        in_command_info["failed_when"] = "0"
        in_command_info["exec_when"] = "0"
        in_command_info["- (with_items)"] = "0"
        in_command_info["- (when)"] = "0"
        in_command_info["- (failed_when)"] = "0"
        in_command_info["- (exec_when)"] = "0"

        # commandコマンドの行番号を退避
        in_command_line_no = in_line_no

        return in_command_info, in_command_line_no

    def initlocalactionInfo(self, in_localaction_info, in_localaction_line_no, in_line_no):
        """
        localactionコマンドのパラメータ情報初期化
        Arguments:
            in_localaction_info:      localactionコマンドパラメータ設定有無配列
            in_localaction_line_no:   localactionコマンド行番号 退避用
            in_line_no:               localactionコマンド行番号
        Returns:
            in_localaction_info, in_localaction_line_no
        """
        # localactionコマンドのパラメータ設定有無をクリア
        in_localaction_info = {}
        in_localaction_info["localaction"] = "0"
        in_localaction_info["ignore_errors"] = "0"

        # localactionコマンドの行番号を退避
        in_localaction_line_no = in_line_no

        return in_localaction_info, in_localaction_line_no

    def errorlocalaction(self, in_mysts, in_result_code, in_localaction_info, in_localaction_line_no, in_error_code, ina_error_info):
        """
        localactionコマンドのパラメータでエラーがあった場合の処理
        Arguments:
            in_mysts:                対話ファイルのチェック状態
            in_result_code:          モジュール戻り値
            in_localaction_info:     localactionコマンドパラメータ設定有無配列
            in_localaction_line_no:  localactionコマンド行番号 退避用
            in_error_code:           エラーメッセージコード
            ina_error_info:          エラーメッセージパラメータ
        Returns:
            in_mysts, in_result_code, in_localaction_info, in_localaction_line_no
        """
        # エラーメッセージを出力
        msgstr = g.appmsg.get_api_message(in_error_code, ina_error_info)
        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                           str(inspect.currentframe().f_lineno), msgstr)

        in_result_code = False
        in_mysts = 3

        # localactionコマンドのパラメータ設定有無をクリア
        in_localaction_info, in_localaction_line_no = self.initstateCommandInfo(in_localaction_info, in_localaction_line_no, in_localaction_line_no)

        return in_mysts, in_result_code, in_localaction_info, in_localaction_line_no

    def getArrayTypeValuecount(self, val):
        ret = self.isJsonString(val)
        if ret is False:
            return 0
        else:
            return len(val)

    def getDBLegacyPlaybookList(self, in_movement_id, mt_child_playbooks):
        """
        Legacyで実行する子PlayBookファイルをデータベースより取得する。
        2.0では不要な処理なので、空リターンする
        Arguments:
            in_pattern_id:       MovementID
            mt_child_playbooks:  PlayBookファイル返却配列
                                 [INCLUDE順序][素材管理Pkey]=>素材ファイル
        Returns:
            bool, mt_child_playbooks
        """
        # B_ANSIBLE_LNS_PLAYBOOKに対するDISUSE_FLAG = '0'の
        # 条件はSELECT文に入れない。
        sql = """\
              SELECT
                  TBL_1.MVMT_MATL_LINK_ID,
                  TBL_1.PLAYBOOK_MATTER_ID,
                  TBL_1.INCLUDE_SEQ,
                  TBL_2.PLAYBOOK_MATTER_FILE,
                  TBL_2.DISUSE_FLAG
              FROM
                  (
                  SELECT
                      TBL3.MVMT_MATL_LINK_ID,
                      TBL3.MOVEMENT_ID,
                      TBL3.PLAYBOOK_MATTER_ID,
                      TBL3.INCLUDE_SEQ
                  FROM
                      T_ANSL_MVMT_MATL_LINK TBL3
                  WHERE
                      TBL3.MOVEMENT_ID = %s AND
                      TBL3.DISUSE_FLAG = '0'
                  )TBL_1
              LEFT OUTER JOIN T_ANSL_MATL_COLL TBL_2 ON (TBL_1.PLAYBOOK_MATTER_ID = TBL_2.PLAYBOOK_MATTER_ID)
              ORDER BY TBL_1.INCLUDE_SEQ """

        rows = self.lv_objDBCA.sql_execute(sql, [in_movement_id])

        mt_child_playbooks = {}

        for row in rows:
            if row['DISUSE_FLAG'] == '0':
                if not row['PLAYBOOK_MATTER_FILE']:
                    msgstr = g.appmsg.get_api_message("MSG-10906", [row['PLAYBOOK_MATTER_ID']])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    return False, mt_child_playbooks

                if row['INCLUDE_SEQ'] not in mt_child_playbooks:
                    mt_child_playbooks[row['INCLUDE_SEQ']] = {}
                mt_child_playbooks[row['INCLUDE_SEQ']][row['PLAYBOOK_MATTER_ID']] = row['PLAYBOOK_MATTER_FILE']

            # 素材管理(B_ANSIBLE_LNS_PLAYBOOK)にPlaybookが未登録の場合
            elif not row['DISUSE_FLAG']:
                msgstr = g.appmsg.get_api_message("MSG-10179", [row['MVMT_MATL_LINK_ID']])
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)
                return False, mt_child_playbooks
            # DISUSE_FLAG = '1'は読み飛ばし

        # 紐付の数を確認
        if len(rows) < 1:
            msgstr = g.appmsg.get_api_message("MSG-10180", [in_movement_id])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, mt_child_playbooks

        # 対象playbookの数を確認
        if len(mt_child_playbooks) < 1:
            msgstr = g.appmsg.get_api_message("MSG-10181", [in_movement_id])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, mt_child_playbooks

        return True, mt_child_playbooks

    def getDBPioneerDialogFileList(self, in_execute_no, in_movement_id, in_operation_id, mt_dialog_files, ina_hostostypelist):
        """
        Pioneerで実行する対話ファイルをデータベースより取得する。
        2.0では不要な処理なので、空リターンする
        Arguments:
            in_execute_no:      作業番号
            in_movement_id:     MovementID
            in_operation_id:    オペレーションID
            mt_dialog_files:    子PlayBookファイル返却配列
                                mt_dialog_files[ホスト名][INCLUDE順番][素材管理Pkey]=対話ファイル
            ina_hostostypelist: ホスト毎OS種別一覧  Pioneerの場合のみ
                                {機器一覧:HOST_NAME': 機器一覧:OS_TYPE_ID'}
        Returns:
            bool, mt_dialog_files
        """

        sql = """
              SELECT
                  TBL_1.MVMT_MATL_LINK_ID,
                  TBL_1.INCLUDE_SEQ,
                  TBL_2.OS_TYPE_ID,
                  TBL_2.DIALOG_MATTER_ID,
                  TBL_2.DIALOG_MATTER_FILE,
                  (
                   SELECT
                       COUNT(*)
                   FROM
                       T_ANSP_DIALOG_TYPE TBL_M
                   WHERE
                       TBL_M.DIALOG_TYPE_ID = TBL_1.DIALOG_TYPE_ID AND
                       TBL_M.DISUSE_FLAG = '0'
                  ) DIALOG_TYPE_ID_COUNT,
                  (
                   SELECT
                       COUNT(*)
                   FROM
                       T_ANSP_OS_TYPE TBL_M
                   WHERE
                       TBL_M.OS_TYPE_ID = TBL_2.OS_TYPE_ID AND
                       TBL_M.DISUSE_FLAG = '0'
                  ) OS_TYPE_ID_COUNT
              FROM
                  (
                   SELECT
                       MVMT_MATL_LINK_ID,
                       DIALOG_TYPE_ID,
                       INCLUDE_SEQ
                   FROM
                       T_ANSP_MVMT_MATL_LINK
                   WHERE
                       MOVEMENT_ID  = %s AND
                       DISUSE_FLAG = '0'
                  )TBL_1
              LEFT OUTER JOIN
                 (
                   SELECT
                       OS_TYPE_ID,
                       DIALOG_TYPE_ID,
                       DIALOG_MATTER_ID,
                       DIALOG_MATTER_FILE
                   FROM
                       T_ANSP_MATL_COLL
                   WHERE
                       OS_TYPE_ID IN (
                                      SELECT
                                          OS_TYPE_ID
                                      FROM
                                          T_ANSC_DEVICE
                                      WHERE
                                          DISUSE_FLAG = '0' AND
                                          SYSTEM_ID in (
                                                        SELECT
                                                            SYSTEM_ID
                                                        FROM
                                                            T_ANSP_TGT_HOST
                                                        WHERE
                                                            EXECUTION_NO = %s AND
                                                            MOVEMENT_ID  = %s AND
                                                            OPERATION_ID = %s AND
                                                            DISUSE_FLAG  = '0'
                                                       )
                                     ) AND
                       DISUSE_FLAG = '0'
                   ) TBL_2 ON (TBL_1.DIALOG_TYPE_ID = TBL_2.DIALOG_TYPE_ID)
               ORDER BY OS_TYPE_ID, INCLUDE_SEQ """

        mt_dialog_files = {}
        w_dialogfilelist = {}

        rows = self.lv_objDBCA.sql_execute(sql, [in_movement_id, in_execute_no, in_movement_id, in_operation_id])

        for row in rows:
            # 対話ファイル素材集の登録確認
            if not row['DIALOG_MATTER_FILE']:
                msgstr = g.appmsg.get_api_message("MSG-10278", [row['DIALOG_MATTER_ID']])
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)
                return False, mt_dialog_files

            #  対話種別の登録確認
            if row['DIALOG_TYPE_ID_COUNT'] == 0:
                msgstr = g.appmsg.get_api_message("MSG-10907", [row['MVMT_MATL_LINK_ID']])
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)
                return False, mt_dialog_files

            #  OS種別の登録確認
            if row['OS_TYPE_ID_COUNT'] == 0:
                msgstr = g.appmsg.get_api_message("MSG-10908", [row['MVMT_MATL_LINK_ID']])
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)
                return False, mt_dialog_files
            if not row['OS_TYPE_ID']:
                msgstr = g.appmsg.get_api_message("MSG-10189", [row['MVMT_MATL_LINK_ID']])
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)
                return False, mt_dialog_files

            #  対話ファイルの情報を退避
            if row['OS_TYPE_ID'] not in w_dialogfilelist:
                w_dialogfilelist[row['OS_TYPE_ID']] = {}
            if row['INCLUDE_SEQ'] not in w_dialogfilelist[row['OS_TYPE_ID']]:
                w_dialogfilelist[row['OS_TYPE_ID']][row['INCLUDE_SEQ']] = {}
            w_dialogfilelist[row['OS_TYPE_ID']][row['INCLUDE_SEQ']][row['DIALOG_MATTER_ID']] = row['DIALOG_MATTER_FILE']

        if len(rows) < 1:
            msgstr = g.appmsg.get_api_message("MSG-10190", [in_movement_id])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, mt_dialog_files

        # 対象playbookの数を確認
        if len(w_dialogfilelist) < 1:
            msgstr = g.appmsg.get_api_message("MSG-10191", [in_movement_id])
            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                               str(inspect.currentframe().f_lineno), msgstr)
            return False, mt_dialog_files

        ret_code = True
        #  ina_hostostypelist[ホスト名]=row[OS種別]
        #  より各ホスト毎のOS種別を取得
        #  w_dialogfilelist[OS種別][インクルード順序][pkey]=子PlayBookファイル
        #  のOS種別と一致する情報を抜出しホスト毎の対話ファイル配列を作成
        #  mt_dialog_files[ホスト][INCLUDE順番][素材管理Pkey]=対話ファイル
        #  ホスト数分繰返す
        for host_name, host_ostype in ina_hostostypelist.items():
            hit = False
            for file_ostype, file_include_list in w_dialogfilelist.items():
                #  OS種別が一致しているか判定
                if host_ostype == file_ostype:
                    hit = True
                    for file_include, file_pkey_list in file_include_list.items():
                        for file_pkey, dialogfile in file_pkey_list.items():
                            #  ホスト毎の対話ファイル配列作成
                            #  [ホストIP][INCLUDE順番][素材管理Pkey]=対話ファイル
                            if host_name not in mt_dialog_files:
                                mt_dialog_files[host_name] = {}
                            if file_include not in mt_dialog_files[host_name]:
                                mt_dialog_files[host_name][file_include] = {}
                            mt_dialog_files[host_name][file_include][file_pkey] = dialogfile
                            hit = True

            if hit is False:
                msgstr = g.appmsg.get_api_message("MSG-10192", [host_name, host_ostype])
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)
                return False, mt_dialog_files

        return ret_code, mt_dialog_files

    def getDBVarList(self,
                     in_execute_no,
                     in_movement_id,
                     in_operation_id,
                     mt_host_vars,
                     mt_pionner_template_host_vars,
                     mt_vault_vars,
                     mt_vault_host_vars_file_list,
                     mt_DB_child_vars_list):
        """
        ansibleで実行する変数をデータベースより取得する。(Legacy/Pioneer)
        Arguments:
            in_execute_no:                  作業番号
            in_movement_id:                  作業パターンID
            in_operation_id:                オペレーションID
            mt_host_vars:                   変数一覧返却配列 (pionner:passwordColumnの具体値がky_encryptで暗号化)
                                            [ホスト名(IP)][ 変数名 ]=>具体値
            mt_pionner_template_host_vars:  pioneer template用 変数一覧返却配列 (passwordColumnの具体値がansible-vaultで暗号化)
                                            [ホスト名(IP)][ 変数名 ]=>具体値
            mt_vault_vars:                  PasswordCoulumn変数一覧(Pioneer用)
                                            [ 変数名 ] = << 変数名 >>
            mt_vault_host_vars_file_list:   PasswordCoulumn変数のみのホスト変数一覧(Pioneer用)
                                            [ホスト名(IP)][ 変数名 ] = 具体値
            mt_DB_child_vars_list:          メンバー変数マスタの配列変数のメンバー変数リスト返却
                                            [ 変数名 ][メンバー変数名]=0
        Returns:
            bool, mt_host_vars, mt_pionner_template_host_vars, mt_vault_vars, mt_vault_host_vars_file_list, mt_DB_child_vars_list
        """
        vars_assign_seq_list = {}

        # T_ANSP_MVMT_VAR_LINKに対するDISUSE_FLAG = '0'の
        # 条件はSELECT文に入れない。
        # PHO_LINK_HOST_COUNT: 代入値管理のみあるホスト変数(作業対象ホストにない)はじくためのSELECT追加
        sql = """
            SELECT
                TBL_1.ASSIGN_ID,
                TBL_1.SYSTEM_ID,
                (
                 SELECT
                     COUNT(*)
                 FROM
                     {} TBL_4
                 WHERE
                     TBL_4.EXECUTION_NO = %s              AND
                     TBL_4.OPERATION_ID = %s              AND
                     TBL_4.MOVEMENT_ID  = %s              AND
                     TBL_4.SYSTEM_ID    = TBL_1.SYSTEM_ID AND
                     TBL_4.DISUSE_FLAG  = '0'
                ) AS PHO_LINK_HOST_COUNT,
                (
                 SELECT
                     TBL_3.HOST_NAME
                 FROM
                     T_ANSC_DEVICE TBL_3
                 WHERE
                     TBL_3.SYSTEM_ID = TBL_1.SYSTEM_ID AND
                     TBL_3.DISUSE_FLAG = '0'
                ) AS HOST_NAME,
                (
                 SELECT
                     COUNT(*)
                 FROM
                     {} TBL_6
                 WHERE
                     TBL_6.EXECUTION_NO = %s                           AND
                     TBL_6.OPERATION_ID = %s                           AND
                     TBL_6.MOVEMENT_ID  = %s                           AND
                     TBL_6.SYSTEM_ID    = TBL_1.SYSTEM_ID              AND
                     TBL_6.MVMT_VAR_LINK_ID  = TBL_1.MVMT_VAR_LINK_ID  AND
                     TBL_6.DISUSE_FLAG  = '0'
                ) AS VARS_NAME_COUNT,
                TBL_1.VARS_ENTRY,
                TBL_1.VARS_ENTRY_FILE,
                TBL_1.SENSITIVE_FLAG,
                TBL_1.ASSIGN_SEQ,
                TBL_2.VARS_NAME,
                TBL_2.DISUSE_FLAG
            FROM
                (
                 SELECT
                     TBL_3.ASSIGN_ID,
                     TBL_3.SYSTEM_ID,
                     TBL_3.MVMT_VAR_LINK_ID,
                     TBL_3.VARS_ENTRY,
                     TBL_3.VARS_ENTRY_FILE,
                     TBL_3.SENSITIVE_FLAG,
                     TBL_3.ASSIGN_SEQ
                 FROM
                     {} TBL_3
                 WHERE
                     TBL_3.EXECUTION_NO = %s AND
                     TBL_3.OPERATION_ID = %s AND
                     TBL_3.MOVEMENT_ID  = %s AND
                     TBL_3.DISUSE_FLAG  = '0'
                ) TBL_1
            LEFT OUTER JOIN {} TBL_2 ON ( TBL_1.MVMT_VAR_LINK_ID = TBL_2.MVMT_VAR_LINK_ID )
        ORDER BY HOST_NAME, VARS_NAME, ASSIGN_SEQ
        """
        sql = sql.format(self.AnscObj.vg_ansible_pho_linkDB,
                         self.AnscObj.vg_ansible_vars_assignDB,
                         self.AnscObj.vg_ansible_vars_assignDB,
                         self.AnscObj.vg_ansible_pattern_vars_linkDB)

        rows = self.lv_objDBCA.sql_execute(sql, [in_execute_no, in_operation_id, in_movement_id,
                                                 in_execute_no, in_operation_id, in_movement_id,
                                                 in_execute_no, in_operation_id, in_movement_id])
        mt_host_vars = {}
        mt_pionner_template_host_vars = {}
        tgt_row = []
        for row in rows:
            ret = self.setFileUploadCloumnFileEnv(row)
            if ret is not True:
                return False, mt_host_vars, mt_pionner_template_host_vars, mt_vault_vars, mt_vault_host_vars_file_list, mt_DB_child_vars_list
            #  具体値の暗号化が必要な場合で具体値が空の場合
            if row['SENSITIVE_FLAG'] == self.AnscObj.DF_SENSITIVE_ON:
                #  暗号化の処理をパスするようにしたいので、具体値を""に設定し暗号化不要に設定
                if not row['VARS_ENTRY']:
                    row['VARS_ENTRY'] = ""
                    row['SENSITIVE_FLAG'] = self.AnscObj.DF_SENSITIVE_OFF
            else:
                if not row['VARS_ENTRY']:
                    row['VARS_ENTRY'] = ""
            tgt_row.append(row)

        for row in tgt_row:
            #  mt_pionner_template_host_vars用の具体値
            row['VARS_ENTRY_PIONEER_TEMP'] = row['VARS_ENTRY']
            assign_seq = True
            if self.getAnsibleDriverID() in [self.AnscObj.DF_LEGACY_DRIVER_ID, self.AnscObj.DF_PIONEER_DRIVER_ID]:
                if not row['ASSIGN_SEQ']:
                    assign_seq = False

            if row['DISUSE_FLAG'] == '0':
                # 代入値管理のみあるホスト変数(作業対象ホストにない)をはじく
                if row['PHO_LINK_HOST_COUNT'] == 0:
                    continue

                if not row['HOST_NAME']:
                    msgstr = g.appmsg.get_api_message("MSG-10186", [row['ASSIGN_ID']])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    return (False, mt_host_vars, mt_pionner_template_host_vars, mt_vault_vars,
                            mt_vault_host_vars_file_list, mt_DB_child_vars_list)

                if not row['VARS_NAME']:
                    msgstr = g.appmsg.get_api_message("MSG-10188", [row['ASSIGN_ID']])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    return (False, mt_host_vars, mt_pionner_template_host_vars, mt_vault_vars,
                            mt_vault_host_vars_file_list, mt_DB_child_vars_list)

                # 複数行具体値判定
                ret = self.chkMultilineValue(row['VARS_ENTRY'])
                if ret is False:
                    msgstr = g.appmsg.get_api_message("MSG-10475", [row['VARS_NAME']])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    return (False, mt_host_vars, mt_pionner_template_host_vars, mt_vault_vars,
                            mt_vault_host_vars_file_list, mt_DB_child_vars_list)

                #  下記予約変数が使用されているかチェックする。
                #  親playbook(pioneer)に埋め込まれるリモート接続コマンド用変数の名前
                #  親playbook(legacy)に埋め込まれるリモートログインのユーザー用変数の名前
                #  対話ファイルに埋め込まれるリモートログインのパスワード用変数の名前
                #  対話ファイルに埋め込まれるホスト名用変数の名前
                if row['VARS_NAME'] in self.AnscObj.CannotValueAssign_ITA_sp_varlist:
                    msgstr = g.appmsg.get_api_message("MSG-10194", [row['HOST_NAME'], row['VARS_NAME']])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    return (False, mt_host_vars, mt_pionner_template_host_vars, mt_vault_vars,
                            mt_vault_host_vars_file_list, mt_DB_child_vars_list)

                #  代入値管理のみあるホスト変数(作業対象ホストにない)をはじく
                if row['PHO_LINK_HOST_COUNT'] > 0:
                    # 代入順序がブランクの場合はスキップ
                    if assign_seq is False:
                        continue

                    if self.getAnsibleDriverID() in [self.AnscObj.DF_LEGACY_DRIVER_ID, self.AnscObj.DF_PIONEER_DRIVER_ID]:
                        #  複数変数で代入順序が重複していないか判定する。
                        keyStr = "{}_{}_{}".format(row['HOST_NAME'], row['VARS_NAME'], row['ASSIGN_SEQ'])
                        if keyStr in vars_assign_seq_list:
                            msgstr = g.appmsg.get_api_message("MSG-10417", [row['ASSIGN_ID'],
                                                                            vars_assign_seq_list[keyStr],
                                                                            row['VARS_NAME'], row['ASSIGN_SEQ']])
                            self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                               str(inspect.currentframe().f_lineno), msgstr)

                            return (False, mt_host_vars, mt_pionner_template_host_vars, mt_vault_vars,
                                    mt_vault_host_vars_file_list, mt_DB_child_vars_list)

                        #  複数変数で代入順序の重複チェックリスト作成
                        vars_assign_seq_list[keyStr] = row['ASSIGN_ID']

                    #  具体値の暗号化が必要か判定 ----
                    if row['SENSITIVE_FLAG'] == self.AnscObj.DF_SENSITIVE_ON:
                        #  Pioneerの場合に暗号化を必要としている変数名リストを生成
                        if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                            # 対話ファイルの変数の具体値を変数名にする変数リスト設定
                            mt_vault_vars[row['VARS_NAME']] = "<< {} >>".format(row['VARS_NAME'])

                        indento_sp = ""
                        valut_value = ""
                        value = ky_decrypt(row['VARS_ENTRY'])
                        make_vaultvalue = self.makeAnsibleVaultValue(value, valut_value, indento_sp, row['ASSIGN_ID'])
                        if make_vaultvalue is False:
                            return (False, mt_host_vars, mt_pionner_template_host_vars, mt_vault_vars,
                                    mt_vault_host_vars_file_list, mt_DB_child_vars_list)

                        if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                            # pioneerの場合に具体値、base64+rot13でエンコードした具体値で上書き
                            row['VARS_ENTRY'] = self.ky_pioneer_encrypt(ky_decrypt(row['VARS_ENTRY']))
                        else:
                            # pioneer以外の場合に具体値、暗号化した具体値で上書き
                            row['VARS_ENTRY'] = make_vaultvalue

                        #  pioneer template用 ホスト変数にansible-vaultで暗号化した具体値で上書き
                        row['VARS_ENTRY_PIONEER_TEMP'] = make_vaultvalue

                    else:
                        # 複数行具体値の場合に複数行の扱い記号を付ける ----
                        row['VARS_ENTRY'] = self.makeMultilineValue(row['VARS_ENTRY'])
                        #  pioneer template用 ホスト変数用
                        row['VARS_ENTRY_PIONEER_TEMP'] = self.makeMultilineValue(row['VARS_ENTRY_PIONEER_TEMP'])
                        # -----複数行具体値の場合に複数行の扱い記号を付ける
                    #  ----具体値の暗号化が必要か判定

                    #  複数具体値変数で具体値が1つの場合の不備対応
                    if row['VARS_NAME_COUNT'] == 1 and not row['ASSIGN_SEQ']:
                        # ホスト変数配列作成
                        if row['HOST_NAME'] not in mt_host_vars:
                            mt_host_vars[row['HOST_NAME']] = {}
                        mt_host_vars[row['HOST_NAME']][row['VARS_NAME']] = row['VARS_ENTRY']

                        #  pioneer template用 ホスト変数用 ホスト変数配列作成
                        if row['HOST_NAME'] not in mt_pionner_template_host_vars:
                            mt_pionner_template_host_vars[row['HOST_NAME']] = {}
                        mt_pionner_template_host_vars[row['HOST_NAME']][row['VARS_NAME']] = row['VARS_ENTRY_PIONEER_TEMP']

                        if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                            #  暗号化されたホスト変数のリスト生成(pioneer用)
                            if row['SENSITIVE_FLAG'] == self.AnscObj.DF_SENSITIVE_ON:
                                if row['HOST_NAME'] not in mt_vault_host_vars_file_list:
                                    mt_vault_host_vars_file_list[row['HOST_NAME']] = {}
                                mt_vault_host_vars_file_list[row['HOST_NAME']][row['VARS_NAME']] = "\"" + row['VARS_ENTRY'] + "\""
                    else:
                        if row['HOST_NAME'] not in mt_host_vars:
                            mt_host_vars[row['HOST_NAME']] = {}
                        if row['VARS_NAME'] not in mt_host_vars[row['HOST_NAME']]:
                            mt_host_vars[row['HOST_NAME']][row['VARS_NAME']] = ""

                        if row['HOST_NAME'] not in mt_pionner_template_host_vars:
                            mt_pionner_template_host_vars[row['HOST_NAME']] = {}
                        if row['VARS_NAME'] not in mt_pionner_template_host_vars[row['HOST_NAME']]:
                            mt_pionner_template_host_vars[row['HOST_NAME']][row['VARS_NAME']] = ""

                        if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                            #  複数具体値変数は対話ファイルの変数の具体値に置換
                            if row['VARS_NAME'] in mt_vault_vars:
                                del mt_vault_vars[row['VARS_NAME']]

                        var_val = row['VARS_ENTRY']
                        if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                            if row['SENSITIVE_FLAG'] == self.AnscObj.DF_SENSITIVE_ON:
                                #  複数具体値の通番(0～)を求める
                                value_count = self.getArrayTypeValuecount(mt_host_vars[row['HOST_NAME']][row['VARS_NAME']])
                                #  複数具体値の場合の変数名を「変数名.x x:0からの通番」設定
                                varname = "{}.{}".format(row['VARS_NAME'], value_count)
                                #  暗号化されたホスト変数のリスト生成(pioneer用)
                                if row['HOST_NAME'] not in mt_vault_host_vars_file_list:
                                    mt_vault_host_vars_file_list[row['HOST_NAME']] = {}
                                mt_vault_host_vars_file_list[row['HOST_NAME']][varname] = "\"" + row['VARS_ENTRY'] + "\""
                                #  ホスト変数の具体値を「変数名.x x:0からの通番」設定
                                var_val = "\"<< " + varname + " >>\""
                            else:
                                #  Pioneerドライバの場合、先頭と末尾にダブルクォーテーションを付ける
                                var_val = "\"" + row['VARS_ENTRY'] + "\""

                        #  複数行具体値をjson形式で収める
                        retAry = self.ArrayTypeValue_encode(mt_host_vars[row['HOST_NAME']][row['VARS_NAME']], var_val)
                        value_count = retAry[0]
                        mt_host_vars[row['HOST_NAME']][row['VARS_NAME']] = retAry[1]

                        #  pioneer template用ホスト変数
                        retAry = self.ArrayTypeValue_encode(mt_pionner_template_host_vars[row['HOST_NAME']][row['VARS_NAME']],
                                                            row['VARS_ENTRY_PIONEER_TEMP'])
                        value_count = retAry[0]
                        mt_pionner_template_host_vars[row['HOST_NAME']][row['VARS_NAME']] = retAry[1]


            elif not row['DISUSE_FLAG']:
                msgstr = g.appmsg.get_api_message("MSG-10187", [row['ASSIGN_ID']])
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)

                return (False, mt_host_vars, mt_pionner_template_host_vars, mt_vault_vars,
                        mt_vault_host_vars_file_list, mt_DB_child_vars_list)
            #  DISUSE_FLAG = '1'は読み飛ばし

        #  代入順序がブランクの場合の処理は不要なのでコメントアウト
        for row in tgt_row:
            #  mt_pionner_template_host_vars用の具体値
            row['VARS_ENTRY_PIONEER_TEMP'] = row['VARS_ENTRY']
            #  代入順序がブランクか判定
            assign_seq = False
            if self.getAnsibleDriverID() in [self.AnscObj.DF_LEGACY_DRIVER_ID, self.AnscObj.DF_PIONEER_DRIVER_ID]:
                if not row['ASSIGN_SEQ']:
                    assign_seq = True

            if row['DISUSE_FLAG'] == '0':
                #  代入値管理のみあるホスト変数(作業対象ホストにない)をはじく
                if row['PHO_LINK_HOST_COUNT'] == 0:
                    continue

                if not row['HOST_NAME']:
                    msgstr = g.appmsg.get_api_message("MSG-10186", [row['ASSIGN_ID']])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)

                    return (False, mt_host_vars, mt_pionner_template_host_vars, mt_vault_vars,
                            mt_vault_host_vars_file_list, mt_DB_child_vars_list)

                if not row['VARS_NAME']:
                    msgstr = g.appmsg.get_api_message("MSG-10188", [row['ASSIGN_ID']])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)

                    return (False, mt_host_vars, mt_pionner_template_host_vars, mt_vault_vars,
                            mt_vault_host_vars_file_list, mt_DB_child_vars_list)

                # 複数行具体値判定
                ret = self.chkMultilineValue(row['VARS_ENTRY'])
                if ret is False:
                    msgstr = g.appmsg.get_api_message("MSG-10475", [row['VARS_NAME']])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)

                    return (False, mt_host_vars, mt_pionner_template_host_vars, mt_vault_vars,
                            mt_vault_host_vars_file_list, mt_DB_child_vars_list)

                #  下記予約変数が使用されているかチェックする。
                #  親playbook(pioneer)に埋め込まれるリモート接続コマンド用変数の名前
                #  親playbook(legacy)に埋め込まれるリモートログインのユーザー用変数の名前
                #  対話ファイルに埋め込まれるリモートログインのパスワード用変数の名前
                #  対話ファイルに埋め込まれるホスト名用変数の名前
                if row['VARS_NAME'] in self.AnscObj.CannotValueAssign_ITA_sp_varlist:
                    msgstr = g.appmsg.get_api_message("MSG-10194", [row['HOST_NAME'], row['VARS_NAME']])
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)

                    return (False, mt_host_vars, mt_pionner_template_host_vars, mt_vault_vars,
                            mt_vault_host_vars_file_list, mt_DB_child_vars_list)

                #  代入値管理のみあるホスト変数(作業対象ホストにない)をはじく
                if row['PHO_LINK_HOST_COUNT'] > 0:
                    #  代入順序がブランク以外の場合はスキップ
                    if assign_seq is False:
                        continue
                    #  具体値の暗号化が必要か判定 ----
                    if row['SENSITIVE_FLAG'] == self.AnscObj.DF_SENSITIVE_ON:
                        #  Pioneerの場合に暗号化を必要としている変数名リストを生成
                        if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                            # 対話ファイルの変数の具体値を変数名にする変数リスト設定
                            mt_vault_vars[row['VARS_NAME']] = "<< {} >>".format(row['VARS_NAME'])
                        indento_sp = ""
                        valut_value = ""
                        value = ky_decrypt(row['VARS_ENTRY'])
                        make_vaultvalue = self.makeAnsibleVaultValue(value, valut_value, indento_sp, row['ASSIGN_ID'])
                        if make_vaultvalue is False:
                            return (False, mt_host_vars, mt_pionner_template_host_vars, mt_vault_vars,
                                    mt_vault_host_vars_file_list, mt_DB_child_vars_list)

                        #  pioneer以外の場合に具体値を暗号化した具体値で上書き
                        if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                            # pioneerの場合に具体値、base64+rot13でエンコードした具体値で上書き
                            row['VARS_ENTRY'] = self.ky_pioneer_encrypt(ky_decrypt(row['VARS_ENTRY']))
                        else:
                            # pioneer以外の場合に具体値、暗号化した具体値で上書き
                            row['VARS_ENTRY'] = make_vaultvalue

                        #  pioneer template用 ホスト変数にansible-vaultで暗号化した具体値で上書き
                        row['VARS_ENTRY_PIONEER_TEMP'] = make_vaultvalue

                    else:
                        # 複数行具体値の場合に複数行の扱い記号を付ける ----
                        row['VARS_ENTRY'] = self.makeMultilineValue(row['VARS_ENTRY'])
                        #  pioneer template用 ホスト変数用
                        row['VARS_ENTRY_PIONEER_TEMP'] = self.makeMultilineValue(row['VARS_ENTRY_PIONEER_TEMP'])
                        # -----複数行具体値の場合に複数行の扱い記号を付ける
                    #  ----具体値の暗号化が必要か判定

                    #  複数具体値変数で具体値が1つの場合の不備対応
                    #  複数具体値変数で具体値が1つの場合の不備対応
                    if row['VARS_NAME_COUNT'] == 1 and not row['ASSIGN_SEQ']:
                        # ホスト変数配列作成
                        if row['HOST_NAME'] not in mt_host_vars:
                            mt_host_vars[row['HOST_NAME']] = {}
                        mt_host_vars[row['HOST_NAME']][row['VARS_NAME']] = row['VARS_ENTRY']

                        #  pioneer template用 ホスト変数用 ホスト変数配列作成
                        if row['HOST_NAME'] not in mt_pionner_template_host_vars:
                            mt_pionner_template_host_vars[row['HOST_NAME']] = {}
                        mt_pionner_template_host_vars[row['HOST_NAME']][row['VARS_NAME']] = row['VARS_ENTRY_PIONEER_TEMP']

                        if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                            #  暗号化されたホスト変数のリスト生成(pioneer用)
                            if row['SENSITIVE_FLAG'] == self.AnscObj.DF_SENSITIVE_ON:
                                if row['HOST_NAME'] not in mt_vault_host_vars_file_list:
                                    mt_vault_host_vars_file_list[row['HOST_NAME']] = {}
                                mt_vault_host_vars_file_list[row['HOST_NAME']][row['VARS_NAME']] = "\"" + row['VARS_ENTRY'] + "\""
                    else:
                        if row['HOST_NAME'] not in mt_host_vars:
                            mt_host_vars[row['HOST_NAME']] = {}
                        if row['VARS_NAME'] not in mt_host_vars[row['HOST_NAME']]:
                            mt_host_vars[row['HOST_NAME']][row['VARS_NAME']] = ""

                        if row['HOST_NAME'] not in mt_pionner_template_host_vars:
                            mt_pionner_template_host_vars[row['HOST_NAME']] = {}
                        if row['VARS_NAME'] not in mt_pionner_template_host_vars[row['HOST_NAME']]:
                            mt_pionner_template_host_vars[row['HOST_NAME']][row['VARS_NAME']] = ""

                        if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                            #  複数具体値変数は対話ファイルの変数の具体値に置換
                            if row['VARS_NAME'] in mt_vault_vars:
                                del mt_vault_vars[row['VARS_NAME']]

                        var_val = row['VARS_ENTRY']
                        if self.getAnsibleDriverID() == self.AnscObj.DF_PIONEER_DRIVER_ID:
                            if row['SENSITIVE_FLAG'] == self.AnscObj.DF_SENSITIVE_ON:
                                #  複数具体値の通番(0～)を求める
                                value_count = self.getArrayTypeValuecount(mt_host_vars[row['HOST_NAME']][row['VARS_NAME']])
                                #  複数具体値の場合の変数名を「変数名.x x:0からの通番」設定
                                varname = "{}.{}".format(row['VARS_NAME'], value_count)
                                #  暗号化されたホスト変数のリスト生成(pioneer用)
                                if row['HOST_NAME'] not in mt_vault_host_vars_file_list:
                                    mt_vault_host_vars_file_list[row['HOST_NAME']] = {}
                                mt_vault_host_vars_file_list[row['HOST_NAME']][varname] = "\"" + row['VARS_ENTRY'] + "\""
                                #  ホスト変数の具体値を「変数名.x x:0からの通番」設定
                                var_val = "\"<< " + varname + " >>\""
                            else:
                                #  Pioneerドライバの場合、先頭と末尾にダブルクォーテーションを付ける
                                var_val = "\"" + row['VARS_ENTRY'] + "\""

                        #  複数行具体値をjson形式で収める
                        retAry = self.ArrayTypeValue_encode(mt_host_vars[row['HOST_NAME']][row['VARS_NAME']], var_val)
                        value_count = retAry[0]
                        mt_host_vars[row['HOST_NAME']][row['VARS_NAME']] = retAry[1]

                        #  pioneer template用ホスト変数
                        retAry = self.ArrayTypeValue_encode(mt_pionner_template_host_vars[row['HOST_NAME']][row['VARS_NAME']],
                                                            row['VARS_ENTRY_PIONEER_TEMP'])
                        value_count = retAry[0]
                        mt_pionner_template_host_vars[row['HOST_NAME']][row['VARS_NAME']] = retAry[1]

            elif not row['DISUSE_FLAG']:
                msgstr = g.appmsg.get_api_message("MSG-10187", [row['ASSIGN_ID']])
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)

                return (False, mt_host_vars, mt_pionner_template_host_vars, mt_vault_vars,
                        mt_vault_host_vars_file_list, mt_DB_child_vars_list)
            #  DISUSE_FLAG = '1'は読み飛ばし

        #  変数未登録の場合もあるので fetch行数などはチェックしない。
        return (True, mt_host_vars, mt_pionner_template_host_vars, mt_vault_vars,
                mt_vault_host_vars_file_list, mt_DB_child_vars_list)

    def var_check(self, dialog_file_name, host_name, dialog_file_vars, host_variable_file_array):
        for dialog_row in dialog_file_vars:
            command = ""
            for dialog_key, dialog_var in dialog_row.items():
                if isinstance(dialog_var, str) is False:
                    dialog_var = str(dialog_var)
                dialog_key = dialog_key.strip()
                if command == "":
                    command = dialog_key
                varString = r"{{[\s][a-zA-Z0-9_]*[\s]}}"
                match = re.findall(varString, dialog_var)
                if len(match) == 0:
                    if dialog_key == "with_items":
                        msgstr = g.appmsg.get_api_message("MSG-10620", [host_name, dialog_file_name, dialog_var])
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        return False

                if len(match) > 1:
                    if dialog_key == "with_items":
                        msgstr = g.appmsg.get_api_message("MSG-10621", [dialog_file_name])
                        self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                           str(inspect.currentframe().f_lineno), msgstr)
                        return False

                if len(match) == 1:
                    # 変数名を抜出す
                    keyFilter = r"[\s][a-zA-Z0-9_]*[\s]"
                    var_name = re.findall(keyFilter, match[0])
                    var_name = var_name[0].strip()
                    if var_name in host_variable_file_array:
                        # 複数具体値か判定
                        if isinstance(host_variable_file_array[var_name], list):
                            # 複数具体値
                            if dialog_key != "with_items":
                                msgstr = g.appmsg.get_api_message("MSG-10619", [host_name, dialog_file_name, dialog_var])
                                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                                   str(inspect.currentframe().f_lineno), msgstr)
                                return False

                        else:
                            # 単一具体値
                            if dialog_key == "with_items":
                                msgstr = g.appmsg.get_api_message("MSG-10620", [host_name, dialog_file_name, dialog_var])
                                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                                   str(inspect.currentframe().f_lineno), msgstr)
                                return False

        return True

    def value_extraction(self, dialog_array, key_name, mt_dialog_line_list):
        """
        処理内容
          対話ファイルの内容を行単位のリスト型に変換する。
        パラメータ
          key_name:            行毎のキー名
          dialog_array:        対話ファイルをパースした内容
                               想定対話ファイル
                                 conf:
                                   timeout: 10
                                 exec_list:
                                   - expect: 'assword:'
                                     exec: '{{ __loginpassword__ }}'
                                   - localaction: "{{ VAR_localaction_cmd }}"
                                     ignore_errors: "{{ VAR_localaction_ignore_errors_YES }}"
                                  - state: "{{ VAR_state_cmd }}"
                                    prompt: "{{ VAR_pro }}"
                                    shell: "{{ VAR_state_shell }}"
                                    stdout_file: "{{ VAR_state_stdout }}"
                                    success_exit: "{{ VAR_state_success_exit_NO }}"
                                    ignore_errors: "{{ VAR_state_ignore_errors_YES }}"
                                    parameter:
                                      - "{{ VAR_state_list_ok_1 }}"
                                      - "{{ VAR_state_list_ok_2 }}"
                                  - command: 'echo {{ item.0 }} {{ item.1 }} {{ VAR_1 }}  >> /temp/plog'
                                    prompt:  '{{ item.2 }}'
                                    timeout: '{{ item.3 }}'
                                    when:
                                      - VAR_when is undefine
                                    exec_when:
                                      - "{{ item.4 }} == OK"
                                    failed_when:
                                      - stdout match({{ item.5 }})
                                    with_items:
                                      - '{{ VAR_list_1 }}'
                                      - '{{ VAR_list_2 }}'
                                      - '{{ VAR_prompt_list }}'
                                      - '{{ VAR_timeout_list }}'
                                      - '{{ VAR_exec_when_list }}'
                                      - '{{ VAR_failed_when_list }}'
          key_name:            行毎のキー名
          mt_dialog_line_list: 行単位に変換したリスト型
                               [{'timeout': 10},
                                {'expect': 'assword:'},
                                {'exec': '{{ __loginpassword__ }}'},
                                {'localaction': 'echo {{ VAR_line }}'},
                                {'localaction': '{{ VAR_localaction_cmd }}'},
                                {'ignore_errors': '{{ VAR_localaction_ignore_errors_YES }}'},
                                {'state': '{{ VAR_state_cmd }}'},
                                {'prompt': '{{ VAR_pro }}'},
                                {'shell': '{{ VAR_state_shell }}'},
                                {'stdout_file': '{{ VAR_state_stdout }}'},
                                {'success_exit': '{{ VAR_state_success_exit_NO }}'},
                                {'ignore_errors': '{{ VAR_state_ignore_errors_YES }}'},
                                {'parameter': '{{ VAR_state_list_ok_1 }}'},
                                {'parameter': '{{ VAR_state_list_ok_2 }}'},
                                {'command': 'echo {{ item.0 }} {{ item.1 }} {{ VAR_1 }}  >> /temp/plog'},
                                {'prompt': '{{ item.2 }}'},
                                {'timeout': '{{ item.3 }}'},
                                {'when': 'VAR_when is undefine'},
                                {'exec_when': '{{ item.4 }} == OK'},
                                {'failed_when': 'stdout match({{ item.5 }})'},
                                {'with_items': '{{ VAR_list_1 }}'},
                                {'with_items': '{{ VAR_list_2 }}'},
                                {'with_items': '{{ VAR_prompt_list }}'},
                                {'with_items': '{{ VAR_timeout_list }}'},
                                {'with_items': '{{ VAR_exec_when_list }}'},
                                {'with_items': '{{ VAR_failed_when_list }}'}]
        戻り値
          true: 正常
          行単位に変換したリスト型
        """
        for line_key, dialog_line_array in self.php_array(dialog_array):
            if isinstance(dialog_line_array, dict) or isinstance(dialog_line_array, list):
                self.value_extraction(dialog_line_array, line_key, mt_dialog_line_list)
            else:
                if type(line_key) is int:
                    pass
                else:
                    # 該当行のキー名を上書き
                    key_name = line_key
                mt_dialog_line_list.append({key_name: dialog_line_array})
        return True, mt_dialog_line_list

    def nestArrayDefineCheck(self, nestArray, FstItem, SstItem):
        if FstItem in nestArray:
            if SstItem in nestArray[FstItem]:
                return True
        return False

    def ky_pioneer_encrypt(self, lcstr):
        # BASE64でエンコード
        tmp_str = base64.b64encode(lcstr.encode())
        # rot13でエンコード
        return codecs.encode(tmp_str.decode(), "rot_13")

    def ky_pioneer_decrypt(self, lcstr):
        # rot13でデコード
        tmp_str = codecs.decode(lcstr, "rot_13")
        # base64でデコード
        return base64.b64decode(tmp_str.encode()).decode()

    def chkVariableValue(self, var_name, ina_host_vars, chkVarDict, errParamList, other_Var_chk_error_no):
        result_code = True
        if var_name not in ina_host_vars:
            if var_name in chkVarDict:
                error_no = chkVarDict[var_name]
                # ITA独自変数の具体値が設定されていることを判定
                msgstr = g.appmsg.get_api_message(error_no, errParamList)
                self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                   str(inspect.currentframe().f_lineno), msgstr)
                result_code = False
            else:
                # pioneerの対話ファイルの変数具体値登録チェックの場合のみ、変数登録の有無判定
                if other_Var_chk_error_no:
                    msgstr = g.appmsg.get_api_message(other_Var_chk_error_no, errParamList)
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    result_code = False
        else:
            if var_name in chkVarDict:
                error_no = chkVarDict[var_name]
                # ITA独自変数を使用している場合に機器一覧に該当データが登録されているか判定
                if ina_host_vars[var_name] == self.LC_ANS_UNDEFINE_NAME:
                    msgstr = g.appmsg.get_api_message(error_no, errParamList)
                    self.LocalLogPrint(os.path.basename(inspect.currentframe().f_code.co_filename),
                                       str(inspect.currentframe().f_lineno), msgstr)
                    result_code = False

        return result_code


